<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[sbxfc]]></title>
  <link href="http://sbxfc.github.io/atom.xml" rel="self"/>
  <link href="http://sbxfc.github.io/"/>
  <updated>2016-11-02T20:09:23+08:00</updated>
  <id>http://sbxfc.github.io/</id>
  <author>
    <name><![CDATA[sbxfc]]></name>
    <email><![CDATA[sbxfc17@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WLAN密钥流解密]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/01/wlan-stream-cipher/"/>
    <updated>2016-11-01T16:10:22+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/01/wlan-stream-cipher</id>
    <content type="html"><![CDATA[<h1>解密操作</h1>

<blockquote><p>使用工具 Wireshark 和 Aircrack-ng</p></blockquote>

<p>首先,打开 Wireshark 并监听无线网接口。如果已开启WIFI,这时候就可以看到许多杂乱无章的捕获数据。</p>

<p>我们进行一下过滤,通过过滤 Beacon帧来寻找WIFI热点(Access Point,简称AP)。Beacon 是由热点发出的,用于告知设备自己的存在的数据帧。Beacon 是管理帧 type=00 (即0x00),并且 subtype=1000(即0x08):</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp75c54425.png" alt="ws" /></p>

<p>选择一个WIFI热点,然后点击查看其帧信息,并记录下MAC地址。(看名称可知,这是一个苹果的网卡接口,是一台开着共享的Mac电脑):</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp11983903.png" alt="ws" /></p>

<p>接着,我们以这个MAC地址线索再寻找一个与其相连的设备。(这个设备是我的iPad,因为之前获得过这个WIFI的密码,所以我把iPad的完整MAC地址隐藏掉了)</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp0a502955.png" alt="ws" /></p>

<p>在得到设备和热点的MAC地址后,我们就可以通过一些工具尝试让他们解除认证,然后抓取他们重连时的认证信息。这里,我用了之前自己写的小工具:</p>

<p><a href="https://github.com/sbxfc/wlan-macos/tree/master/deauth">https://github.com/sbxfc/wlan-macos/tree/master/deauth</a></p>

<pre><code>$ make
$ ./deauth en1 -s xx:xx:xx:xx:b0:73 -a c8:e0:eb:58:34:bd --rate 1 - number 10
</code></pre>

<p>在运行上面的示例之前,要确保你的 Wireshark 正在处于抓包状态。执行后,如果发现捕获到了四次握手数据就可以停止Wireshark了,如果没有那就再来一次。</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp2c8e7312.png" alt="ws" /></p>

<p>在成功捕获握手数据之后,将捕获数据进行保存（Wireshark->文件->另存为）。然后打开 Aircrack-ng 对数据进行解密。 Aircrack-ng 实际上是通过现有的密码字典通过PRG算法生成密钥流与加密后的流进行一系列的比对,从而找到正确的密码值。也就是说,如果你的WiFi密码设置的越复杂也就越难以破解。</p>

<p>在使用 Aircrack-ng 对数据流进行解密时,我们需要一个密码字典,你可以从网上下一个常用的密码字典。在确定设备上安装  Aircrack-ng 之后,就可以在终端下开始解密了:</p>

<pre><code>aircrack-ng -w /Volumes/sbxfc/pwd_dic/破解字典/wordlist/wordlist.txt /Users/sbxfc/Downloads/tmp.pcap
</code></pre>

<p>在运行之后,程序会询问你选择哪一个目标,一般是第一个,后面标识 handshake。输入序列号,然后回车。由于我选择的WIFI热点密码太过简单,回车之后立刻就返回结果了:</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp53ad4572.png" alt="ws" /></p>

<h1>四次握手</h1>

<p>802.11i 中的 RSN（Robust Security Network）定义了在无线网络下的一个安全的连接流程。这个流程也就是 RSNA（Robust Security Network Association）,定义了认证、加密以及密钥管理。</p>

<p>STA 通过 802.1x 的认证后,AP 与 STA 都会拿到同一组 session key。有RADIUS(认证服务器)时称为 PMK(Pairwise Master Key),无 RADIUS 时 PSK(Pre-Shared Key) 即PMK。之后进行 4-way handshake。</p>

<blockquote><p>在没有RADIUS时,AP 与 STA 会预先设定好一组passphrase,并用来衍生出PMK。</p></blockquote>

<p>对于网络安全而言,key愈少愈好。因此 4-way handshake 用来建立 512 bits的PTK(Pairwise Transient Key)。PTK 由 PMK,AP Nonce,STA Nonce,AP&#8217;MAC,STA&#8217;MAC生成。4-way handshake 也会产生GTK（Group Temporal Key）,用来解密 multicast和broadcast traffic。这个GTK是所有STA公用一个key。</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp13152092.png" alt="4-handshake" /></p>

<ol>
<li>AP 发送 ANonce 至 STA。</li>
<li>STA 收到后,用 ANonce 和已知信息生成PTK,并通过PTK中的KCK生成检验码MIC,附上SNonce 发送至 AP。</li>
<li>AP 收到后也生成 PTK,然后用PTK中的KCK部分对MIC进行校验。成功,则发送GTK和MIC至STA。</li>
<li>STA 答复。</li>
</ol>


<p>WPA1 TKIP的 PTK 长度512bits,WPA2 CCMP的PTK长度为384bits。其中,TMK1 和 TMK2 只用在 TKIP 加密data时。</p>

<table>
<thead>
<tr>
<th>区域 </th>
<th> 简称 </th>
<th> 长度</th>
<th> 名称 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-127   </td>
<td> KCK  </td>
<td> 128 bits</td>
<td> EAPOL-Key Confirmation Key</td>
<td> 计算WPA EAPOL key message 的MIC</td>
</tr>
<tr>
<td>128-255  </td>
<td> KEK  </td>
<td> 128 bits</td>
<td> EAPOL-Key Encryption Key</td>
<td> 加密额外要送给STA的data,如 GTK or RSN IE</td>
</tr>
<tr>
<td>256-383  </td>
<td> TEK </td>
<td> 128 bits</td>
<td> Temporal Encryption Key</td>
<td> 解密unicast packets</td>
</tr>
<tr>
<td>384-447  </td>
<td> TMK1  </td>
<td> 64 bits</td>
<td> Temporal AP Tx MIC Key</td>
<td> 计算AP 发送的unicast packet的MIC</td>
</tr>
<tr>
<td>448-511  </td>
<td> TMK2  </td>
<td> 64 bits</td>
<td> Temporal AP Rx MIC Key</td>
<td> 计算STA 发送的unicast packet的MIC</td>
</tr>
</tbody>
</table>


<p>生成PTK算法:</p>

<p>首先使用PBKDF2（Password-Based Key Derivation Function 2）算法生成一个32字节的PMK key，该算法需要执行4096*2轮,同时由于使用了SSID（0-32字符）进行salt。</p>

<pre><code> PMK = PBKDF2(HMAC−SHA1, pwd, ssid, 4096, 256)
</code></pre>

<p>PTK使用PRF-512（pseudo random functions 512bits）算法产生，通过PMK、固定字符串、AP_Mac、Sta_Mac、ANonce、SNonce六个输入参数得到一个512 bits的PTK。</p>

<pre><code> PTK = PRF-512(PMK, “Pairwise key expansion”, Min(AP_Mac, Sta_Mac) ||Max(AP_Mac, Sta_Mac) || Min(ANonce, SNonce) || Max(ANonce, SNonce))
</code></pre>

<p>生成MIC算法:</p>

<pre><code>//WAP1
MIC = HMAC(EVP_sha1(), KCK, 16, eapol_data，eapol_size) 
//WAP2
MIC = HMAC(EVP_md5(), KCK, 16, eapol_data，eapol_size)
</code></pre>

<h1>解密原理</h1>

<p><img src="http://sbxfc.github.io/images/2016/10/142303547147.png" alt="4-handshake" /></p>

<p>破解时,利用我们字典中 PSK 和 ssid 生成PMK。</p>

<p>然后结合已知的MAC，AP的BSSID，A-NONCE，S-NONCE计算出PTK。</p>

<p>然后加上原始的报文数据算出MIC,并与AP发送的MIC比较。如果一致，那么该PSK就是密钥。</p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86">https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看类UNIX系统下的进程]]></title>
    <link href="http://sbxfc.github.io/blog/2016/10/17/unix-ps/"/>
    <updated>2016-10-17T16:52:11+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/10/17/unix-ps</id>
    <content type="html"><![CDATA[<h1>ps</h1>

<p>ps程序 ( process status 的简称) 是类Unix系统下用来查看系统进程的命令。在终端里,不带参数运行时,该命令显示与当前登陆用户相关的bash命令:</p>

<pre><code>$ps
 PID  TTY        TIME    CMD
 6122 ttys003    0:00.25 -bash
 6356 ttys003    0:00.01 /Users/sbxfc/...
</code></pre>

<p>如果添加 <font color='#bd260d'><strong>-l</strong></font> 参数,则会在此基础上显示更详细的信息:</p>

<pre><code>$ps -l
  UID  PID   PPID     F     CPU PRI NI SZ        RSS  WCHAN  S   ADDR TTY           TIME CMD
  501  6122  6121     4006   0  31  0  2463084   3212 -      S   0    ttys003    0:00.26 -bash
  501  6356     1     4006   0  31  0  2463148   3052 -      S   0    ttys003    0:00.01 /Users/sbxfc/...
</code></pre>

<p>如果是查看所有程序,通常会使用 <font color='#bd260d'><strong>aux</strong></font> 参数。其中 <font color='#bd260d'><strong>a</strong></font> 列出了一个终端上的所有进程,包括其他用户运行的,<font color='#bd260d'><strong>x</strong></font>列出所有没有控制终端的进程,<font color='#bd260d'><strong>u</strong></font> 添加了一列显示每个进程的控制用户。需要注意的是，为了提高兼容性，使用此语法时&#8221;aux&#8221; 前没有 &ldquo;&ndash;&rdquo; 。</p>

<pre><code>$ps aux
USER   PID   %CPU %MEM VSZ     RSS      TT  STAT STARTED   TIME COMMAND
sbxfc  6105  12.1 1.1  3034064 141676  ??  S    4:55下午  5:00.59 /Applications/Google Chrome.app/Contents/...
sbxfc  5813  5.6  0.5  2784956 62488   ??  S    3:47下午  0:35.94 /Applications/Utilities/Terminal.app/Contents
sbxfc  261   4.6  1.8  3049408 223952  ??  S    9:55上午  19:03.62 /Applications/QQ.app/Contents/MacOS/QQ
sbxfc  6552  2.5  0.2  2516792 22536   ??  S    6:34下午  0:00.35 /System/Library/Frameworks/CoreServices...
...
</code></pre>

<h1>配合grep使用</h1>

<p>ps 可以配合 grep 使用并擦出火花:</p>

<pre><code>$ ps aux | grep chrome
sbxfc 6720   0.0  0.0  2434840    772 s001  S+    7:01下午   0:00.00 grep chrome
</code></pre>

<h1>其他有用参数</h1>

<p>指定用户运行的进程:</p>

<pre><code>$ ps -u sbxfc
</code></pre>

<h1>对应列名</h1>

<table>
<thead>
<tr>
<th>列名  </th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td> %CPU</td>
<td>  进程正在使用多少个CPU</td>
</tr>
<tr>
<td> %MEM</td>
<td>  进程正在使用多少内存</td>
</tr>
<tr>
<td>ADDR    </td>
<td>进程的内存地址</td>
</tr>
<tr>
<td>C或CP</td>
<td> CPU使用率和调度信息</td>
</tr>
<tr>
<td>COMMAND*    </td>
<td>进程名，包括参数（如果有的话）</td>
</tr>
<tr>
<td>NI  </td>
<td>nice值</td>
</tr>
<tr>
<td>F   </td>
<td>标志</td>
</tr>
<tr>
<td>PID </td>
<td>进程ID</td>
</tr>
<tr>
<td>PPID    </td>
<td>父进程ID</td>
</tr>
<tr>
<td>PRI </td>
<td>进程优先级</td>
</tr>
<tr>
<td>RSS </td>
<td>真实内存用量</td>
</tr>
<tr>
<td>S or STAT   </td>
<td>进程状态码</td>
</tr>
<tr>
<td>START or STIME  </td>
<td>进程启动时间</td>
</tr>
<tr>
<td>SZ  </td>
<td>虚拟内存用量</td>
</tr>
<tr>
<td>TIME    </td>
<td>总CPU用量</td>
</tr>
<tr>
<td>TT或TTY    </td>
<td>与进程相关的终端</td>
</tr>
<tr>
<td>UID或USER  </td>
<td>进程所有者的用户名</td>
</tr>
<tr>
<td>WCHAN   </td>
<td>进程所等待事件的内存地址</td>
</tr>
</tbody>
</table>


<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Ps_(Unix)">https://zh.wikipedia.org/wiki/Ps_(Unix)</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds4/ps.htm">https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds4/ps.htm</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php#process_1">http://linux.vbird.org/linux_basic/0440processcontrol.php#process_1</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DNS查询工具 ]]></title>
    <link href="http://sbxfc.github.io/blog/2016/10/10/dns/"/>
    <updated>2016-10-10T11:15:36+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/10/10/dns</id>
    <content type="html"><![CDATA[<h1>DNS(Domain Name System 域名系统)</h1>

<p>域名服务器常见记录类型列表:</p>

<table>
<thead>
<tr>
<th>代码</th>
<th> 描述 </th>
<th> 功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>A </td>
<td> 主机记录  </td>
<td> 指定域名对应的主机IP地址。</td>
</tr>
<tr>
<td>CNAME </td>
<td> 别名记录  </td>
<td> 可以将其他域名指向到A记录,这个别名可以是域名也可以是IP地址</td>
</tr>
<tr>
<td>AAAA </td>
<td> IPv6主机记录  </td>
<td> 与A记录对应，用于将特定的域名映射到一个主机的IPv6地址。</td>
</tr>
<tr>
<td>MX </td>
<td> 邮件交互记录  </td>
<td> 用于将以该域名为结尾的电子邮件指向对应的邮件服务器以进行处理。</td>
</tr>
<tr>
<td>NS </td>
<td> 名称服务器记录 </td>
<td> 当前域下的DNS服务器。</td>
</tr>
</tbody>
</table>


<p><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8">域名服务器记录类型列表</a></p>

<h1>nslookup</h1>

<p>nslookup 是一款非常有用的 DNS 查询工具,可以指定查询类型,可以查到DNS记录的生存时间,还可以指定使用哪个DNS服务器进行解析。</p>

<p>查询指定域名的IP地址:</p>

<pre><code>$ nslookup
&gt; rungame.me
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
rungame.me  canonical name = sbxfc.github.io.
sbxfc.github.io canonical name = github.map.fastly.net.
github.map.fastly.net   canonical name = prod.github.map.fastlylb.net.
Name:   prod.github.map.fastlylb.net
Address: 151.101.36.133
&gt;exit
</code></pre>

<p>前面的 Server: 和 Address: 是你电脑所使用的DNS服务器地址,可以看出 rungame.me 的一个别名是 sbxfc.github.io 、github.map.fastly.net、prod.github.map.fastlylb.net 的别名,rungame.me对应的IP地址是 151.101.36.133。</p>

<p>查询域名服务器:</p>

<pre><code>$ nslookup
&gt; set type=NS
&gt; sina.com.cn
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
sina.com.cn nameserver = ns4.sina.com.cn.
sina.com.cn nameserver = ns2.sina.com.cn.
sina.com.cn nameserver = ns1.sina.com.cn.
sina.com.cn nameserver = ns3.sina.com.cn.

Authoritative answers can be found from:
&gt;exit
</code></pre>

<p>通过指定DNS服务器来查询域名的IP:</p>

<pre><code>$ nslookup - 8.8.8.8
&gt; 163.com
Server:     8.8.8.8
Address:    8.8.8.8#53

Non-authoritative answer:
Name:   163.com
Address: 123.58.180.8
Name:   163.com
Address: 123.58.180.7
&gt;exit
</code></pre>

<p>当然也可以写成这种形式:</p>

<pre><code>$ nslookup 163.com 8.8.8.8
</code></pre>

<p>查看邮件服务器:</p>

<pre><code>$ nslookup
&gt; set type=MX
&gt; 163.com
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
163.com mail exchanger = 10 163mx01.mxmail.netease.com.
163.com mail exchanger = 10 163mx02.mxmail.netease.com.
163.com mail exchanger = 10 163mx03.mxmail.netease.com.
163.com mail exchanger = 50 163mx00.mxmail.netease.com.

Authoritative answers can be found from:
&gt; set type=A
&gt; 163mx01.mxmail.netease.com
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.138
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.137
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.140
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.142
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.141
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.143
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.139
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.135
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.136
</code></pre>

<h1>查看顶级域信息</h1>

<pre><code>$ nslookup - 8.8.8.8
&gt; set type=ns
&gt; me.
Server:     8.8.8.8
Address:    8.8.8.8#53

Non-authoritative answer:
me  nameserver = a0.cctld.afilias-nst.info.
me  nameserver = a2.me.afilias-nst.info.
me  nameserver = b0.cctld.afilias-nst.org.
me  nameserver = b2.me.afilias-nst.org.
me  nameserver = c0.cctld.afilias-nst.info.
me  nameserver = d0.cctld.afilias-nst.org.
me  nameserver = ns.nic.me.
me  nameserver = ns2.nic.me.

Authoritative answers can be found from:
&gt; 
</code></pre>

<h1>dig</h1>

<p>dig和nslookup的使用类似。</p>

<pre><code>$ dig soa rungame.me

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; soa rungame.me
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 28257
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;rungame.me.            IN  SOA

;; ANSWER SECTION:
rungame.me.     600 IN  SOA f1g1ns1.dnspod.net. freednsadmin.dnspod.com. 1476082444 3600 180 1209600 180

;; Query time: 371 msec
;; SERVER: 114.114.114.114#53(114.114.114.114)
;; WHEN: Mon Oct 10 18:42:26 2016
;; MSG SIZE  rcvd: 105
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F</a></li>
<li><a href="https://zh.wikipedia.org/wiki/MX%E8%AE%B0%E5%BD%95">https://zh.wikipedia.org/wiki/MX%E8%AE%B0%E5%BD%95</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8</a></li>
<li><a href="https://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/network-dns.html">https://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/network-dns.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GNU C 中的 __attribute__ 机制]]></title>
    <link href="http://sbxfc.github.io/blog/2016/09/21/attribute-syntax/"/>
    <updated>2016-09-21T18:31:09+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/09/21/attribute-syntax</id>
    <content type="html"><![CDATA[<h1>__attribute__ 机制</h1>

<p>__attribute__ 是 GCC 提供的一种语法,可以帮助我们在编译时对声明的函数、变量和类型做一些特殊处理或者是检查操作。</p>

<p>__attribute__ 的语法格式为: <font color='#bd260d'><strong>__attribute__ ((attribute-list))</strong></font> , attribute-list 是指令集 , __attribute__ 出现在函数、变量和类型声明的 <font color='#bd260d'><strong>&ldquo;;&rdquo;</strong></font> 前。</p>

<p>__attribute__ 有三类,分别为函数属性(Function Attribute) 、变量属性(Variable  Attribute) 和类型属性(Type  Attribute)</p>

<h1>一,函数属性</h1>

<p><font color='#bd260d'><strong>1. format (archetype, string-index, first-to-check)</strong></font></p>

<p>format 属性通过指定 <em>printf, scanf, strftime</em> 或 <em>strfmon</em> 等方法来检测函数的参数是否同样适用于这些指定的格式化字符串方法,如果不适用,编译器在编译时的就会发出警告,从而发现错误。</p>

<pre><code>extern int
my_printf (int value, const char *my_format, ...)
__attribute__ ((format (printf, 2, 3)));

void foo()
{
    my_printf(0, "age = %d\n",17);
    my_printf(0, "age = %d\n","17");
    my_printf(0, "age = %d name = %s\n",17,"sbxfc");
}
</code></pre>

<p>上面示例中, format 属性的第一个参数指定了一个 printf 方法,第二个参数 string-index  表示函数 my_printf 里格式化参数是总参数的第几个,这里我们的格式化参数 <font color='#bd260d'><strong>my_format</strong></font> 是第2个参数,format 属性的第三个参数表示,参数集合 (<font color='#bd260d'><strong>&hellip;</strong></font>) 从函数 my_printf 的第几个参数开始出现。</p>

<p>如无意外,上述示例在 gcc 编译时会提示以下警告信息:</p>

<pre><code>$ gcc -c main.c
main.c:12:31: warning: format specifies type 'int' but the argument has type
  'char *' [-Wformat]
my_printf(0, "age = %d\n","17");
</code></pre>

<p>去掉 __attribute__ 属性,该示例则不会提示错误,但运行时会出错。</p>

<p><font color='#bd260d'><strong>2.  noreturn </strong></font></p>

<p>noreturn 属性表示其指定的函数没有返回值,当编译器执行到这时,要面对现实,不要大惊小怪(~慌忙报错~)。下面是 fatal 的部分代码,在程序出错的位置调用 fatal 函数打印信息,然后直接退出程序,不需要 return。</p>

<pre><code>void fatal () __attribute__ ((noreturn));

void
fatal (/* ... */)
{
  /* ... */ /* Print error message. */ /* ... */
  exit (1);
}
</code></pre>

<p><font color='#bd260d'><strong>3.  deprecated </strong></font></p>

<p>deprecated 属性可以用来标识一个预计将会被弃用的函数,如果开发者使用该函数,编译时就会发出警告,并提示出错的行数。警告信息只会在开发者调用该函数时才会提示:</p>

<pre><code>int old_fn () __attribute__ ((deprecated));
int old_fn ();
int (*fn_ptr)() = old_fn;
</code></pre>

<p>在上面示例中,只会在第3行提出警告:</p>

<pre><code>main.c:7:19: warning: 'old_fn' is deprecated [-Wdeprecated-declarations]
int (*fn_ptr)() = old_fn;
                    ^
main.c:6:5: note: 'old_fn' has been explicitly marked deprecated here
int old_fn ();
</code></pre>

<p>deprecated 也可以用于<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Variable-Attributes.html#Variable-Attributes">变量</a>和<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Type-Attributes.html#Type-Attributes">类型</a>。</p>

<p><font color='#bd260d'><strong> 4. constructor &amp; destructor</strong></font></p>

<p>设置 constructor 属性可以使函数在 main 方法之前执行,而设置 destructor 可以使函数在 main 方法之后执行。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

__attribute__((constructor)) void before_func (){
  printf("before \n");
}

__attribute__((destructor)) void after_func (){
  printf("after \n");
}

int main(){
  printf("main func \n");
  return 0;
}
</code></pre>

<p>不出意外,会看到以下输出:</p>

<pre><code>$ gcc main.c
$ ./a.out 
before 
main func 
after   
</code></pre>

<p>constructor 、 destructor 函数也可以设置执行的优先级:</p>

<pre><code>__attribute__((constructor(PRIORITY)))
__attribute__((destructor(PRIORITY)))
</code></pre>

<h1>二,变量属性</h1>

<p><font color='#bd260d'><strong> 1.  aligned (alignment) </strong></font></p>

<p>aligned 属性让其指定的变量或结构体成员按 alignment 字节大小对齐。如果其中对齐长度有长度大于 alignment的,则按照最大对齐长度来对齐。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//结构体的对齐值为8
struct foo {
  char a;
  int x[2] __attribute__ ((aligned (8)));
};

int main(){
  int s0 = sizeof(struct foo);
  printf("s0 = %d\n",s0);//print s0 = 16
  return 0;
}
</code></pre>

<p><font color='#bd260d'><strong> 2.  packed </strong></font></p>

<p>packed 属性用于设置变量或结构体成员以最小的对齐方式对齐。</p>

<p>在下面的结构体中,由于 x 已经使用 packed 进行对齐,所以此时结构体以 a 的size来对齐:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct foo{
  char a;
  int x[2] __attribute__ ((packed));
};

int main(){
  int s0 = sizeof(struct foo);
  printf("s0 = %d\n",s0);//print s0 = 9
  return 0;
}
</code></pre>

<h1>三,类型属性</h1>

<p><font color='#bd260d'><strong> 1. packed </strong></font></p>

<p>如果 packed 属性用在 struct 或 union 上,表示该结构的成员变量按照紧凑模式对齐,即以变量的实际占用字节对齐,不用编译器进行优化对齐。如果用在 enum 上,则表示使用最小的整数来存储枚举类型。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct my_unpacked_struct{
  char c;
  int i;
};

struct __attribute__ ((__packed__)) my_packed_struct {
   char c;
   int  i;
   struct my_unpacked_struct s;
};

int main(){
  int s0 = sizeof(struct my_unpacked_struct);
  int s1 = sizeof(struct my_packed_struct);
  printf("s0 = %d,s1 = %d\n",s0,s1);//print s0 = 8,s1 = 13
  return 0;
}
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html">https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Function-Attributes.html</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Variable-Attributes.html#Variable-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Variable-Attributes.html#Variable-Attributes</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Type-Attributes.html#Type-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Type-Attributes.html#Type-Attributes</a></li>
<li><a href="http://blog.zhangjikai.com/2015/11/28/%E3%80%90C%E3%80%91alignment/">http://blog.zhangjikai.com/2015/11/28/%E3%80%90C%E3%80%91alignment/</a></li>
<li><a href="http://www.jianshu.com/p/6153eccdbe62">http://www.jianshu.com/p/6153eccdbe62</a></li>
<li><a href="http://blog.wangruofeng007.com/blog/2016/01/13/attribute/">http://blog.wangruofeng007.com/blog/2016/01/13/attribute/</a></li>
<li><a href="http://unixwiz.net/techtips/gnu-c-attributes.html">http://unixwiz.net/techtips/gnu-c-attributes.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS - Property的修饰词]]></title>
    <link href="http://sbxfc.github.io/blog/2016/09/14/objc-modifiers/"/>
    <updated>2016-09-14T14:11:45+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/09/14/objc-modifiers</id>
    <content type="html"><![CDATA[<h1>原子性</h1>

<p><font color='#bd260d'><strong>nonatomic/atomic</strong></font>  是objc里有关属性原子操作的两种修饰词,其中 nonatomic 是非线程安全的,即不对 setter/getter 操作进行加锁,而 atomic 会对生成的 setter/getter 添加<font color='#bd260d'><strong>类似于</strong></font>下面这样的互斥锁操作:</p>

<pre><code>- (void) setProperty:(property_type *) property {
    @synchronized(self){
        _property = property;
    }
}
</code></pre>

<p>尽管,Apple 可能会使用一些比 @synchronized 更加高级的互斥操作,但是由于 atomic 本身并不能保证已加锁的类和对象是 <font color='#bd260d'><strong>thread safe</strong></font> 的,并且 atomic 在加锁时会消耗一些系统资源,我们一般会用 nonatomic 来作为修饰词。</p>

<p>需要注意的是,如果你没有在属性上键入 nonatomic 修饰词,编译器会把 atomic 当做默认修饰词( <a href="http://stackoverflow.com/questions/5168331/why-is-atomic-a-default-property-qualifier-in-objective-c-when-i-find-myself"><font color='#bd260d'><strong>吐槽看这里</strong></font></a> )。</p>

<h1>读写权限</h1>

<p><font color='#bd260d'><strong>readwrite/readonly</strong></font> 定义了属性的访问权限,其中 readwrite 是可读写,当你声明这个修饰词时,编译器会生成该属性的 setter/getter方法。readonly 为只读,当声明该属性时只会生成 getter 方法。</p>

<p>假如你只声明了 readonly 权限,但自己手动实现了 setter 方法,该属性也会变成可读可写的(囧)。所有属性,如果未声明读写权限,编译器会以 readwrite 作为默认方式处理。</p>

<h1>内存管理</h1>

<p><font color='#bd260d'><strong>1.  strong/retain</strong></font> 在 MRC (Mannul Reference Counting) 时代,当我们想得到一个对象的控制权时,我们会对该对象进行 retain 操作。这样一来,该对象的引用次数就会增加1,即便在其他地方,该对象的其他指针被置为 nil 或者是被 release过一次。但由于其总引用次数没有减小至0,系统依旧不会释放该对象,不会出现 &ldquo;EXC_BAD_ACCESS&rdquo; 错误。</p>

<pre><code>/**
 * 使用retain标识属性的内存处理方式时,会在 setter 方法里,
 * 对传入的对象进行引用计数加1的操作。
 */
-(void)setProperty:(property_type*)property{  
     if ( _property != property){  
          [_property release];  
          _property = [property retain];  
     }  
}
</code></pre>

<p>进入 ARC (Auto Reference Counting) 时代,retain 被 strong 取代了。实际上,在ARC环境里,无论是使用 strong 还是 retain ,其作用是完全一致的, strong = retain 。但 ARC 环境里,因为编译器会帮我们自动处理 setter 和 getter 里的 retain 和 release 操作,这时用 strong 修饰词就显得更 ARC 的语意。</p>

<p>在objc里,object 类型的属性默认内存处理方式是 strong,也就是说,即便你没有指明 object 属性内存修饰词时,系统会默认按照 strong 的方式处理该属性。而基本类型(int、float、double、NSInteger，CGFloat等) 的属性,其默认是以 <font color='#bd260d'><strong>assign</strong></font> 的方式处理的。</p>

<p><font color='#bd260d'><strong>2.  assign/weak/unsafe_unretained</strong></font> 使用 assign 修饰的属性,在赋值时 setter 方法里进行的是简单的指针拷贝,并没有像 retain 或 strong 那样进行引用计数的增加。对于基本类型,由于其本身是由系统自动分配和管理的,不需要考虑内存问题,所以可以直接使用指针来赋值。但如果用 assign 修饰 object 属性,一旦属性指向的对象中的其中一个引用指针被为nil,系统就会回收该对象,由此会导致,当我们访问该 object 属性时出现 &ldquo;EXC_BAD_ACCESS&rdquo; 错误。</p>

<p>对于 object 类型的属性,如果我们不想持有该属性指向的对象。我们可以使用 weak 修饰词,weak 修饰词和 assign 类似 ,唯一的区别是,当 weak 修饰的属性如果其指向对象的指针在别处被置为nil,导致该对象被释放,那么 weak 属性里的成员变量指针也会被置为nil,从而不会出现野指针的情况。(delegate 和 Outlet 一般用weak来声明。)。</p>

<p>在ARC之前,我们通常用 assign 来修饰基本类型,而 unsafe_unretained 则通常用于“对象类型”,unsafe_unretained 与 assign 是等价的,在实际使用时 unsafe_unretained 修饰“基础类型”并不会报错 。进入ARC之后,我们用weak代替unsafe_unretained修饰“对象类型”。</p>

<p><font color='#bd260d'><strong>3.  copy</strong></font> 与strong类似，但区别在于属性的成员变量是对传入对象的副本拥有所有权，而非对象本身。</p>

<h1>参见</h1>

<ul>
<li><a href="http://stackoverflow.com/questions/5168331/why-is-atomic-a-default-property-qualifier-in-objective-c-when-i-find-myself">http://stackoverflow.com/questions/5168331/why-is-atomic-a-default-property-qualifier-in-objective-c-when-i-find-myself</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于属性和成员变量的疑惑]]></title>
    <link href="http://sbxfc.github.io/blog/2016/09/13/objc-property/"/>
    <updated>2016-09-13T10:03:20+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/09/13/objc-property</id>
    <content type="html"><![CDATA[<h1>成员变量和属性</h1>

<p>在objc里变量有两种写法，一种是以 <font color='#bd260d'><strong>@property</strong></font> 形式声明的属性,另一种是定义在大括号里 (<font color='#bd260d'><strong>@interface :NSObject{}</strong></font> )的成员变量( <font color='#bd260d'><strong>instance variable</strong></font> )。</p>

<pre><code>@interface MyObject : NSObject {
    NSInteger memberVar; // 成员变量
}

@property NSInteger value; // 属性

@end
</code></pre>

<p>这两者有什么区别呢?</p>

<p>从设计的角度上来讲, @property 方式声明的属性,主要是用来暴露给外部访问用的。而成员变量( instance variable )是内部变量,主要用作内部使用,外部无法访问。</p>

<p>需要留意的是,成员变量既可以在 <font color='#bd260d'><strong>@interface :NSObject{}</strong></font> 里声明,也可以在 <font color='#bd260d'><strong>@Implementation :NSObject{}</strong></font> 里声明。在 <font color='#bd260d'><strong>@Interface</strong></font> 区域声明的成员变量默认权限是protected,能被被子类访问,而在 <font color='#bd260d'><strong>@implementation</strong></font>里声明的成员变量权限是private。在 <font color='#bd260d'><strong>@implementation</strong></font> 里定义私有成员变量更符合面向对象的封装原则,因为此类别的信息不会暴露于公开的interface中。</p>

<p>成员变量和属性在访问时也有所不同,属性可以用<font color='#bd260d'><strong>点表达式(.)</strong></font> 来访问(<font color='#bd260d'><strong>self.name</strong></font>),而成员变量,因为是内部变量可以直接使用变量名(<font color='#bd260d'><strong>name</strong></font>)访问或者通过<font color='#bd260d'><strong>右箭头(&ndash;>)</strong></font>来访问(<font color='#bd260d'><strong>self->name</strong></font>)。</p>

<h1>属性的声明</h1>

<p>经常看到有的人用 <font color='#bd260d'><strong>@property</strong></font>声明了属性,又在<font color='#bd260d'><strong>@interface</strong></font>里定义了相同的成员变量。</p>

<pre><code>@interface MyObject : NSObject{
    NSInteger value;
}

@property NSInteger value;
@end
</code></pre>

<p>首先应当了解一下 @property 的用法。当我们用 @property （和 @synthsize) 声明一个属性时,在 .h 文件里 @property会让编译器帮我们创建两个存取方法的声明:</p>

<pre><code>- (NSInteger)propertyName;      
- (void)setPropertyName:(NSInteger)value;
</code></pre>

<p>而在 .m 文件里, <font color='#bd260d'><strong>@synthesize propertyName</strong></font> 会告诉编译器,帮我们创建这两个声明的实现函数,并且以 propertyName 命名该属性的成员变量。</p>

<pre><code>- (void)setPropertyName:(NSInteger)value{   
    propertyName  =  value;
}

- (NSInteger)propertyName{
    return  propertyName;
}
</code></pre>

<p>因此,在使用 @property （和 @synthsize) 声明属性时,编译器帮我们生成读写方法的同时,也会自动创建一个成员变量,不需要我们手动去创建。</p>

<p>假如,我们不想使用现有的属性名作为成员变量名,我们可以将 <font color='#bd260d'><strong>@synthesize propertyName</strong></font> 改为 <font color='#bd260d'><strong>@synthsize propertyName = xxx</strong></font>  的形式,这样我们的成员变量就变成了 <font color='#bd260d'><strong>xxx</strong></font>。Xcode4.5 以后,如果我们没有写 @synthsize ,系统会为我们自动生成一个 @synthsize 并指定一个以下划线 ( <font color='#bd260d'><strong>_</strong></font> ) 为前缀,加上属性名的成员变量,即  <font color='#bd260d'><strong>@synthsize propertyName = _propertyName</strong></font> 。</p>

<h1>.h和.m文件</h1>

<p>在objc里,类的定义（interface）与实现（implementation）被分成了两个部分。我们知道在 @interface 里面定义的属性和函数主要用于外部访问,但是这里有一个的前提条件:</p>

<pre><code>//MyObject.h
@interface MyObject : NSObject{
    NSInteger memberVar1;
}

@end

//MyObject.m
@interface MyObject(){
    NSInteger memberVar2;
}

@end
</code></pre>

<p>在上面的 .h 和 .m文件里的两个 @interface 定义区域里,我们分辨创建了两个成员变量 memberVar1 和 memberVar2。其中在 .h 里面写的成员变量会暴露出来,而在 .m里写的变量外界是看不到的,也不能访问。</p>

<p>当我们在子类里访问该类的成员变量时,只能看到暴露出来的memberVar1。</p>

<p><img src="http://sbxfc.github.io/images/2016/9/tmp799c4889.png" alt="" /></p>

<p><font color='#bd260d'><strong>所有定义在 .m文件里的变量和函数,无论是 @interface 还是 @implementation ,外界是无法访问的。</strong></font></p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Objective-C">https://zh.wikipedia.org/wiki/Objective-C</a></li>
<li><a href="http://www.cnblogs.com/letmefly/archive/2012/07/20/2601338.html">http://www.cnblogs.com/letmefly/archive/2012/07/20/2601338.html</a></li>
<li><a href="http://www.devtalking.com/articles/you-should-to-know-property/">http://www.devtalking.com/articles/you-should-to-know-property/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译一个C程序]]></title>
    <link href="http://sbxfc.github.io/blog/2016/07/07/compile/"/>
    <updated>2016-07-07T15:37:57+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/07/07/compile</id>
    <content type="html"><![CDATA[<p>GCC是类Unix操作系统下的标准编译器,在Linux或者是以FreeBSD为基础的macOS下可以直接使用。</p>

<h1>编译一个简单的C程序</h1>

<p>下面的代码被包含在一个名为<font color='#bd260d'><strong>test.c</strong></font>的文本文件里:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(){
    printf("Hello World!\n");
}   
</code></pre>

<p>你可以通过macOS终端直接编译该文件:</p>

<pre><code>$gcc test.c -o test
</code></pre>

<p>编译指令会将test.c编译成一个名为test的可执行程序,<font color='#bd260d'><strong>-o</strong></font>参数用于指定编译后的程序名。 执行程序<font color='#bd260d'><strong>(./test)</strong></font>时屏幕上会输出 <em>Hello World!</em></p>

<p>除此之外,你也可以执行下面两行编译命令来生成test程序</p>

<pre><code>$gcc -c test.c
$gcc test.o -o test
</code></pre>

<p>和第一条编译命令相比,除了执行命令多出一行以外,还额外生成了一个名为test.o的文件。这是因为,GCC在编译C程序时要经过预处理、编译、汇编和连接四步。通过第二种方式,编译器首先会将源文件test.c编译成名为hello.o的机器语言程序。接着,再将hello.o和一些用于输出&#8221;Hello World&#8221;的系统库链接在一起,并合成最终的可执行程序test。</p>

<p>而第一种方式同样执行了这两步,只不过编译器在后台悄悄运行,并删除了中间文件test.o</p>

<h1>编译参数</h1>

<p>在编译时,我们可以指定一些参数来告诉编译器如何编译我们的程序</p>

<p>在编译命令里加入<font color='#bd260d'><strong>-g</strong></font>选项,可以开启 gdb 对程序进行调试,通过输入命令 <font color='#bd260d'><strong>gdb ./test</strong></font>进入调试模式</p>

<pre><code>$gcc -g test.c -o test
</code></pre>

<p>在编译命令里加入<font color='#bd260d'><strong>-Wall</strong></font>选项会打印出程序编译时的警告信息,包括一些语法问题。</p>

<pre><code>$gcc -Wall test.c -o test
</code></pre>

<p>加入 <font color='#bd260d'><strong>-O</strong></font>选项,开启默认优化。</p>

<pre><code>$gcc -O test.c -o test
</code></pre>

<p>加入 <font color='#bd260d'><strong>-shared</strong></font> ,用来生成共享文件<font color='#bd260d'><strong>*.so</strong></font>(Shared Object)</p>

<pre><code>$gcc -shadred test.c -o libtest.so
</code></pre>

<h1>链接库（-l&amp;-L）</h1>

<p>当程序需要一些系统库或我们自己生成的类库时,并且这个库文件是在以下三个目录之中时,<font color='#bd260d'><strong>/lib、/usr/lib和/usr/local/lib</strong></font>,我们就可以在编译指令里加入<font color='#bd260d'><strong>-l</strong></font>参数来指定编译时需要链接的库文件。</p>

<p>-l参数和其他参数的用法有所不同,-l后面不加空格并直接跟要链接的库名,比如说我们要连接的库为libm.dylib数学库,那么我们要写成<font color='#bd260d'><strong>-lm</strong></font>的形式,即库名去掉lib和.dylib后的库名。这样,编译器在链接时就会自动在目录<font color='#bd260d'><strong>/lib、/usr/lib和/usr/local/lib</strong></font>下寻找要链接的库文件</p>

<pre><code>gcc test.c -o test -lm
</code></pre>

<p>但是,如果要链接的库不在这三个目录之列时,通过-l链接就会出错。这时可以用到<font color='#bd260d'><strong>-L</strong></font>参数。-L参数用来指定库的目录位置。比如我们用到当前项目下的lib文件夹里的库文件(<font color='#bd260d'><strong>../lib</strong></font>),我们可以写成如下格式:</p>

<pre><code>gcc test.c -o test -L../lib
</code></pre>

<h1>指定头文件目录(-I)</h1>

<p>有时,我们会将头文件放在一个统一的目录里,比如<font color='#bd260d'><strong>include</strong></font>文件夹。
这时候,我们可以在编译指令里加入<font color='#bd260d'><strong>-I</strong></font>参数来指定头文件的目录</p>

<pre><code>gcc test.c -o test -I./include
</code></pre>

<p>当然你也可以在引用头文件的时写成完整路径的形式<font color='#bd260d'><strong>./include/header.h</strong></font></p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/GCC">https://zh.wikipedia.org/wiki/GCC</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/04/03/2998652.html">http://www.cnblogs.com/vamei/archive/2013/04/03/2998652.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动化编译之make]]></title>
    <link href="http://sbxfc.github.io/blog/2016/07/01/makefile/"/>
    <updated>2016-07-01T11:36:32+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/07/01/makefile</id>
    <content type="html"><![CDATA[<p><em>注1：本中使用的make为GNU Make</em></p>

<h1>源文件的编译</h1>

<p>通常,我们将源代码编译成可执行程序时,首先要将源代码文件编译成中间文件(Windows下为.obj文件,在Unix下为.o文件),这个过程称为编译（compile）。然后,将大量的中间文件合成最终执行文件的过程称为链接（link）。</p>

<p>其中,链接主要是链接函数和全局变量,链接器不关心函数所在的源文件,只关心函数的中间文件。有时候生成的中间目标文件太多,而链接时需要明显指出中间目标名,这对于编译很不方便。所以,我们要给中间文件打个包,在Windows下这种包叫“库文件”（Library File),也就是 .lib 文件,在UNIX下,是Archive File,也就是 .a 文件。</p>

<h1>Makefile的使用</h1>

<p>当编译一个大型项目时,往往需要许多次调用编译器,并根据依赖关系,逐步编译整个项目。而通过make工具来处理这些复杂的依赖关系时,我们不需要频繁输入 gcc 命令,而只需要执行一次make就可以完成整个编译过程。所有的依赖关系都被记录在Makefile文本中</p>

<pre><code>target ... : prerequisites ... 
    command 
    ... 
    ... 
</code></pre>

<p>上面是一个基本的Makefile结构,target 用来指定一个目标文件，可以是中间文件，也可以是执行文件。 prerequisites 就是,要生成那个target所依赖的文件或目标。command 也就是生成目标文件make需要执行的命令</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_01.png" alt="make.png" /></p>

<p>上面是一个简单的make示例,test.c程序输出hello world,这个makefile的工作流程如下:</p>

<p>1,当make命令执行时,程序会搜索当前目录下的makefile,Makefile或者GNUmakefile。</p>

<p>2,如果找到,它会找文件中的第一个目标文件(target),在上面的例子中,他会找helloworld这个目标文件,并把这个文件作为最终的目标文件。</p>

<p>3,如果helloworld不存在,或是edit所依赖的后面的.o文件比helloworld这个文件新,那么他就会执行后面的命令来生成这个文件。</p>

<p>4,如果helloworld所依赖的.o文件也存在,那么make会在当前文件夹中找目标.o文件的依赖性,如果找到则再根据那一个规则生成.o。(直到所有的依赖关系都找到,类似于堆栈的过程。)</p>

<p>5,当所有的中间文件.o都存在的时候,make就会执行终极任务,生成helloworld。</p>

<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。</p>

<h1>宏</h1>

<p>当我们往生成最终目标helloworld的依赖里添加了一个用于输出时间的工具类时,这时我们需要在依赖目标里,添加一个print_time.o,然后在command里添加print_time.o,由于我们的makefile并不复杂,所以在这两处修改并不麻烦。但是,如果makefile变得复杂,我们可能会漏掉一个需要加入的地方而导致编译失败。为了维护方便,这时,我们可以在makefile使用宏,类似于文本类型的变量。</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_02.png" alt="make.png" /></p>

<h1>make自动推导</h1>

<p>GNU Make可以说是体贴入微,有些command不需要我们写出,make可以自动推导出该命令,比如生成目标test.o时,可以省略为  <font color='#bd260d'>test.o:</font></p>

<p>只要make看见一个.o目标文件,它就会自动的把.c文件加到依赖关系中,如果make找到一个test.o,那么test.c,就会是test.o的依赖文件。并且 <font color='#bd260d'>gcc -c test.c -o test.o</font> 也会被推导出来</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_03.png" alt="make.png" /></p>

<p>如果觉得这样写看着不太舒服,也可以直接改为下面的终极格式:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_04.png" alt="make.png" /></p>

<h1>清理</h1>

<p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的功能,这不仅便于重编译,也很利于保持文件的清洁。</p>

<pre><code>clean :
-rm helloworld $(objects) 
</code></pre>

<h1>示例</h1>

<ul>
<li><a href="https://github.com/sbxfc/gnu-make">https://github.com/sbxfc/gnu-make</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IEEE 802.11 WLAN协议]]></title>
    <link href="http://sbxfc.github.io/blog/2016/06/23/wlan/"/>
    <updated>2016-06-23T15:27:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/06/23/wlan</id>
    <content type="html"><![CDATA[<p><img src="http://sbxfc.github.io/images/2016/6/ieee80211.png" alt="IEEE_802_11" /></p>

<p>在上面的示意图里,Preamble(序言)和PLCP header是物理层驱动的使用的一些信息,而我们获取的MAC层协议帧是MPDU部分,MPDU是Mac protocal data unit的简称,即IEEE 802.11在 MAC 层的数据单元。</p>

<p>MPDU分为三大类:管理帧、控制帧和数据帧。通过Frame Control里的Type值,我们可以判断当前数据帧是什么类型:</p>

<ul>
<li><p>管理帧(00) 这类数据帧主要用来进行身份验证,发送信号(Beacon)等。</p></li>
<li><p>控制帧(01) 发送RTS/CTS,ACK等一些查询和控制响应帧。</p></li>
<li><p>数据帧(10) 携带更高层的数据(如IP数据包，ISO7层协议)。</p></li>
</ul>


<p>在这三个大类下面,又会根据subtype的不同将数据帧分为不同的类型。</p>

<p>由于,每种数据帧对应的数据格式是不同的(<font color='#bd260d'><strong>除了Frame control部分以外</strong></font>),所以说如果我们解析某个数据帧格式,需要根据具体的类型来判断:</p>

<h1>管理帧(00)</h1>

<p>管理帧根据subtype的不同,又分为如下类型:</p>

<table>
<thead>
<tr>
<th> subtype  </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 </td>
<td> Association request (关联请求) </td>
</tr>
<tr>
<td>0001 </td>
<td> Association response (关联响应)  </td>
</tr>
<tr>
<td>0010 </td>
<td> Reassociation request（重关联请求）</td>
</tr>
<tr>
<td>0011 </td>
<td> Reassociation response（重关联响应）</td>
</tr>
<tr>
<td>1010 </td>
<td> Disassociation（解除关联）</td>
</tr>
<tr>
<td>0100 </td>
<td> Probe request（探测请求）</td>
</tr>
<tr>
<td>0101 </td>
<td> Probe response（探测响应）</td>
</tr>
<tr>
<td>1000 </td>
<td> Beacon（信标,由AP发出,告知BSS的存在）</td>
</tr>
<tr>
<td>1001 </td>
<td> ATIM（通知传输指示消息）</td>
</tr>
<tr>
<td>1011 </td>
<td> Authentication（身份验证）</td>
</tr>
<tr>
<td>1100 </td>
<td> Deauthentication（解除认证）</td>
</tr>
<tr>
<td>1101～1111</td>
<td>Reserved（保留，未使用）</td>
</tr>
</tbody>
</table>


<p>Beacon帧格式:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/ieee80211_beacon.jpeg" alt="IEEE_802_11" /></p>

<p>Probe Request帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/probe_request.jpg" alt="IEEE_802_11" /></p>

<p>Probe Response帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/probe_esponse.jpg" alt="IEEE_802_11" /></p>

<p>ATIM帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/atim.jpg" alt="IEEE_802_11" /></p>

<p>Disassociation与Deauthentication帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/dd.jpg" alt="IEEE_802_11" /></p>

<p>Association Request帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/association_request.jpg" alt="IEEE_802_11" /></p>

<p>Reassociation Request帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/reassociation_request.jpg" alt="IEEE_802_11" /></p>

<p>Authentication帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/authentication.jpg" alt="IEEE_802_11" /></p>

<h1>控制帧(01)</h1>

<table>
<thead>
<tr>
<th> Subtype值   </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1010 </td>
<td>Power Save- Poll（省电－轮询,由休眠的AP定时发送）</td>
</tr>
<tr>
<td>1011 </td>
<td>RTS（Request To Send,请求发送,预约信道,帧长20字节）</td>
</tr>
<tr>
<td>1100 </td>
<td>CTS（Clear To Send,清除发送,收到RTS后,如果同意预约,就通过CTS告知其他人在一定时间内暂停向自己发送数据,避免冲突,帧长14字节）</td>
</tr>
<tr>
<td>1101 </td>
<td>ACK（确认收到的数据帧,如果收到的数据帧校验出错，则不发送ACK，等待重传。）</td>
</tr>
<tr>
<td>1110 </td>
<td>CF-End（无竞争周期结束,让STA脱离协调模式，开始基于竞争模式。)</td>
</tr>
<tr>
<td>1111 </td>
<td>CF-End＋CF-ACK（无竞争周期结束+无竞争周期确认）</td>
</tr>
</tbody>
</table>


<p>RTS帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/rts.jpg" alt="IEEE_802_11" /></p>

<p>CTS帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/cts.jpg" alt="IEEE_802_11" /></p>

<p>ACK帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/ack.jpg" alt="IEEE_802_11" /></p>

<p>PS-Poll:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/pspoll.jpg" alt="IEEE_802_11" /></p>

<h1>数据帧(10)</h1>

<table>
<thead>
<tr>
<th> Subtype值   </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0000 </td>
<td> Data（传输数据）</td>
</tr>
<tr>
<td> 0001 </td>
<td> Data+CF-ACK</td>
</tr>
<tr>
<td> 0010 </td>
<td> Data+CF-Poll</td>
</tr>
<tr>
<td> 0011 </td>
<td> Data+CF-ACK+CF-Poll</td>
</tr>
<tr>
<td> 0100 </td>
<td> Null（无数据的空帧）</td>
</tr>
<tr>
<td> 0101 </td>
<td> CF-ACK（无竞争周期的确认,用于确认之前所收到的帧）</td>
</tr>
<tr>
<td> 0110 </td>
<td> CF-Poll（无竞争周期的轮询,用于通知已经没有数据要传输）</td>
</tr>
<tr>
<td> 0111 </td>
<td> Data+CF-ACK+CF-Poll</td>
</tr>
<tr>
<td> 1000 </td>
<td> Qos Data</td>
</tr>
<tr>
<td> 1001 </td>
<td> Qos Data + CF-ACK</td>
</tr>
<tr>
<td> 1010 </td>
<td> Qos Data + CF-Poll</td>
</tr>
<tr>
<td> 1011 </td>
<td> Qos Data + CF-ACK+ CF-Poll</td>
</tr>
<tr>
<td> 1100 </td>
<td> QoS Null（未传送数据）</td>
</tr>
<tr>
<td> 1101 </td>
<td> QoS CF-ACK（未传送数据）</td>
</tr>
<tr>
<td> 1110 </td>
<td> QoS CF-Poll（未传送数据）</td>
</tr>
<tr>
<td> 1111 </td>
<td> QoS CF-ACK+ CF-Poll（未传送数据）</td>
</tr>
</tbody>
</table>


<p>IBSS帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/ibss.jpg" alt="IEEE_802_11" /></p>

<p>由接入点发出的数据帧格式(From AP):</p>

<p><img src="http://sbxfc.github.io/images/2016/6/from_ap.jpg" alt="IEEE_802_11" /></p>

<p>发送至接入点的数据帧格式(To AP):</p>

<p><img src="http://sbxfc.github.io/images/2016/6/to_ap.jpg" alt="IEEE_802_11" /></p>

<p>WDS数据帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/wds.jpg" alt="IEEE_802_11" /></p>

<h1>RadioTap</h1>

<p>当无线网络接口处于monitor模式时,内核会生成一个名为RadioTap的数据添加在IEEE802.11数据帧(MPDU)的前面,该Radiotap记录了热点的信息,如信号强度、MPDU帧信息等信息。意思就是在正常的IEEE802.11数据帧前面,内核又额外给你加了一块RadioTap类型的数据,这块数据记录了一些无线网的属性。</p>

<pre><code>---------------------
|--Header--|--Data--|
---------------------
</code></pre>

<p>RadioTap的结构包括Header和Data两部分,首先看一眼Header:</p>

<pre><code>struct ieee80211_radiotap_header {
    u_int8_t        it_version;     /* set to 0 */
    u_int8_t        it_pad;
    u_int16_t       it_len;         /* entire length */
    u_int32_t       it_present;     /* fields present */
} __attribute__((__packed__));
</code></pre>

<p>it_version 是一个8位的版本号,值始终为0,it_pad未使用,只作字段对齐用,it_len 是整个Radiotap的长度,如果你不关心Radiotap里具体包含哪些信息,可以通过这个值跳过解析Radiotap的解析。it_present 是Data数据的掩码,标识哪些数据出现在接下来的Data里。</p>

<p>在这里面,it_present是最有趣的一个值,它总共有32位,里面的每一位都代表一种数据有没有出现在接下来的Data里。什么意思呢,我们知道每一位的值无非就是0和1两个值,如果该位是1则表示该位代表的数据在RadioTap里的Data部分携带了,并且每一位对应什么值都可以在这里(<a href="http://www.radiotap.org/defined-fields">http://www.radiotap.org/defined-fields</a>)查到,例如是它的size多大或是它代表了啥含义。</p>

<p>it_present代表的数据出场顺序与这32个掩码的位置是依次相关的。也就是第一位携带的数据如果有,永远是靠在最前的,其他的依次排列。通常it_present的最后一位Ext为0,此时Data紧随it_present之后出现。如果Ext为1,表明开发者增加了it_present字段,每个增加的it_present大小都是标准的32位,直到最后一个Ext为0的it_present出现时,Data才会紧接着出现。除Ext之外Present中倒数第2、3位是设备厂商的保留位，不能作为Data掩码使用。</p>

<pre><code>.... .... .... .... .... .... .... ...1 = TSFT : True
.... .... .... .... .... .... .... ..1. = Flags: True
.... .... .... .... .... .... .... .1.. = Rate : True
.... .... .... .... .... .... .... 1... = Channel : True
.... .... .... .... .... .... ...0 .... = FHSS : False
.... .... .... .... .... .... ..1. .... = Antenna signal  : False
.... .... .... .... .... .... .0.. .... = Antenna noise : False 
.... .... .... .... .... .... 0... .... = Lock quality : False
.... .... .... .... .... ...0 .... .... = TX attenuation : False 
.... .... .... .... .... ..0. .... .... = dB TX attenuation : False 
.... .... .... .... .... .0.. .... .... = dBm TX power : False  
.... .... .... .... .... 1... .... .... = Antenna  : True
.... .... .... .... ...0 .... .... .... = dB antenna signal : False
.... .... .... .... ..0. .... .... .... = dB antenna noise : False
.... .... .... .... .1.. .... .... .... = RX flags : False
.... .... .... .... 0... .... .... .... = MCS : False
.... .... .... ...0 .... .... .... .... = A-MPDU status : False
.... .... .... ..0. .... .... .... .... = VHT : False
.... .... .... .0.. .... .... .... .... = ... 
0... .... .... .... .... .... .... .... = Ext:False
</code></pre>

<p>掩码对应信息:</p>

<table>
<thead>
<tr>
<th> 位置编码</th>
<th> 大小 </th>
<th>名称</th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0  </td>
<td>  8byte   </td>
<td> TSFT </td>
<td> 只对接收帧有效,表示MPDU第一个bit到达MAC时的时间,单位是微秒</td>
</tr>
<tr>
<td>1  </td>
<td>  1byte   </td>
<td> Flags</td>
<td> 发送或接收帧属性,包括一些有用信息,比如FCS是否符合 </td>
</tr>
<tr>
<td>2  </td>
<td>  1byte   </td>
<td> Rate </td>
<td> 传输或接收速率,单位500kbs</td>
</tr>
<tr>
<td>3  </td>
<td>  2byte   </td>
<td>  Channel </td>
<td> 发送接收信号的频率，单位是MHz</td>
</tr>
<tr>
<td>4  </td>
<td>  1byte   </td>
<td>  FHSS </td>
<td> 跳频技术，是无线通讯最常用的扩频方式之一</td>
</tr>
<tr>
<td>5  </td>
<td>  1byte   </td>
<td> Antenna signal </td>
<td> 天线的射频信号强度，单位是dBm</td>
</tr>
<tr>
<td>6  </td>
<td>  1byte   </td>
<td> Antenna noise  </td>
<td> 天线的射频噪声强度，单位是dBm；</td>
</tr>
<tr>
<td>7  </td>
<td>  2byte   </td>
<td> Lock quality </td>
<td> 信号质量</td>
</tr>
<tr>
<td>8  </td>
<td>  2byte   </td>
<td> TX attenuation </td>
<td> 与出厂标准最大功率相比的功率衰减，0为最大功率</td>
</tr>
<tr>
<td>9  </td>
<td>  2byte   </td>
<td> dB TX attenuation </td>
<td> 与出厂标准最大功率相比的功率衰减dB值，0为最大功率</td>
</tr>
<tr>
<td>10 </td>
<td>  1byte   </td>
<td> dBm TX power </td>
<td> 传输功率的dBm值，这是在天线端口测量的功率绝对值</td>
</tr>
<tr>
<td>11 </td>
<td>  1byte   </td>
<td> Antenna </td>
<td> 发送或接收该帧的天线索引编号（硬件编号从0开始）；</td>
</tr>
<tr>
<td>12 </td>
<td>  1byte   </td>
<td> dB antenna signal </td>
<td> 天线的射频信号的相对功率强度dB值；</td>
</tr>
<tr>
<td>13 </td>
<td>  1byte   </td>
<td> dB antenna noise </td>
<td> 天线的射频噪音的相对功率强度dB值；</td>
</tr>
</tbody>
</table>


<h1>示例</h1>

<ul>
<li><a href="https://github.com/sbxfc/wlan-macos">https://github.com/sbxfc/wlan-macos</a></li>
</ul>


<h1>参考</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/IEEE_802.11">https://zh.wikipedia.org/wiki/IEEE_802.11</a></li>
<li><a href="http://www.radiotap.org/">http://www.radiotap.org/</a></li>
<li><a href="http://www.radiotap.org/defined-fields">http://www.radiotap.org/defined-fields</a></li>
<li><a href="http://www.cnblogs.com/littlehann/p/3700357.html">http://www.cnblogs.com/littlehann/p/3700357.html</a></li>
<li><a href="http://rick_stone.leanote.com/post/802.11%E5%B8%A7%E8%A7%A3%E6%9E%90">http://rick_stone.leanote.com/post/802.11%E5%B8%A7%E8%A7%A3%E6%9E%90</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocos2d-JSB 内存管理]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/15/memory-of-jsb/"/>
    <updated>2016-01-15T14:42:31+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/15/memory-of-jsb</id>
    <content type="html"><![CDATA[<p>如果你写的Cocos2d-JS程序在iOS/Android原生环境里运行时出现 <font color='#bd260d'>Error : Invalid Native Object</font> ,那么你有可能遇到了JSB的内存问题。</p>

<p>我们知道,Cocos2d-JS在原生环境里运行时,实际上运行的是Cocos2dx引擎而非Cocos2d-HTML5。在程序执行时Javascript通过JSB调用Cocos2dx引擎的API,因为 Javascript 本身有一套垃圾回收机制,Cocos2dx也有一套,当这两者一起运行时,就会由于沟通问题出现一些差错。</p>

<p>Invalid Native Object 的错误原因是,JS端访问了一个已经释放了相应C++绘制对象的JS对象。官网列举了一个这样的示例。首先,在程序里创建了一个全局变量globalNode:</p>

<pre><code>var globalNode = new cc.Node();
...
onTouched:function(sender){
    sender.addChild(globalNode);
}
</code></pre>

<p>当程序运行时,globalNode没有通过 addChild 函数添加场景上,而是在按钮事件onTouched触发时才被添加到场景上。当按钮点击时出现下列错误:</p>

<blockquote><p><font color='#bd260d'><em>jsb: ERROR: File /Users/sbxfc/Documents/XXX/frameworks/cocos2d-x/cocos/scripting/js-bindings/
auto/jsb_cocos2dx_auto.cpp: Line: 1973, Function: js_cocos2dx_Node_addChild<br>
Invalid Native Object</em></font></p></blockquote>

<p>按照我们一贯的思路,可能察觉不出这个程序的问题。我们通过CCNode.js里一段注释作为引子来解析这段程序错误的原因:</p>

<blockquote><p>If you created an engine object and haven&rsquo;t added it into the scene graph during the same frame.JSB&rsquo;s native autorelease pool will consider this object a useless one and release it directly</p></blockquote>

<p>当程序当前帧绘制完成之后,那些没有被添加到场景上的绘制对象将被删除并进行垃圾回收,所以globalNode在C++端的对象会被移除,按正常逻辑globalNode也将被回收,但是由于globalNode是一个全局对象不能被回收,所以就出现了上述错误。</p>

<h1>cc.Node的生命周期</h1>

<p>为了更清除地了解整个过程,我们看一下Node对象被创建和释放的整个流程。首先,我们使用 cc.Node.create() 来创建对象时会执行以下操作:</p>

<p>首先,在游戏启动的时候(applicationDidFinishLaunching),游戏引擎会通过addRegisterCallback将JS代码往C++的映射:</p>

<pre><code>static JSFunctionSpec st_funcs[] = {
    JS_FN("create", js_cocos2dx_CCNode_create, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
    JS_FS_END
};

jsb_CCNode_prototype = JS_InitClass(
    cx, global,
    NULL, // parent proto
    jsb_CCNode_class,
    js_cocos2dx_CCNode_constructor, 0, // constructor
    properties,
    funcs,
    NULL, // no static properties
    st_funcs);
</code></pre>

<p>cc.Node.create() 会被隐射到 C函数 js_cocos2dx_CCNode_create()上,该函数的结构如下:</p>

<pre><code>JSBool js_cocos2dx_CCNode_create(JSContext *cx, uint32_t argc, jsval *vp)
{
    if (argc == 0) {
        cocos2d::CCNode* ret = cocos2d::CCNode::create();
        jsval jsret;
        do {
        if (ret) {
            js_proxy_t *proxy = js_get_or_create_proxy(cx, ret);
            jsret = OBJECT_TO_JSVAL(proxy-&gt;obj);
        } else {
            jsret = JSVAL_NULL;
        }
    } while (0);
        JS_SET_RVAL(cx, vp, jsret);
        return JS_TRUE;
    }
    JS_ReportError(cx, "wrong number of arguments");
    return JS_FALSE;
}
</code></pre>

<p>在该函数里,通过调用 js_cocos2dx_CCNode_create 来创建了一个js_proxy_t类型的对象 proxy,js_cocos2dx_CCNode_create 是通过下面的SpiderMonkey API 完成调用的:</p>

<pre><code>JS_AddObjectRoot(cx, &amp;proxy-&gt;obj);
</code></pre>

<p>JS_AddObjectRoot 将 JSObject 添加到垃圾回收中,proxy->obj将JSObject隐射到Javascript中,也就是说,最后proxy得到了JS端对象(cc.Node)的访问权限。</p>

<p>cc.Node.create()创建的对象最终在Cocos2dx端被保存到内存里,并且通过JS_RemoveObjectRoot来移除JS端对象的引用。</p>

<p>当cocos2d::CCNode对象被移除时,会在下一帧自动释放掉,接着CCObject的析构函数会被调用,代码如下:</p>

<pre><code>// if the object is referenced by Lua engine, remove it
if (m_nLuaID)
{
    CCScriptEngineManager::sharedManager()-&gt;getScriptEngine()-&gt;removeScriptObjectByCCObject(this);
}
else
{
    CCScriptEngineProtocol* pEngine = CCScriptEngineManager::sharedManager()-&gt;getScriptEngine();
    if (pEngine != NULL &amp;&amp; pEngine-&gt;getScriptType() == kScriptTypeJavascript)
    {
        pEngine-&gt;removeScriptObjectByCCObject(this);
    }
}
</code></pre>

<p>析构函数触发了pEngine->removeScriptObjectByCCObject,而该函数做了下面这些事情:</p>

<pre><code>void ScriptingCore::removeScriptObjectByCCObject(CCObject* pObj)
{
    js_proxy_t* nproxy;
    js_proxy_t* jsproxy;
    void *ptr = (void*)pObj;
    nproxy = jsb_get_native_proxy(ptr);
    if (nproxy) {
        JSContext *cx = ScriptingCore::getInstance()-&gt;getGlobalContext();
        jsproxy = jsb_get_js_proxy(nproxy-&gt;obj);
        JS_RemoveObjectRoot(cx, &amp;jsproxy-&gt;obj);
        jsb_remove_proxy(nproxy, jsproxy);
    }
}
</code></pre>

<p>其中,函数JS_RemoveObjectRoot被调用,JS端对象引用被移除,jsb_remove_proxy将会移除掉哈希表中的映射关系。至此,Cocos2d-x完成了整个对象的垃圾回收管理。</p>

<h1>retain()和release()</h1>

<p>在上面的问题里,cc.Node的引用对象是全局变量所以没有被释放掉,而其绘制对象cocos2d::CCNode却被垃圾回收了。</p>

<p>为了避免出现 Invalid Native Object 的情形,我们可以使用retain()函数来使Cocos2dx端的绘制对象增加引用计数,我们知道C++端是通过引用计算来控制内存管理的。当我们需要释放时,只需要手动调用release()即可。但是需要注意的是,retain和release是一一对应关系,retain之后必须要release一下,不然会造成内存泄露。</p>

<h1>其他</h1>

<p>除了全局变量以外,还有一些情形也会导致JS端的对象无法被释放掉。下面是另一个错误示例,首先,创建了一个node对象,node在当前帧没有被添加到场景里,而是在一秒钟(1000ms)后被添加到场景里:</p>

<pre><code>var self = this;
this.node = new cc.Node();
setTimeout(function(){
    self.node.setLocalZOrder(1);
},1000);
</code></pre>

<p>当改程序运行时,会出现 Invalid Native Object 错误:</p>

<p><font color='#bd260d'><em>File /Users/sbxfc/Documents/cocos/projects/demo/frameworks/cocos2d-x/cocos/scripting/js-bindings/auto/jsb_cocos2dx_auto.cpp: Line: 4186, Function: js_cocos2dx_Node_setLocalZOrder js_cocos2dx_Node_setLocalZOrder : Invalid Native Object</em></font></p>

<p>理解该示例错误的关键在于JS里的参数传递和闭包。setTimeout形成的闭包会在程序运行时异步执行,其中self.node通过匿名参数的形式传递到函数内部,而函数参数传递本身是一种值传递,其传递的是对象引用的副本。所以Cocos2dx无法释放setTimeout函数里的self.node,最终也会导致Invalid Native Object错误。</p>

<p>当然,上面的问题也可以使用retain、release对解决。CCNode.js里关于函数retain、release有详细的注释,开发者可以借此了解到有关释放问题和JSB机制不健全的说明,并以此理解引擎开发者的困扰。</p>

<h1>参见</h1>

<ul>
<li><a href="http://bosn.me/js/js-call-by-sharing/">JS是按值传递还是按引用传递?</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/1-about-cocos2d-js/1-1-a-brief-history/zh.md">Javascript Binding</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=wiki&amp;url=/doc/cocos-docs-master/manual/framework/native/wiki/memory-management-of-jsb/zh.md">JSB内存管理</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I/O复用]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/11/unix-select/"/>
    <updated>2016-01-11T11:01:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/11/unix-select</id>
    <content type="html"><![CDATA[<h1>I/O 复用 和 select函数</h1>

<p>在《UNIX网络编程》里描述了这样一个例子,当客户端通过TCP协议正常连接服务端之后,紧接着客户端进入标准输入的阻塞状态。此时,若服务器突然重启,由于客户端正处于输入状态所以无法通过read函数读取对端返回EOF状态,直到输入结束,客户端恢复read为止(可能已久过去了许多时间)。</p>

<p>这种情况不是我们预期的结果。我们想让程序有一种预先设置内核通知的能力,当内核一旦发现进程指定的一个或多个I/O条件已就绪(比如输入完成,或可以进行读取数据时),它就告知进程。这个能力称为I/O复用。</p>

<p>I/O复用由select和poll函数支持的,还有前者较新的POSIX变种pselect。</p>

<p><img src="http://sbxfc.github.io/images/2016/1/io_multiplexing.png" alt="IO multiplexing" /></p>

<p>上图显示了IO复用的一般流程,首先,在图示集流阀(select)的位置,我们设置了许多需要监听的事件,然后select进入睡眠状态,当这些事件的其中一个或多个事件条件满足时,唤醒select函数,接着来执行相应的操作。</p>

<p>关于IO复用的一个很形象比喻:</p>

<p>一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，可以干点别的玩玩手机。至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间玩手机了。io多路复用大概就是指这几个醉汉共用一个服务员。</p>

<h1>select函数</h1>

<p>select函数允许程序指示内核等待多个事件的任何一个发生,并且在一个或多个事件发生时,或是经历一段指定的时间后才唤醒它。</p>

<pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;

struct timeval{
    long tv_sec;/*秒*/
    long tv_usec;/*毫秒*/
};

int select(int maxfd, fd_set* readfds, fd_set* writefds, fd_set* errorfds, struct timeval* timeout);
</code></pre>

<p>一),首先从最后一个参数说起。timeout告知内核等待指定描述符中的任何一个就绪所花费时间。该参数会有以下三种情况:</p>

<ol>
<li>永远等待下去 : 仅在有一个描述符准备好时I/O才返回。为此,我们把该参数设置为空指针(NULL)。</li>
<li>等待一段固定时间 : 在有一个描述符准备好I/O时返回,但等待时间不超过由timeval结构中指定的时间。</li>
<li>根本不等待 : 检查描述符后立刻返回,这称为轮询(polling)。为此,该参数必须指向一个timeval结构,而且其中的定时器值必须为0。</li>
</ol>


<p>二),中间的三个参数readfds,writefds,errorfds用于指定我们让内核试读、写和异常条件的描述符集合。目前支持的异常条件只有两个:</p>

<ol>
<li>某个套接字的<strong>带外数据</strong>的到达。</li>
<li>某个已置为分组模式的伪终端存在可从其他端读取的控制状态信息。</li>
</ol>


<p>如果该三个参数都为NULL,那么我们就有了一个比Unix的sleep更精确的定时器(sleep以秒为最小单位)。</p>

<p>三),maxfd 参数指定待测试的描述符个数,它的值是待测试的最大描述符加1,描述符0,1,2&hellip;maxfd-1将都被测试。</p>

<h1>示例代码</h1>

<p><a href="https://github.com/sbxfc/unix/tree/master/select">https://github.com/sbxfc/unix/tree/master/select</a></p>

<h1>运行</h1>

<p>1,客户端</p>

<pre><code>//Mac终端 
$ gcc client_select.c -o client
$ ./client
$ hi //客户端输入
$ input is readable //输出~~
$ socket is readable //输出~~
$ hi //回射服务器返回
</code></pre>

<p>2,服务端(回射服务器)</p>

<pre><code>$ gcc server_select.c
$ ./a.out 
</code></pre>

<h1>参见</h1>

<hr />

<ul>
<li>&lt;UNIX网络编程></li>
<li><a href="https://zh.wikipedia.org/zh/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">https://zh.wikipedia.org/zh/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Select_(Unix)">https://zh.wikipedia.org/wiki/Select_(Unix)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[信号]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/04/unix-signal/"/>
    <updated>2016-01-04T14:24:14+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/04/unix-signal</id>
    <content type="html"><![CDATA[<p>在UNIX系统里,每个进程都有一个独立的工作环境并且专注于做自己的事。然而有些时候,比如发现一个进程在砸墙(发生硬件错误),这时候,内核就会通过信号来让进程意识到这种危险情况。</p>

<h1>常见的信号</h1>

<ul>
<li><p>SIGINT   交互式操作产生的信号（如CTRL &ndash; C）。</p></li>
<li><p>SIGQUIT  当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。</p></li>
<li><p>SIGTSTP  当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。</p></li>
<li><p>SIGCONT  用于通知暂停的进程继续。</p></li>
<li><p>SIGALRM  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。</p></li>
<li><p>SIGFPE    浮点错误（0作为除数产生的错误，非法的操作）。</p></li>
</ul>


<h1>信号产生</h1>

<p>信号的产生有两种方式,一种是由内核(kernel)差生的,比如出现硬件错误(比如出现分母为0的除法运算)。还有一种情况是其他进程产生的,发送给内核,再由内核传递给目标进程。</p>

<p>1,通过 raise 发送信号给当前进程,该函数</p>

<pre><code>/**
 * 成功返回0,否则返回 -1
 * @param signo 信号类型
 */
if (raise(SIGINT) != 0) {
    fputs("Error raising the signal.\n", stderr);
    return EXIT_FAILURE;
}
</code></pre>

<p>2,在权限允许的情况下通过 kill 发送信号给指定进程。</p>

<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt; 

/**
 * @param pid 进程ID,
 * 当pid &gt; 0时,信号发送至ID为pid的进程,
 * 当pid = 0时,信号发送至同一进程组的进程,
 * 当pid &lt; 0 &amp;&amp; pid != -1时,信号发送至进程组ID为(-1*pid)的所有进程
 * 当pid = -1时,信号发送至除自身进程以外的所有ID大于1的进程
 * 
 * @param signo 信号类型
 * 当 signo = 0 时,实际不发送任何信号,但照常进行错误检查,
 * 因此,可用于检查目标进程是否存在,以及当前进程是否具有向目标发送信号的权限
 * (root权限的进程可以向任何进程发送信号，非root权限的进程
 * 只能向属于同一个session或者同一个用户的进程发送信号)
 */
int kill(pid_t pid,int signo)
</code></pre>

<p>3,sigqueue(Linux) 相比于kill,sigqueue传递了更多的附加信息,但只能向一个进程发送信号。成功返回0,否则返回 -1。</p>

<p>在调用sigqueue时,sigval_t指定的信息会拷贝到3参数信号处理函数（3参数信号处理函数指的是信号处理函数由sigaction安装,并设定了sa_sigaction
指针）的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。
sigqueue系统调用支持发送带参数信号,所以比kill()系统调用的功能要灵活和强大得多。(Note:sigqueue是Linux系统下信号发送函数,我的Mac机没有所以只摘抄了一些介绍。)</p>

<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt; 

typedef union sigval {
    int  sival_int;
    void *sival_ptr;
}sigval_t;

/**
 * @param pid 进程ID
 * @param signo 信号值 sigqueue 不能发送信号给一个进程组,如果 signo = 0,将会执行错误检,
 * 但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号
 */
int sigqueue(pid_t pid, int signo, const union sigval val) 
</code></pre>

<p>4,alarm 在指定的时间seconds秒后,将向进程本身发送SIGALRM信号，又称为闹钟时间。进程调用alarm后,任何以前的alarm()调用都将无效。如果参数seconds为零,那么进程内将不再包含任何闹钟时间。返回值,如果调用alarm()前,进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间,否则返回0。</p>

<pre><code>#include &lt;unistd.h&gt; 
unsigned int alarm(unsigned int seconds); 
</code></pre>

<p>5,setitimer setitimer比alarm功能强大,setitimer调用成功返回0,否则返回-1。支持3种类型的定时器:</p>

<ul>
<li>ITIMER_REAL:设定绝对时间;经过指定的时间后，内核将发送SIGALRM信号给本进程;</li>
<li>ITIMER_VIRTUAL 设定程序执行时间;经过指定的时间后,内核将发送SIGVTALRM信号给本进程；</li>
<li>ITIMER_PROF 设定进程执行以及内核因本进程而消耗的时间和,经过指定的时间后,内核将发送ITIMER_VIRTUAL信号给本进程;</li>
</ul>


<!--more-->


<pre><code>#include &lt;sys/time.h&gt;
/**
* @param which 定时器类型
* @param value 
*/
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));
</code></pre>

<p>6,abort 向进程发送SIGABRT信号,默认情况下进程会异常退出,当然可定义自己的信号处理函数。即使SIGABRT被进程设置为阻塞信号,调用abort()后，SIGABRT仍然能被进程接收。该函数无返回值。</p>

<pre><code>#include &lt;stdlib.h&gt;
void abort(void);
</code></pre>

<h1>安装信号(信号监听)</h1>

<p>如果进程想要处理某一信号,就需要在进程里安装该信号。</p>

<p>1,signal</p>

<pre><code>#include &lt;signal.h&gt; 

/**
* 第一个参数信号值。
* 第二个参数是信号值的处理。第二个参数如果设为 SIG_IGN 表示可忽略该信号,
* 如果设为 SIG_DFL 表示采用系统的默认处理方式,也可以指定一个处理函数。
*/
void (*signal(int, void (*)(int)))(int);
</code></pre>

<p>2,sigaction</p>

<pre><code>#include &lt;signal.h&gt; 

/**
 * @param union 联合数据结构中的两个元素_sa_handler以及*_sa_sigaction指定信号关联函数,
 * 即用户指定的信号处理函数。除了可以是用户自定义的处理函数外,还可以为SIG_DFL(采用缺省的处理方式),
 * 也可以为SIG_IGN（忽略信号）
 * @param sa_restorer,已过时,POSIX不支持它,不应再被使用。
 */
struct sigaction {
    union{
        __sighandler_t _sa_handler;
        void (*_sa_sigaction)(int,struct siginfo *, void *)；
    }_u
    sigset_t sa_mask；
    unsigned long sa_flags； 
    void (*sa_restorer)(void)；
}

/**
* @param signum 信号值,可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号。
* @param act 指向结构sigaction的一个实例的指针,在结构sigaction的实例中,
* 指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理。
* @param oldact oldact指向的对象用来保存原来对相应信号的处理,可指定oldact为NULL。
* 如果把第二、第三个参数都设为NULL,那么该函数可用于检查信号的有效性。
*/
int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));
</code></pre>

<h1>阻塞信号/恢复信号</h1>

<p>有时候我们不希望信号立刻执行,同时也不想信号被忽略掉(SIG_IGN)。这时,我们可以设置阻塞信号,并在信号恢复后接收阻塞的信号。</p>

<p>如果信号在被阻塞期间产生了一次或多次,那么该信号被解除阻塞之后通常只提交一次,也就是说Unix信号默认是不排队的。</p>

<pre><code>#include &lt;signal.h&gt;

/**
 * @func 1
 * @param how 选择阻塞方式,how有以下三种值:
 * SIG_BLOCK 添加set阻塞信号集合,第二个参数为本次设置之前的阻塞信号集合
 * SIG_UNBLOCK 如果当前进程阻塞集中包含set阻塞信号集合,则解除该阻塞信号集合
 * SIG_SETMASK 设置当前阻塞集为set指定的集合,第二个参数NULL
 */
int sigprocmask(int how,  const  sigset_t *set, sigset_t *oldset))；

/**
 * 获取当前已递送到进程,却被阻塞的所有信号,
 * 从set指向的信号集中获取返回结果。
 */
int sigpending(sigset_t *set));

/**
 * @func 2
 * 获取当前已递送到进程,却被阻塞的所有信号,
 * 从set指向的信号集中获取返回结果。
 */
int sigsuspend(const sigset_t *mask));

/**
 * @func 3
 * 用于在接收到某个信号之前, 临时用mask替换进程的信号掩码, 并暂停进程执行，直到收到信号为止。
 * 也就是说,进程执行到sigsuspend时,sigsuspend并不会立刻返回,进程处于TASK_INTERRUPTIBLE状态
 * 并立刻放弃CPU,等待UNBLOCK（mask之外的）信号的唤醒。进程在接收到UNBLOCK（mask之外）信号后,
 * 调用处理函数，然后把现在的信号集还原为原来的,sigsuspend返回,进程恢复执行。
 * 该系统调用始终返回-1，并将errno设置为EINTR。
 */
sigsuspend(const sigset_t *mask));
</code></pre>

<h1>完整示例</h1>

<p><a href="https://github.com/sbxfc/unix/tree/master/signal">https://github.com/sbxfc/unix/tree/master/signal</a></p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7">Unix信号</a></li>
<li><a href="http://en.cppreference.com/w/c/program/raise">http://en.cppreference.com/w/c/program/raise</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html">http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Kill_(%E5%91%BD%E4%BB%A4)">https://zh.wikipedia.org/wiki/Kill_(%E5%91%BD%E4%BB%A4)</a></li>
<li>&lt;kernal/signal.c></li>
<li><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/sigqueue.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/sigqueue.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html">http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html">http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用libevent库]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/30/libevent/"/>
    <updated>2015-12-30T17:43:19+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/30/libevent</id>
    <content type="html"><![CDATA[<h1>编译</h1>

<p>从官网下载最新的release包 <a href="http://libevent.org/">libevent-2.0.22-stable.tar.gz</a></p>

<p>解压并进入相应目录后进行编译:</p>

<pre><code>./configure &amp;&amp; make  
sudo make install
</code></pre>

<p>编译完成后,可以按Command+Shilt+G进入目录(/usr/local/lib)查看生成的文件夹 libevent-2.0.22</p>

<h1>定时器示例</h1>

<p>新建一个Command Line Tool 的c++项目,首先在Build Phases->Link Binary With Libraries里添加三个.a库文件 libevent_core.a、libevent_extra.a、libevent_phreads.a(这几个库文件的选择视情况而定)。</p>

<p>检查Building Setting里的Library Search Paths是否已添加了libevent库文件目录,如果没有则添加(以下是我本机路径):</p>

<pre><code>/usr/local/libevent-2.0.22/lib //库文件目录
</code></pre>

<p>在Header Search Paths里将头文件的目录添加进去(以下是我本机路径):</p>

<pre><code>/usr/local/libevent-2.0.22/include //头文件的目录
</code></pre>

<p>在main.cpp添加简单定时器代码:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

// libevent头文件
#include &lt;event.h&gt;
using namespace std;

struct event evt;
struct timeval tv;

// 定时事件回调函数
void time_cb(int sock, short event, void *arg)
{
    printf("timer wakeup\n");
    //重新添加定时事件（定时事件触发后默认自动删除）
    event_add((struct event*)arg, &amp;tv);
}

int main()
{
    //初始化
    struct event_base *base = event_init();

    tv.tv_sec = 1; //1s period
    tv.tv_usec = 0;

    //设置定时事件
    evtimer_set(&amp;evt,time_cb, &amp;evt);

    // 添加定时事件
    event_add(&amp;evt, &amp;tv);

    //事件循环
    event_base_dispatch(base);

    return 0;
}
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="http://libevent.org/">http://libevent.org/</a></li>
<li>libevent源码深度剖析.pdf</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - 纹理的选择 ]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/04/cocos2d-texture/"/>
    <updated>2015-12-04T12:15:05+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/04/cocos2d-texture</id>
    <content type="html"><![CDATA[<p>普通的2D纹理就是一张图片,在cocos2d里,纹理的使用主要分为两步:</p>

<ul>
<li>一,从本地加载纹理图片,并将纹理数据读取到内存。</li>
<li>二,将内存里的纹理数据以copy的形式上传到GPU内存。</li>
</ul>


<p><font color='#bd260d'><strong>前者主要涉及到的问题是图片尺寸以及加载后的内存占用。</strong></font>例如,我们要从本地加载了一张1024*1024的png图片(假设是RGBA8888格式),其大小约为1024*1024*4 = 4MB。这意味着,如果这张图片打包进安装包就会使整个程序增加4MB,如果在运行时加载到游戏里就相当于多了至少4MB内存。</p>

<p>对于一个有责任心(小肚鸡肠)的开发者来说,程序无缘无故增加了4MB内存,无疑是令人耿耿于怀的。能不能把尺寸或者运行时内存减少一点呢?答案是可以的。</p>

<p>要解决纹理的内存问题,首先,我们应当了解一下纹理图片为何会占了这么多内存。对于,我们常见的图片,无论是png还是jpg图片,他们都是非压缩纹理。非压缩纹理的意思是,这些图片的RGBA四个通道的像素数据在文件里都是按照一定顺序规则排列的。类似于RGBA,RGBA,&hellip;.,RGBA这样的排列,不同的非压缩格式图片的区别在于,有一些只使用了rgb三个通道值,有一些使用的通道精度是小于2<sup>8</sup>。</p>

<p>cocos2d支持十余种格式的非压缩纹理,上面提到的RGBA8888就是其中一种,也是最常见的一种(一般来说,没有特殊设置图片的像素格式就是RGBA8888)。并且图片的扩展名和它的像素格式没什么直接关系,一个png图片其像素格式可能是RGBA8888、RGBA4444也或者是其他格式。</p>

<p>说到这里,那么RGBA8888纹理有什么特别的地方呢？首先,该纹理格式上的每个像素点包括了R、G、B以及Alpha四个通道值,并且每个通道值是精度2<sup>8</sup>,图片数据是以二进制存储的,我们知道2<sup>8</sup>的bit值等于1byte,所以RGBA8888格式的纹理每个像素通道大小是1byte,所以该格式的纹理每个像素大小就是4*1byte = 4byte。</p>

<p>以此推之,RGBA4444像素格式就是通道精度为 2<sup>4</sup>,包含RGBA四个通道的纹理。其大小为4*0.5byte = 2byte。由此可见,RGBA4444纹理的大小是RGBA8888的一半。也就是说,如果我们有张RGBA8888的纹理图片,如果能把它转化为RGBA4444,其尺寸立刻就减小了二分之一。多么诱人,但是我们也注意到RGBA4444相较于RGBA8888,其精度只有2<sup>4</sup>=16。这种精度的损失对一些颜色渐变的纹理来说,影响比较明显。但是无论精度区间是[0,16]还是[0,256],这些像素都会被映射到OpenGL支持的[0,1]这个颜色区间。</p>

<p>所以,我们应当根据实际情况选取合适的像素格式来减少图片尺寸和运行时的内存。<font color='#bd260d'><strong>通常来说,对于非压缩纹理 rgb565 和 rgba5551(RGB5A1) 的效果和内存占用相对会好一些。</strong></font></p>

<p>cocos2d支持的非压缩纹理像素格式:</p>

<pre><code>    enum class PixelFormat
    {
        //! auto detect the type
        AUTO,
        //! 32-bit texture: BGRA8888
        BGRA8888,
        //! 32-bit texture: RGBA8888
        RGBA8888,
        //! 24-bit texture: RGBA888
        RGB888,
        //! 16-bit texture without Alpha channel
        RGB565,
        //! 8-bit textures used as masks
        A8,
        //! 8-bit intensity texture
        I8,
        //! 16-bit textures used as masks
        AI88,
        //! 16-bit textures: RGBA4444
        RGBA4444,
        //! 16-bit textures: RGB5A1
        RGB5A1,

        //省略了压缩纹理
        //...
     }
</code></pre>

<h1>加载时的设置</h1>

<p><font color='#bd260d'><strong>不同的非压缩纹理时,在加载时需要注意格式问题。</strong></font></p>

<p>cocos2d对纹理的默认处理方式是PixelFormat::NONE,这个设置在游戏运行时会被转化为默认值为&#8221;RGBA8888&#8221;。但是,如果要加载的纹理图片的格式RGBA4444,这时引擎就会通过转换函数将RGBA4444转为RGBA8888。</p>

<p>这种转换不是我们想要的,我们想直接加载并绘制RGBA4444这种格式的纹理图片。因为RGBA4444是OpenGL可以直接读取并渲染的格式,我们不需要再将其转化为其他格式。(转换不但会耗费一定的CPU,也会增加运行时内存(rgba4444->rgba888内存增加一倍))</p>

<p>所以,在加载时如果遇到非RGBA8888的情况,需要进行代码声明:</p>

<pre><code>//在这里,我们高呼,我们加载的格式是RGBA5551,不用帮我们转换
[Texture2D setDefaultAlphaPixelFormat:kTexture2DPixelFormat_RGB5A1];
Sprite *s1 = [Sprite spriteWithFile:@"rgba5551.png"];
[self addChild:s1];

//在RGBA5551加载完后,我们告诉引擎你可以去按照你默认的格式(RGBA8888)去处理其他纹理了
[Texture2D setDefaultAlphaPixelFormat:kTexture2DPixelFormat_RGBA8888];
Sprite *s2 = [Sprite spriteWithFile:@"rgba8888.png"];
[self addChild:s2];
</code></pre>

<p>需要注意的是,在Sprite里,除了initWithTexture以外,其他全部创建方法会将纹理自动加载到内存并向GPU内存上传纹理数据。所以,实际开发中如果图像资源中同时包含多种纹理格式,一定要小心处理。</p>

<p>OpenGL通过glTexImage2D上传非压缩纹理,虽然GPU拥有高效的图像处理速度,但是从本地内存向显卡内存传递图片数据仍然是CPU和GPU共同处理的过程,资源的绘制效率也会受资源数据的大小限制(传输中的宽带问题,数据越大传输时间越长),所以预先上传纹理数据会对纹理的绘制效率有很大的提高,可以参见Texture2DCache对纹理缓存的管理。</p>

<p>下面的代码是Cocos里向 GPU 内存上传非压缩纹理数据的源码:</p>

<pre><code>glTexImage2D(GL_TEXTURE_2D, i, info.internalFormat, 
             (GLsizei)width, (GLsizei)height, 0, info.format, info.type, data);
</code></pre>

<p>其中,第三个参数的可选值为:</p>

<pre><code>GL_RGB,GL_RGBA,GL_ALPHA,GL_LUMINANCE,GL_LUMINANCE_ALPHA 
</code></pre>

<p>倒数第二个参数的格式可选值为:</p>

<pre><code>GL_UNSIGNED_BYTE,GL_UNSIGNED_SHORT_5_6_5,GL_UNSIGNED_SHORT_4_4_4_4,GL_UNSIGNED_SHORT_5_5_5_1
</code></pre>

<p>是不是有点熟悉,这两个参数的组合其实就是我们上面提到的某一个像素格式,比如RGBA4444对应的就是GL_RGBA和GL_UNSIGNED_SHORT_4_4_4_4。</p>

<h1>压缩纹理</h1>

<p>除了非压缩纹理外,cocos2d也支持压缩纹理,压缩纹理是通过一些优化算法将像素数据进行压缩,这些压缩纹理可以在相应的GPU直接解析(比如PVR格式的文件就可以直接 PowerVR图形芯片 解析)。</p>

<p>在OpenGL里,压缩纹理通过 glCompressedTexImage2D 接口将纹理数据从本地上传到GPU内存:</p>

<pre><code>glCompressedTexImage2D(GL_TEXTURE_2D,   i,  info.internalFormat,
                       (GLsizei)width,  (GLsizei)height,    0,  datalen, data);
</code></pre>

<p>Cocos里支持的压缩纹理格式:</p>

<pre><code>enum class PixelFormat
{
    ...

    //! 4-bit PVRTC-compressed texture: PVRTC4
    PVRTC4,
    //! 4-bit PVRTC-compressed texture: PVRTC4 (has alpha channel)
    PVRTC4A,
    //! 2-bit PVRTC-compressed texture: PVRTC2
    PVRTC2,
    //! 2-bit PVRTC-compressed texture: PVRTC2 (has alpha channel)
    PVRTC2A,
    //! ETC-compressed texture: ETC
    ETC,
    //! S3TC-compressed texture: S3TC_Dxt1
    S3TC_DXT1,
    //! S3TC-compressed texture: S3TC_Dxt3
    S3TC_DXT3,
    //! S3TC-compressed texture: S3TC_Dxt5
    S3TC_DXT5,
    //! ATITC-compressed texture: ATC_RGB
    ATC_RGB,
    //! ATITC-compressed texture: ATC_EXPLICIT_ALPHA
    ATC_EXPLICIT_ALPHA,
    //! ATITC-compresed texture: ATC_INTERPOLATED_ALPHA
    ATC_INTERPOLATED_ALPHA,
    //! Default texture format: AUTO
    DEFAULT = AUTO,

    NONE = -1
};
</code></pre>

<h1>纹理选择</h1>

<ul>
<li><p><font color='#bd260d'><strong>在 iOS 设备上最好使用PVR格式的压缩格式</strong></font>,因为iOS设备采用的是 PowerVR 图形芯片,PVR格式图片在PowerVR图形芯片中效率极高，占用显存也小。<a href="http://blog.chukong-inc.com/index.php/2013/02/04/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96cocos2d-x%E6%B8%B8%E6%88%8F%E7%9A%84%E5%86%85%E5%AD%98/">其中PVRTC4格式的PVR有损压缩包pvr.ccz,尺寸是原来的1/8</a></p></li>
<li><p><font color='#bd260d'><strong>在 Android 设备上使用双层 ETC1 的压缩纹理</strong></font>(极少数的GPU对ETC格式支持有问题。)。</p></li>
</ul>


<h1>TexturePacker</h1>

<p>TexturePacker是一款很出众的纹理压缩工具,上述的纹理格式都可以通过TexturePacker工具导出,下图是以导出一个PVRTC4格式的pvr.ccz文件的截图:</p>

<p><img src="http://sbxfc.github.io/images/2015/12/texture_packer.png" alt="" /></p>

<h1>参见</h1>

<ul>
<li><a href="http://blog.chukong-inc.com/index.php/2013/02/04/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96cocos2d-x%E6%B8%B8%E6%88%8F%E7%9A%84%E5%86%85%E5%AD%98/">如何优化Cocos2d-X游戏的内存</a></li>
<li><a href="http://blog.csdn.net/kaitiren/article/details/8054856">pvr与png的内存占用</a></li>
<li><a href="http://pngmini.com/">ImageAlpha Mac</a></li>
<li><a href="https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml">https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml</a></li>
<li><a href="http://www.learn-cocos2d.com/2011/11/depth-ios-cocos2d-performance-analysis-test-project/#image-formats">http://www.learn-cocos2d.com/2011/11/depth-ios-cocos2d-performance-analysis-test-project/#image-formats</a></li>
<li><a href="http://matrixcn.tumblr.com/post/75239316805/%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2png%E5%9B%BE%E7%89%87%E5%88%B0rgba4444">http://matrixcn.tumblr.com/post/75239316805/%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2png%E5%9B%BE%E7%89%87%E5%88%B0rgba4444</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Prototype的JS对象]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/03/js-prototype/"/>
    <updated>2015-12-03T18:11:18+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/03/js-prototype</id>
    <content type="html"><![CDATA[<p>Javascript是基于Prototype的编程语言,而非我们熟悉的基于Class的编程语言。</p>

<p>在Javascript里,当我们new一个对象实例时,该对象的Prototype属性会被实例继承,但是Prototype和实例之间是引用关系。</p>

<p>当我们为实例对象的一个属性赋值时实际上并不是对Prototype里的属性进行修改,而是在实例上设置一个新属性。当程序访问该实例上的属性时,编译器会首先搜索实例自身的属性(即新添加的属性),如果没找到才会去搜索其继承的Prototype上的值:</p>

<pre><code>function Person{}
Person.prototype.name = "sbxfc";

var p = new Person();
//p身上没有name属性,转而去Person身上找
console.log(p.name);

//该name属性非Person上的name属性
p.name = "ss";
console.log(p.name);
</code></pre>

<h1>参见:</h1>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/09/19/javascriptYouMustKnowPrototype.html">http://www.cnblogs.com/mindsbook/archive/2009/09/19/javascriptYouMustKnowPrototype.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - scheduler]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/01/cocos-scheduler/"/>
    <updated>2015-12-01T12:12:18+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/01/cocos-scheduler</id>
    <content type="html"><![CDATA[<p>在cocos2d里,场景的每帧刷新是由一个与屏幕帧频相等的定时器来驱动绘制的,在iOS环境里,这个定时器是CADisplayLink</p>

<p>每当屏幕上一帧刷新结束时,主线程里维持程序生命周期的NSRunLoop就会向CADisplayLink发送通知。接着,CADisplayLink会触发一个名为doCaller的回调函数,在该回调函数里cocos2d引擎进行了一系列的帧刷新操作。</p>

<p>在这个过程里,除了执行基本的场景刷新以外,cocos2d还定义了一个名为scheduler(调度器)的定时器,让开发者可以参与管理与每帧刷新息息相关的操作</p>

<pre><code>//在Cocos引擎里,当Director初始化时会启动该CADisplayLink定时器
//doCaller函数会执行每帧的刷新操作
-(void) startMainLoop
{
    // Director::setAnimationInterval() is called, we should invalidate it first
    [self stopMainLoop];

    displayLink = [NSClassFromString(@"CADisplayLink") 
                    displayLinkWithTarget:self selector:@selector(doCaller:)];
    [displayLink setFrameInterval: self.interval];
    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
}
</code></pre>

<p><font color='#bd260d'><strong>scheduler的回调函数优先于场景刷新函数被执行,这意味着,如果我们在scheduler回调函数里做一些UI刷新操作,这些操作会在下一帧被及时更新。</strong></font></p>

<pre><code>_scheduler-&gt;update(_deltaTime);   //调用scheduler
...
_runningScene-&gt;render(_renderer);//渲染场景
</code></pre>

<h1>基本用法</h1>

<p>任何Node对象以Node的子类都可以直接调用scheduleUpdate方法,然后通过重载update函数来执行回调操作:</p>

<pre><code>this-&gt;scheduleUpdate();

//*.h
void update(float dt) override;
//*.cpp
void HelloWorld::update(float delta){
    //Do something!
}
</code></pre>

<h1>自定义scheduler</h1>

<p>除基础用法以外,还可以通过指定执行频率和回调函数来创建自定义调度器:</p>

<pre><code>this-&gt;schedule(schedule_selector(HelloWorld::updateCustom), 1.0f, kRepeatForever, 0);

//*.h
void updateCustom(float dt);
//*.cpp
void HelloWorld::updateCustom(float dt){
    //Do something!
}
</code></pre>

<p>自定义的scheduler在回调时使用一个Timer来计时,所以会花费更多的内存和计算时间,而且由于其内部实现机制,其间隔时间至少大于0.1秒。这种scheduler更适合作为定时器来使用。</p>

<h1>优先级</h1>

<p>我们还可以为调度器指定优先级，来处理回调方法执行的先后顺序逻辑。</p>

<pre><code>void Node::scheduleUpdate(){
    scheduleUpdateWithPriority(0);
}

void Node::scheduleUpdateWithPriority(int priority){
    _scheduler-&gt;scheduleUpdate(this, priority, !_running);
}
</code></pre>

<h1>移除</h1>

<p>Scheduler会随Node对象移除而停止,当然你也可以显示地执行移除函数</p>

<pre><code>node-&gt;unschedulerUpdate();
node-&gt;unschedule(SEL_SCHEDULE selector, float delay);
</code></pre>

<h1>参考</h1>

<ul>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/scheduler/zh.md">http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/scheduler/zh.md</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - Spine骨骼动画]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/25/cocos-spine/"/>
    <updated>2015-11-25T14:14:58+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/25/cocos-spine</id>
    <content type="html"><![CDATA[<p>Spine是一款出众的2D的骨骼动画编辑器。</p>

<h1>使用步骤</h1>

<p>1.首先,在SETUP模型下选中右侧的Images标签页,然后点击Browse将包含图片资源的文件夹添加进来。</p>

<p>2.将Images下的图片拖入场景,并按照角色的样子将各个部位拼接起来。可通过右侧Draw Order调整图片的绘制顺序;</p>

<p>3.创建骨骼,并绑定图片到骨骼上,注意各骨骼的父子关系。</p>

<p>4.切换到ANIMATE模式,选中要“动”的骨骼,对其进行旋转、移动、缩放等操作,每次改动后要记得打关键帧。</p>

<p>5.选择菜单中的Texture Packer选项,导出Cocos2d-x工程需要的json文件和atlas以及png合图。</p>

<h1>在Cocos2d-x里使用</h1>

<p>首先,包含Spine动画需要的相关头文件:</p>

<pre><code>#include &lt;spine/spine-cocos2dx.h&gt;
#include "spine/spine.h"
using namespace spine;
</code></pre>

<p>然后,使用SkeletonAnimation创建Spine动画</p>

<pre><code>auto skeletonNode = new SkeletonAnimation("player.json", "player.atlas");
skeletonNode-&gt;setAnimation(0, "walk", true);
skeletonNode-&gt;debugBones = false;
skeletonNode-&gt;setPosition(CCRANDOM_0_1() * windowSize.width, 0 + CCRANDOM_0_1() * windowSize.height);
addChild(skeletonNode);
</code></pre>

<h1>参见:</h1>

<ul>
<li><a href="http://zh.esotericsoftware.com/spine-in-depth">http://zh.esotericsoftware.com/spine-in-depth</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/spine/zh.md">http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/spine/zh.md</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Xcode上运行Cocos2d-JS工程]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/23/run-cocos2d-js-on-xcode/"/>
    <updated>2015-11-23T17:21:14+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/23/run-cocos2d-js-on-xcode</id>
    <content type="html"><![CDATA[<p>在Mac下通过命令生成Cocos2d-JS项目时,编译命令也会生成相应的Xcode集成环境,用Xcode打开下面目录下的工程就可以直接在真机或模拟器下运行调试:</p>

<pre><code>project
    /frameworks
        /runtime-src
            /proj.ios_mac
                /project.xcodeproj
</code></pre>

<p>使用Xcode 7.0以上版本会出现如下错误:</p>

<pre><code>error:-fembed-bitcode is not supported on versions of iOS prior to 6.0
</code></pre>

<p>修改方法,选择General->Deployment Target 6.0以上<br>
或者设置Build Settings->Build Options->Enabled Bitcode为NO。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - 批次绘制]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/19/cocos-auto-batching/"/>
    <updated>2015-11-19T16:52:57+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/19/cocos-auto-batching</id>
    <content type="html"><![CDATA[<h1>自动批绘制</h1>

<p>从3.0版本以后,cocos2d的图形渲染模块实现了自动批绘制(Auto-batching)的优化。引擎的渲染部分对相同材质的连续渲染指令(QuadCommand)进行过滤,如果当前的渲染对象的材质和上一次渲染的材质一样,就不渲染了,保存一下所需的信息,继续遍历下一个,直到发现当前材质和上一个材质不一样，才重新开始渲染。</p>

<p>这样一来,渲染指令里相邻的且材质ID相同的多个draw call就能减少为一个,过程如下图:</p>

<p><img src="http://sbxfc.github.io/images/2015/10/auto-batching.png" alt="" /></p>

<p>最简单的满足条件就是我们用同一张图片连续创建精灵,这些精灵在绘制时只需要一个draw call:</p>

<pre><code>for (int i = 0; i &lt; 10000; i++)
{
    Sprite* sprite = Sprite::create("HelloWorld.png");
    sprite-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite);
}
</code></pre>

<p>需要注意的是,在渲染开始前引擎会对渲染指令根据zOrder进行一次排序。所以,连续添加的相同Sprite需要保证期zOrder是一样的。当然,我们也可以利用zOrder排序的这个机制,对非连续添加的相同纹理精灵设置相同zOrder来满足自动批绘制的条件:</p>

<pre><code>for(int i = 0; i &lt; 10000; i++)
{
    Sprite* sprite1 = Sprite::create("CloseNormal.png");
    sprite1-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite1);

    Sprite* sprite2 = Sprite::create("CloseSelected.png");
    sprite2-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite2);
    sprite2-&gt;setZOrder(1);
}
</code></pre>

<p>由于,Auto-batching的使用条件是使用QuadCommands渲染命令的连续的相同材质ID的Sprite或ParticleSystem objects。所以,我们也可以使用精灵帧表单来实现Auto-batching。</p>

<pre><code>SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile("TankMovePlist.plist");
for(int i = 0; i &lt; 10000; i++)
{
    char buf[64];
    sprintf(buf,"image/M26_b_%d.png", i%8 + 4);
    SpriteFrame *frame= SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName(buf);
    Sprite *sprite = Sprite::createWithSpriteFrame(frame);
    sprite-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite);
}
</code></pre>

<p>进而将Auto-Batching用在动画上:</p>

<pre><code>SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile("TankMovePlist.plist");
for(int i = 0; i &lt; 700; i++)
{
    auto s_tank = Sprite::createWithSpriteFrameName("image/M26_b_4.png");

    auto tankMoveAnimation = Animation::create();
    tankMoveAnimation-&gt;setDelayPerUnit(0.1);
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_4.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_5.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_6.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_7.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_8.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_9.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_10.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_11.png"));
    s_tank-&gt;runAction(RepeatForever::create(Animate::create(tankMoveAnimation)));
    s_tank-&gt;setPosition(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height);
    addChild(s_tank);
}
</code></pre>

<p>运行效果:</p>

<p><img src="http://sbxfc.github.io/images/2015/10/tank_move.png" alt="" /></p>

<h1>使用SpriteBatchNode绘制精灵</h1>

<p>和Auto-batching的对绘制优化的策略一样,SpriteBatchNode将多个精灵放到一个纹理上,绘制的时候直接统一绘制该texture，不需要单独绘制子节点。</p>

<pre><code>SpriteBatchNode* batchNode = SpriteBatchNode::create("HelloWorld.png", 10000);
addChild( batchNode);

for ( int i = 0; i &lt; 10000; ++i)
{
    Sprite* sprite = Sprite::createWithTexture( batchNode-&gt;getTexture());
    sprite-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    batchNode-&gt;addChild( sprite);
}
</code></pre>

<p>再添一个官网文档上提供的例子:</p>

<pre><code>auto batch = SpriteBatchNode::create("Images/grossini_dance_atlas.png", 1);
addChild(batch, 0, kTagSpriteBatchNode);        

auto sprite1 = Sprite::createWithTexture(batch-&gt;getTexture(), Rect(85*0, 121*1, 85, 121));
auto sprite2 = Sprite::createWithTexture(batch-&gt;getTexture(), Rect(85*1, 121*1, 85, 121));

auto s = Director::getInstance()-&gt;getWinSize();
sprite1-&gt;setPosition( Point( (s.width/5)*1, (s.height/3)*1) );
sprite2-&gt;setPosition( Point( (s.width/5)*2, (s.height/3)*1) );

batch-&gt;addChild(sprite1, 0, kTagSprite1);
batch-&gt;addChild(sprite2, 0, kTagSprite2);
</code></pre>

<h1>参见:</h1>

<ul>
<li><a href="https://github.com/chukong/cocos-docs/blob/master/manual/framework/native/v3/auto-batching/zh.md">https://github.com/chukong/cocos-docs/blob/master/manual/framework/native/v3/auto-batching/zh.md</a></li>
<li><a href="http://blog.csdn.net/chenqiai0/article/details/46820669">http://blog.csdn.net/chenqiai0/article/details/46820669</a></li>
<li><a href="http://www.cocos2d-x.org/docs/tutorial/framework/html5/parkour-game-with-javascript-v3.0/chapter5/zh">在cocos2d-js上运行动画</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - 屏幕适配]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/09/cocos-resolution/"/>
    <updated>2015-11-09T17:50:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/09/cocos-resolution</id>
    <content type="html"><![CDATA[<p>现在,几乎每人都有一台移动设备。无论是手机还是iPad,这些设备的尺寸千差万别。因此,想开要发一款能在不同屏幕上友好显示的游戏,就要综合这些设备的特点,设计合理的适配方案。</p>

<p>从2.0.4开始,Cocos2d-x就提出了自己的多分辨率适配方案,经过这几年的发展已趋于成熟。对于开发者来说,如果能掌握这些技巧,就能够很好地解决适配问题。</p>

<h1>资源到设计尺寸</h1>

<p>在Cocos里,官方把适配方案分为了两步,第一步是资源到设计尺寸的适配。</p>

<p>因为设备尺寸是参差不齐的,当我们在开发游戏时并不会假定界面是基于某台设备来设计的。通常,我们会选择一个较为通用的尺寸来进行界面布局(比如1027*768),这时选取的这个尺寸称为设计尺寸。</p>

<p>而从资源到设计尺寸的映射,其实就是图片到设计尺寸的映射。例如,我们为iPhone3G和iPhone 4设计一款游戏。iPhone 3G的分辨率是320*480,而iPhone 4的分辨率是640*960。尽管这两种设备分辨率不同,但是屏幕尺寸一样大。在这样的情况下,我们使用同样的设计尺寸,只不过将iPhone4的图片资源换成2倍的即可。</p>

<p>通过 cocos2d 的setContentScaleFactor函数可以设置所有加载资源的缩放因子:</p>

<pre><code>director-&gt;setContentScaleFactor(2);
</code></pre>

<p>设置完之后,一张640*960的背景图在一个sprite显示时,高宽变为为320*480,而分辨率变为了原本的4倍。这样一来,iPhone 3G和iPhone 4的屏幕适配做好了。</p>

<p>当然,因为改变了缩放因子,这两种设备设置加载的资源就不同,为了方便管理,我们会为它们设置不同的资源目录:</p>

<pre><code>/Resource
    /iphone
    /iphonehd
</code></pre>

<p>并根据具体设备指定Resource下的默认资源路径:</p>

<pre><code>vector&lt;string&gt; searchPath;
if (iPadHD){    
    searchPath.push_back("iphonehd");
}else if(iPhone){
    searchPath.push_back("iphone");
}
//如果这两个目录下没有所需的资源,加载common目录资源
searchPath.push_back("common");
FileUtils::getInstance()-&gt;setSearchPaths(searchPath);
</code></pre>

<p>现在iPhone 3G近乎绝迹,大部分iOS设备都是高清设备。所以,不必考虑为iPhone设备设置普清图。但是普清的iPad2用的还是比较多的(最后会介绍一点iOS原生语言的适配方法)。</p>

<h1>适配屏幕分辨率</h1>

<p>一开始时,我们在一个预设的尺寸上进行界面布局,当程序运行在实际设备上时,我们需要为其选择一个合适的适配方案。比如设计尺寸是320*480,而实际分辨率是320*500,这样一样,如果不做适配上下就会空出一条黑色缝隙。设计尺寸到屏幕分辨率的适配就是设计窗口如何缩放来适应实际屏幕的分辨率的过程。</p>

<p>Cocos提供了五种设计尺寸到屏幕分辨率的适配方案,通过setDesignResolutionSize函数来设置。DW、DH指设计尺寸的宽、高,后面的参数是适配方案的枚举值:</p>

<pre><code>setDesignResolutionSize(DW,/*分辨率宽*/
                         DH,/*分辨率高*/
                         resolutionPolicy) 
</code></pre>

<p>适配方案resolutionPolicy有五种选择:</p>

<ul>
<li>ResolutionPolicy::SHOW_ALL 屏幕宽、高分别和设计分辨率宽、高计算缩放因子，取较小者作为宽、高的缩放因子。保证了设计区域全部显示到屏幕上，但可能会有黑边。</li>
<li>ResolutionPolicy::EXACT_FIT 屏幕宽与设计宽的比例作为X方向的缩放因子，屏幕高与设计高的比例作为Y方向的缩放因子。保证了设计区域完全铺满屏幕，但是可能会出现图像拉伸。</li>
<li>ResolutionPolicy::NO_BORDER 屏幕宽、高分别和设计分辨率宽、高计算缩放因子，取较(大)者作为宽、高的缩放因子。保证了设计区域总能一个方向上铺满屏幕，而另一个方向一般会超出屏幕区域。</li>
<li>ResolutionPolicy::FIXED_HEIGHT 保持传入的设计分辨率高度不变,根据屏幕分辨率修正设计分辨率的宽度。(按照适配尺寸的宽度将屏幕撑满,宽度可根据屏幕的分辨率拉伸或者是裁剪)</li>
<li>ResolutionPolicy::FIXED_WIDTH 保持传入的设计分辨率宽度不变,根据屏幕分辨率修正设计分辨率的高度。</li>
</ul>


<p>最后两种适配方案,是我们常用的适配方式。以ResolutionPolicy::FIXED_HEIGHT为例,假如我们的设计尺寸是320*480,在640*1000的设备上运行时,原先一个点为(100,100)的sprite,其实际位置就出现在屏幕上(200,208)这个像素点的位置。实际界面上的图片如果没有设置根据分辨率和设计尺寸的变化而改变,将不会变化。</p>

<p>在Cocos2d-x里的cpp-empty-test项目里有一个AppMacros.h的文件,是官方针对iphone、ipad和ipadhd所做的适配方案。另外,还有一些重要的接口:</p>

<pre><code>Director::getInstance()-&gt;getOpenGLView()-&gt;setDesignResolutionSize() //设计分辨率大小及模式 
Director::getInstance()-&gt;setContentScaleFactor() //内容缩放因子 
FileUtils::getInstance()-&gt;setSearchPaths() //资源搜索路径 
Director::getInstance()-&gt;getOpenGLView()-&gt;getFrameSize() //屏幕分辨率 
Director::getInstance()-&gt;getWinSize()       //设计分辨率 
Director::getInstance()-&gt;getVisibleSize() //设计分辨率可视区域大小 
Director::getInstance()-&gt;getVisibleOrigin()//可视区域起点
</code></pre>

<h1>iOS原生语言的适配方式</h1>

<p>从iPad3、iPad mini2和iPhone4开始,苹果的设备都采用了&#8221;Retina&#8221;显示技术,即将多个像素点压缩至一块屏幕里。比如,一台iPhone4设备,GPU在工作时渲染出960*640个像素点,其中每四个像素一组,输出到原来屏幕上一个像素的显示区域里。这样一来，用户所看到的图标与文字的大小与原来的480x320分辨率显示屏相同，但精细度是原来的4倍。</p>

<p>在iOS原生开发中,iPad3、iPad mini2和iPhone4等等这些设备在读取图片时会优先选择文件名后缀是@2x的图片。比如,我们要为iPhone4上的应用添加一张背景图,我们会做一张640*960大小的图并命名为bkg@2x.png。如果是iPhone 3G设备,我们做一张320*480的图片即可。运行时不同设备优先去加载相应分辨率的图片。(iPad3、iPad mini2和iPhone4等这些Retina设备图片资源与屏幕尺寸的比值为2,到了iPhone6 PLUS这个比值达到了2.46左右,加载的图片格式也变为了@3x)</p>

<h1>参见:</h1>

<ul>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/multi-resolution/zh.md">Cocos2d-x 多分辨率适配完全解析</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/4-essential-concepts/4-4-resolution-policies/zh.md+">Cocos2d-JS的屏幕适配方案</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
