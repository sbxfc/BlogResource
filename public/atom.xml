<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[sbxfc]]></title>
  <link href="http://sbxfc.github.io/atom.xml" rel="self"/>
  <link href="http://sbxfc.github.io/"/>
  <updated>2017-02-05T13:59:59+08:00</updated>
  <id>http://sbxfc.github.io/</id>
  <author>
    <name><![CDATA[sbxfc]]></name>
    <email><![CDATA[sbxfc17@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在亚马逊EC2 RHEL主机上安装nginx]]></title>
    <link href="http://sbxfc.github.io/blog/2017/01/22/nginx-install/"/>
    <updated>2017-01-22T18:13:21+08:00</updated>
    <id>http://sbxfc.github.io/blog/2017/01/22/nginx-install</id>
    <content type="html"><![CDATA[<p>首先登陆亚马逊的EC2控制台,把安全组里的入站端口HTTP服务的默认端口80打开。</p>

<p>下载并安装EPEL:</p>

<pre><code>$wget http://download.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm
$rpm -ivh epel-release-5-4.noarch.rpm
</code></pre>

<p>安装nginx,看一眼安装提示,没问题就确认下载:</p>

<pre><code>$yum install nginx
</code></pre>

<p>启动nginx</p>

<pre><code>$/etc/init.d/nginx start    
</code></pre>

<p>然后就可以直接输入地址在浏览器里测试了,现在的首页是nginx的欢迎页面。</p>

<h1>配置虚拟主机</h1>

<p>建立静态资源目录:</p>

<pre><code>$mkdir -p /var/www/ok2.site/public
</code></pre>

<p>在该public目录下建立首页index.html文件:</p>

<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt; HOST :)&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>修改www目录的访问权限:</p>

<pre><code>$chmod 755 /var/www
</code></pre>

<p>设置虚拟主机的配置文件:</p>

<pre><code>$vi /etc/nginx/conf.d/ok2.site.conf 

#
# A virtual host using mix of IP-, name-, and port-based configuration
#

server {
    listen        80;
#    listen       somename:8080;
    server_name   ok2.site;

    location / {
        root   /var/www/ok2.site/public;
        index  index.html index.htm;
    }
}
</code></pre>

<p>重启服务:</p>

<pre><code>$service nginx restart
</code></pre>

<p>当然,你可以根据不同的域名配置多台虚拟主机 :)</p>

<p><img src="http://sbxfc.github.io/images/2017/01/tmp01276c3d.png" alt="" /></p>

<h1>参见:</h1>

<ul>
<li><a href="http://comtechies.com/how-to-install-and-configure-nginx-on-amazon-ec2-rhel-and-ubuntu-instances.html">http://comtechies.com/how-to-install-and-configure-nginx-on-amazon-ec2-rhel-and-ubuntu-instances.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BIND9服务器]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/17/install-bind9/"/>
    <updated>2016-11-17T16:03:05+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/17/install-bind9</id>
    <content type="html"><![CDATA[<p>如果想要为你的顶级域名(xxx.com)创建域名服务器,根据DNS协议你需要向上一级域名服务器(.com)申请。就像我们的域名申请一样,这些操作都是可以通过注册商来完成的,比如阿里,比如狗爹(Godaddy)。阿里申请一个域名服务器要花10RMB,一般注册商要求配置俩域名服务器。注册DNS服务器时,阿里没有检测这台主机的IP是否有DNS服务器,所以填写的时候可以随便填写。我的域名下,ns.ok2.site这个DNS是有效的,ns2.ok2.site这个DNS是无效的,但并不影响解析。</p>

<p>关于DNS的安装和配置,网络上都是有的。只不过配置起来挺繁琐,但实际上没有什么难度。可以参见 《DNS&amp;BIND 4th》,这本书讲的很详细，虽然是挺老的书,但是对DNS来说,变化不大。</p>

<h1>下载</h1>

<p>下载最后一版本的BIND9:</p>

<pre><code>$wget -c ftp.isc.org/isc/bind9/9.9.9/bind-9.9.9.tar.gz
</code></pre>

<h1>安装</h1>

<pre><code>$tar zxvf bind-9.9.9.tar.gz -C /usr/local/src/ 
$cd /usr/local/src/bind-9.9.9/ 
$sudo ./configure --prefix=/usr/local/bind-9.9.9 --enable-threads --disable-openssl-version-check --sysconfdir=/etc --with-libtool
$sudo make 
$sudo make install
</code></pre>

<p>.configure参数的说明:</p>

<table>
<thead>
<tr>
<th>参数 </th>
<th> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>&mdash;prefix=/usr/local/bind </td>
<td>指定bind9的安装目录,默认值是/usr/local</td>
</tr>
<tr>
<td>&mdash;enable-threads </td>
<td>开启多线程的支持；如果你的系统有多个CPU，那么可以使用这个选项</td>
</tr>
<tr>
<td>&mdash;disable-openssl-version-check </td>
<td> 关闭openssl的版本检查</td>
</tr>
<tr>
<td>&mdash;with-openssl=/usr/local/openssl </td>
<td> 指定openssl的安装路径</td>
</tr>
<tr>
<td>&mdash;sysconfdir=/etc/bind </td>
<td>设置named.conf配置文件放置的目录，默认是&mdash;prefix选项指定的目录下的/etc下</td>
</tr>
<tr>
<td>&mdash;localstatdir=/var </td>
<td>设置 run/named.pid 放置的目录，默认是&mdash;prefix选项指定的目录下的/var下</td>
</tr>
<tr>
<td>&mdash;with-libtool </td>
<td> 将BIND的库文件编译为动态共享库文件，这个选项默认是未选择的。如果不选这个选项，那么编译后的named命令会比较大，lib目录中的库文件都是.a后缀的。如果选上这个选项，那么编译后的named命令会很小，lib目录中的库文件则是.so后缀</td>
</tr>
</tbody>
</table>


<p>问题1:</p>

<p><font color='#bd260d'><em>checking for OpenSSL library&hellip; configure: error: OpenSSL was not found in any of /usr /usr/local /usr/local/ssl /usr/pkg /usr/sfw; use &mdash;with-openssl=/path
If you don&rsquo;t want OpenSSL, use &mdash;without-openssl</em></font></p>

<p>解决:</p>

<pre><code>$ yum install openssl-devel
</code></pre>

<h1>配置BIND</h1>

<p>1,BIND9安装成功之后,首先创建BIND9的配置文件,直接保存退出即可:</p>

<pre><code>$vi /etc/named.conf 
</code></pre>

<p>2,创建区数据文件目录</p>

<pre><code>$mkdir /var/named   
</code></pre>

<h1>建立区数据文件</h1>

<p>区数据文件的大部分条目称为DNS资源记录(resouce record)。我们把区数据文件的根目录设置在了 <font color='#bd260d'><em>/var/named/</em></font> 建立 ok2.site 区的数据文件 <font color='#bd260d'><em>db.ok2.site</em></font></p>

<pre><code>$TTL  3d
@                   IN      SOA     ns.ok2.site. admin.ok2.site. (
                                                          3     ;序列号
                                                          3h    ;3小时后刷新
                                                          1h    ;1小时后重试
                                                          1w    ;1周后期满
                                                          1h)   ;否定缓存TTL为1小时
@                   IN      NS      ns.ok2.site.
@                   IN      NS      ns1.ok2.site.
@                   IN      MX 10   mail.ok2.site.    ;本域中邮件转递的主要邮件主机，后面的数字越小，优&gt;先级越高。
ns                  IN      A       35.164.14.188
ns1                 IN      A       123.57.38.225
www                 IN      A       35.164.14.188
mail                IN      A       35.164.14.188
ftp                 IN      CNAME   www               ;指向主机www的别名
</code></pre>

<p>TTL 值得全称是 Time To Live,即存活时间。这里是指允许其他服务器将区数据在缓存中存放的时间。如果数据不是经常变动可以将值设置为几天。</p>

<p>SOA 记录的全称是 Start Of Authority,该值指定该区的权威服务器。</p>

<h1>BIND配置文件</h1>

<p>BIND服务器启动时会首先加载配置文件,然后根据配置文件里的信息去读取区数据文件。配置文件的默认位置在 <font color='#bd260d'><em>/etc/named.conf</em></font></p>

<pre><code>options
{
    directory "/var/named"; #区数据文件所在目录
    pid-file "named.pid";
    forwarders {8.8.8.8;};
    dump-file "cache_dump.db";
    statistics-file "named_stats.txt";
    allow-query    { any; };
};

logging
{
    channel default_debug {
    file "named.run";
    severity dynamic;};
};

zone "ok2.site" IN 
{
    type master;
    file "db.ok2.site";
    allow-update {none;};
};

zone "localhost" IN
{
    type master;
    file "db.localhost";
    allow-update {none;};
};

zone "14.164.35.in-addr.arpa" IN {
    type master;
    file "db.35.164.14";
    allow-update { none; };
};

zone "0.0.127.in-addr.arpa" IN
{
    type master;
    file "db.127.0.0";
    allow-update {none;};
};

zone "." IN
{
    type hint;
    file "db.root";
};
</code></pre>

<h1>启动</h1>

<pre><code># /usr/local/bind-9.9.9/sbin/named -g
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="">DNS&amp;BIND 4th.pdf</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下的命令]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/17/unix-cmd/"/>
    <updated>2016-11-17T14:32:56+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/17/unix-cmd</id>
    <content type="html"><![CDATA[<h1>系统信息</h1>

<pre><code>uname -a
</code></pre>

<h1>文件系统</h1>

<pre><code>$touch a.txt
</code></pre>

<p>如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。</p>

<pre><code>$ls .
</code></pre>

<p>是list的简写，列出当前目录下的所有文件名</p>

<pre><code>$ls -l a.txt
</code></pre>

<p>列出文件的详细信息</p>

<pre><code>$cp a.txt b.txt
</code></pre>

<p>cp是copy的简写，用来复制文件。在工作目录下，将a.txt复制到文件b.txt</p>

<pre><code>$cp a.txt ..
</code></pre>

<p>将a.txt复制到父目录的a.txt</p>

<pre><code>$mv a.txt c.txt
</code></pre>

<p>mv是move的简写，用来移动文件。将a.txt移动成为c.txt (相当于重命名rename)</p>

<p>将文件 log1.txt,log2.txt,log3.txt 移动到目录docs中:</p>

<pre><code>mv log1.txt log2.txt log3.txt /tmp/docs/
</code></pre>

<p>将文件 log1.txt,log2.txt,log3.txt 移动到目录docs中:</p>

<pre><code>mv -t /tmp/docs/ log1.txt log2.txt log3.txt 
</code></pre>

<table>
<thead>
<tr>
<th>参数 </th>
<th> 作用 </th>
</tr>
</thead>
<tbody>
<tr>
<td>-b  </td>
<td> 若需覆盖文件，则覆盖前先进行备份 </td>
</tr>
<tr>
<td>-f </td>
<td> force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</td>
</tr>
<tr>
<td>-i </td>
<td> 若目标文件存在时,询问是否覆盖</td>
</tr>
<tr>
<td>-u </td>
<td> 若目标文件已经存在,且 source 比较新，才会更新(update)</td>
</tr>
<tr>
<td>-t </td>
<td> 即指定mv的目标目录,该选项适用于移动多个源文件到一个目录的情况,此时目标目录在前,源文件在后。</td>
</tr>
</tbody>
</table>


<pre><code>$rm a.txt
</code></pre>

<p>rm是remove的缩写，用于删除文件。删除a.txt</p>

<pre><code>$rm -r /tmp/docs/ 
</code></pre>

<p>删除从/tmp/docs/向下的整个子文件系统。-r表示recursive， 是指重复删除的操作，/tmp/docs/文件夹为空，然后删除/tmp/docs/文件夹本身。</p>

<p>(程序员总是对这个命令很感兴趣,   $rm -rf /   它会删除整个文件树。f的目的是告诉rm放心干，不用再确认了…… 一般情况下，应该没有人会用这个命令。)</p>

<h1>解压缩</h1>

<blockquote><p>.tar</p></blockquote>

<pre><code>//解包
tar xvf FileName.tar
//打包 （注：tar是打包，不是压缩！）
tar cvf FileName.tar DirName
</code></pre>

<blockquote><p>.gz</p></blockquote>

<pre><code>//解压1
gunzip FileName.gz
//解压2
gzip -d FileName.gz
//压缩
gzip FileName
</code></pre>

<blockquote><p>.tar.gz 和 .tgz</p></blockquote>

<pre><code>//解压:
tar zxvf FileName.tar.gz
//压缩:
tar zcvf FileName.tar.gz DirName
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dig工具]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/17/dig/"/>
    <updated>2016-11-17T10:54:59+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/17/dig</id>
    <content type="html"><![CDATA[<p>dig 的全称是 Domain Information Groper,意即域名信息挖掘工具。</p>

<p>直接输入dig查询,会显示全球13个DNS根域名服务器信息:</p>

<pre><code>$ dig

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt;
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 56638
;; flags: qr rd ra; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;.              IN  NS

;; ANSWER SECTION:
.           402014  IN  NS  f.root-servers.net.
.           402014  IN  NS  d.root-servers.net.
.           402014  IN  NS  j.root-servers.net.
.           402014  IN  NS  e.root-servers.net.
.           402014  IN  NS  g.root-servers.net.
.           402014  IN  NS  a.root-servers.net.
.           402014  IN  NS  b.root-servers.net.
.           402014  IN  NS  h.root-servers.net.
.           402014  IN  NS  k.root-servers.net.
.           402014  IN  NS  l.root-servers.net.
.           402014  IN  NS  m.root-servers.net.
.           402014  IN  NS  c.root-servers.net.
.           402014  IN  NS  i.root-servers.net.

;; Query time: 16 msec
;; SERVER: 114.114.114.114#53(114.114.114.114)
;; WHEN: Thu Dec 22 16:43:01 2016
;; MSG SIZE  rcvd: 228
</code></pre>

<p>使用追踪功能(+trace),我们可以查询到每级DNS服务器对域名的解析全过程</p>

<pre><code>$ dig +trace rungame.me

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace rungame.me
;; global options: +cmd
.           227759  IN  NS  b.root-servers.net.
.           227759  IN  NS  d.root-servers.net.
.           227759  IN  NS  e.root-servers.net.
.           227759  IN  NS  a.root-servers.net.
.           227759  IN  NS  h.root-servers.net.
.           227759  IN  NS  k.root-servers.net.
.           227759  IN  NS  c.root-servers.net.
.           227759  IN  NS  j.root-servers.net.
.           227759  IN  NS  m.root-servers.net.
.           227759  IN  NS  i.root-servers.net.
.           227759  IN  NS  g.root-servers.net.
.           227759  IN  NS  l.root-servers.net.
.           227759  IN  NS  f.root-servers.net.
;; Received 228 bytes from 114.114.114.114#53(114.114.114.114) in 210 ms

me.         172800  IN  NS  a0.cctld.afilias-nst.info.
me.         172800  IN  NS  a2.me.afilias-nst.info.
me.         172800  IN  NS  b0.cctld.afilias-nst.org.
me.         172800  IN  NS  b2.me.afilias-nst.org.
me.         172800  IN  NS  c0.cctld.afilias-nst.info.
me.         172800  IN  NS  d0.cctld.afilias-nst.org.
me.         172800  IN  NS  ns.nic.me.
me.         172800  IN  NS  ns2.nic.me.
;; Received 486 bytes from 198.97.190.53#53(198.97.190.53) in 1171 ms

rungame.me.     86400   IN  NS  f1g1ns1.dnspod.net.
rungame.me.     86400   IN  NS  f1g1ns2.dnspod.net.
;; Received 82 bytes from 199.249.119.1#53(199.249.119.1) in 281 ms

rungame.me.     600 IN  CNAME   sbxfc.github.io.
rungame.me.     86400   IN  NS  f1g1ns2.dnspod.net.
rungame.me.     86400   IN  NS  f1g1ns1.dnspod.net.
;; Received 121 bytes from 182.140.167.188#53(182.140.167.188) in 50 ms
</code></pre>

<p>或者,使用指定的DNS服务器查询A记录</p>

<pre><code>$ dig @8.8.8.8 rungame.me A

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; @8.8.8.8 rungame.me A
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63802
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;rungame.me.            IN  A

;; ANSWER SECTION:
rungame.me.     599 IN  CNAME   sbxfc.github.io.
sbxfc.github.io.    3599    IN  CNAME   github.map.fastly.net.
github.map.fastly.net.  11  IN  A   151.101.100.133

;; Query time: 198 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Wed Nov 16 15:45:04 2016
;; MSG SIZE  rcvd: 108
</code></pre>

<p>部分参数描述:</p>

<table>
<thead>
<tr>
<th>参数 </th>
<th> 描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>+trace </td>
<td> 从顶级根域名开始追踪查询过程</td>
</tr>
<tr>
<td>+tcp </td>
<td> 使用TCP代替默认的UDP查询</td>
</tr>
<tr>
<td>-q </td>
<td> 逆向查询,可以查询IP到域名的映射</td>
</tr>
<tr>
<td>-x </td>
<td> 逆向查询,可以查询IP到域名的映射</td>
</tr>
<tr>
<td>-t </td>
<td> 设置查询类型,默认情况下是A，也可以设置MX等类型</td>
</tr>
<tr>
<td>-f </td>
<td> dig支持从一个文件里读取内容进行批量查询</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nmap]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/16/nmap/"/>
    <updated>2016-11-16T16:58:26+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/16/nmap</id>
    <content type="html"><![CDATA[<blockquote><p>nmap 基本语法</p></blockquote>

<pre><code>nmap [ &lt;扫描类型&gt; ...] [ &lt;选项&gt; ] { &lt;扫描目标说明&gt; }
</code></pre>

<blockquote><p>全面进攻性扫描（包括各种主机发现、端口扫描、版本扫描、OS扫描及默认脚本扫描）</p></blockquote>

<pre><code>nmap -A -v targetip
</code></pre>

<blockquote><p>Ping扫描</p></blockquote>

<pre><code>nmap -sn -v targetip
</code></pre>

<blockquote><p>快速端口扫描</p></blockquote>

<pre><code>nmap -F -v targetip
</code></pre>

<blockquote><p>版本扫描</p></blockquote>

<pre><code>nmap -sV -v targetip
</code></pre>

<blockquote><p>操作系统扫描</p></blockquote>

<pre><code>nmap -O -v targetip
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Nmap">https://zh.wikipedia.org/wiki/Nmap</a></li>
<li><a href="https://nmap.org/man/zh/">https://nmap.org/man/zh/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二进制加法与异或]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/14/bit-xor/"/>
    <updated>2016-11-14T20:22:38+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/14/bit-xor</id>
    <content type="html"><![CDATA[<p>二进制异或相当于将每一位进行加法运算,但不进位。:&ndash;)</p>

<pre><code>    101110011           
    111111111          
    ---------              
XOR:010000100                           
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[curl]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/11/curl/"/>
    <updated>2016-11-11T10:45:37+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/11/curl</id>
    <content type="html"><![CDATA[<blockquote><p>下载首页,并在控制台显示</p></blockquote>

<pre><code>curl rungame.me
</code></pre>

<blockquote><p>下载指定路径下的文件并保存</p></blockquote>

<pre><code>curl -O http://rungame.me/images/photo.gif
</code></pre>

<blockquote><p>将下载的文件保存至指定的文件中</p></blockquote>

<pre><code>curl -o index.html http://rungame.me/
</code></pre>

<table>
<thead>
<tr>
<th>参数 </th>
<th>  作用 </th>
</tr>
</thead>
<tbody>
<tr>
<td>-o {FILE} </td>
<td>  保存至指定的文件中</td>
</tr>
<tr>
<td>-O </td>
<td>  下载指定路径下的文件并保存</td>
</tr>
<tr>
<td>-i </td>
<td>  会显示 Response Header信息和页面源码</td>
</tr>
<tr>
<td>-I </td>
<td>  只会显示 Response Header信息</td>
</tr>
<tr>
<td>-v </td>
<td>  可以显示HTTTP的请求的通信过程</td>
</tr>
<tr>
<td>&mdash;trace {OUTPUT_FILE} </td>
<td>  显示详细的HTTTP请求过程</td>
</tr>
<tr>
<td>&mdash;trace-ascii {OUTPUT_FILE} </td>
<td>  显示详细的HTTTP请求过程</td>
</tr>
<tr>
<td>&mdash;referer </td>
<td>  设置HTTP请求中的Referer</td>
</tr>
</tbody>
</table>


<h1>参见</h1>

<ul>
<li><p><a href="https://curl.haxx.se/docs/manpage.html">https://curl.haxx.se/docs/manpage.html</a></p></li>
<li><p><a href="http://blog.51yip.com/linux/1049.html">http://blog.51yip.com/linux/1049.html</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wget]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/10/wget/"/>
    <updated>2016-11-10T16:19:18+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/10/wget</id>
    <content type="html"><![CDATA[<p>wget是一个用于网络下载的自由工具,它支持HTTP、HTTPS以及FTP协议。</p>

<p>wget支持递归下载并按照robots.txt协议对远程服务器上的HTML页面信息,按照其目录结构进行拷贝。并且 wget 非常稳定,在不稳定的网络下有很强的适应性.如果是由于网络的原因下载失败,wget会不断的尝试,直到整个文件下载完毕。如果是服务器打断下载过程,它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>

<p>wget的命令格式:</p>

<pre><code>wget [options] [URL]
</code></pre>

<blockquote><p>下载文件</p></blockquote>

<pre><code>//这个命令会尝试将服务器首页下载下来
wget http://rungame.me/

//加 -x 会强制创建与服务器上一样的目录
wget -x http://rungame.me/

//加-nd 则不会创建目录
wget -nd http://rungame.me/

//-r 会按照递归的方式下载服务器下的全部内容
wget -r http://rungame.me/
</code></pre>

<blockquote><p>断点续传</p></blockquote>

<p>当文件特别大或者网络特别慢的时候,往往一个文件还没有下载完,连接就已经被切断,此时就需要断点续传。</p>

<pre><code>wget -c http://rungame.me/
</code></pre>

<blockquote><p>批量下载</p></blockquote>

<p>如果有多个文件需要下载,那么可以生成一个文件,把每个文件的URL写一行,例如生成文件 download.txt,然后用命令把文本里的文件都下载下来:</p>

<pre><code>wget -i download.txt    
</code></pre>

<blockquote><p>选择性下载</p></blockquote>

<p>可以指定wget只下载一类文件或者不下载什么文件。</p>

<pre><code>//忽略gif文件
wget -m --reject=gif http://rungame.me/
//只下载png图片
wget -m --accept=png http://rungame.me/
</code></pre>

<blockquote><p>使用代理服务器进行下载</p></blockquote>

<h1>参数</h1>

<table>
<thead>
<tr>
<th>命令参数 </th>
<th> 分类 </th>
<th> 作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-V, –version  </td>
<td> 启动  </td>
<td> 显示wget版本</td>
</tr>
<tr>
<td>-h, –help  </td>
<td> 启动  </td>
<td> 帮助</td>
</tr>
<tr>
<td>-b, -background </td>
<td> 启动  </td>
<td>启动后进入后台操作。 </td>
</tr>
<tr>
<td>-c, &mdash;continue </td>
<td> 下载  </td>
<td> 继续接收已下载了一部分的文件。</td>
</tr>
<tr>
<td>-o, –output-file=FILE </td>
<td> 下载 </td>
<td> 将下载的内容保存至指定的文件</td>
</tr>
<tr>
<td>-a, –append-output=FILE </td>
<td> 记录  </td>
<td> 把记录追加到FILE文件中</td>
</tr>
<tr>
<td>-d, –debug </td>
<td> 输出  </td>
<td>打印调试输出</td>
</tr>
<tr>
<td>-q, –quiet </td>
<td> 输出  </td>
<td> 安静模式(没有输出)</td>
</tr>
<tr>
<td>-v, –verbose  </td>
<td> 输出  </td>
<td> 冗长模式(这是缺省设置)</td>
</tr>
<tr>
<td>-nv, –non-verbose</td>
<td> 输出  </td>
<td> 关掉冗长模式，但不是安静模式</td>
</tr>
<tr>
<td>-i, –input-file=FILE </td>
<td> 输入  </td>
<td>下载在FILE文件中出现的URLs</td>
</tr>
<tr>
<td>-F, –force-html </td>
<td> 输入  </td>
<td> 把输入文件当作HTML格式文件对待</td>
</tr>
<tr>
<td>-B, –base=URL </td>
<td> 输入  </td>
<td> 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀</td>
</tr>
<tr>
<td>–sslcertfile=FILE </td>
<td> 输入  </td>
<td>  可选客户端证书</td>
</tr>
<tr>
<td>–sslcertkey=KEYFILE </td>
<td> 输入  </td>
<td>  可选客户端证书的KEYFILE</td>
</tr>
<tr>
<td>–egd-file=FILE </td>
<td> 输入  </td>
<td> 指定EGD socket的文件名</td>
</tr>
<tr>
<td>–bind-address=ADDRESS </td>
<td> 下载  </td>
<td> 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)</td>
</tr>
<tr>
<td>-t, –tries=NUMBER </td>
<td> 下载  </td>
<td> 设定最大尝试链接次数(0 表示无限制).</td>
</tr>
<tr>
<td>-O –output-document=FILE </td>
<td> 下载  </td>
<td>  把文档写到FILE文件中</td>
</tr>
<tr>
<td>-nc, –no-clobber  </td>
<td> 下载  </td>
<td> 不要覆盖存在的文件或使用.#前缀</td>
</tr>
<tr>
<td>-c, –continue  </td>
<td> 下载  </td>
<td> 接着下载没下载完的文件</td>
</tr>
<tr>
<td>–progress=TYPE </td>
<td> 下载  </td>
<td> 设定进程条标记</td>
</tr>
<tr>
<td>-N, –timestamping </td>
<td> 下载  </td>
<td> 不要重新下载文件除非比本地文件新</td>
</tr>
<tr>
<td>-S, –server-response </td>
<td> 下载  </td>
<td> 打印服务器的回应</td>
</tr>
<tr>
<td>–spider </td>
<td> 下载  </td>
<td> 不下载任何东西</td>
</tr>
<tr>
<td>-T, –timeout=SECONDS </td>
<td> 下载  </td>
<td> 设定响应超时的秒数</td>
</tr>
<tr>
<td>-w, –wait=SECONDS  </td>
<td> 下载  </td>
<td> 两次尝试之间间隔SECONDS秒</td>
</tr>
<tr>
<td>–waitretry=SECONDS  </td>
<td> 下载  </td>
<td> 在重新链接之间等待1…SECONDS秒</td>
</tr>
<tr>
<td>–random-wait  </td>
<td> 下载  </td>
<td>在下载之间等待0…2*WAIT秒</td>
</tr>
<tr>
<td>-Y, –proxy=on/off  </td>
<td> 下载  </td>
<td>打开或关闭代理</td>
</tr>
<tr>
<td>-Q, –quota=NUMBER  </td>
<td> 下载  </td>
<td>设置下载的容量限制</td>
</tr>
<tr>
<td>–limit-rate=RATE  </td>
<td> 下载  </td>
<td> 限定下载输率</td>
</tr>
<tr>
<td>-nd &mdash;no-directories </td>
<td> 目录  </td>
<td>不创建目录 </td>
</tr>
<tr>
<td>-x, &mdash;force-directories </td>
<td> 目录  </td>
<td> 强制创建目录</td>
</tr>
<tr>
<td>-nH, –no-host-directories </td>
<td> 目录  </td>
<td> 不创建主机目录</td>
</tr>
<tr>
<td>-P, –directory-prefix=PREFIX </td>
<td> 目录  </td>
<td> 将文件保存到目录 PREFIX/…</td>
</tr>
<tr>
<td>–cut-dirs=NUMBER </td>
<td> 目录  </td>
<td>  忽略 NUMBER层远程目录</td>
</tr>
<tr>
<td>&mdash;http-user=用户 </td>
<td> HTTP  </td>
<td> 配置http用户名</td>
</tr>
<tr>
<td>&mdash;http-passwd=密码 </td>
<td> HTTP  </td>
<td> 配置 http 用户密码</td>
</tr>
<tr>
<td>-C, –cache=on/off </td>
<td> HTTP  </td>
<td>允许/不允许服务器端的数据缓存 (一般情况下允许)</td>
</tr>
<tr>
<td>-E, –html-extension </td>
<td> HTTP  </td>
<td>将所有text/html文档以.html扩展名保存</td>
</tr>
<tr>
<td>–ignore-length </td>
<td> HTTP  </td>
<td> 忽略 `Content-Length’头域</td>
</tr>
<tr>
<td>–header=STRING </td>
<td> HTTP  </td>
<td> 在headers中插入字符串 STRING</td>
</tr>
<tr>
<td>&mdash;proxy-user=用户 </td>
<td> HTTP  </td>
<td> 配置代理服务器用户名 </td>
</tr>
<tr>
<td>&mdash;proxy-passwd=密码 </td>
<td> HTTP  </td>
<td>配置代理服务器用户密码</td>
</tr>
<tr>
<td>&mdash;referer=URL </td>
<td> HTTP  </td>
<td> 在 HTTP 请求中包含“Referer：URL”头</td>
</tr>
<tr>
<td>-r,-recursive </td>
<td> 递归下载  </td>
<td> 递归下载</td>
</tr>
<tr>
<td>-m, &mdash;mirror </td>
<td> 递归下载   </td>
<td> 等效于 -r -N -l inf -nr 的选项</td>
</tr>
<tr>
<td>-l, &mdash;level=数字 </td>
<td> 递归下载  </td>
<td> 最大递归深度(inf 或 0 表示无限)</td>
</tr>
<tr>
<td>-A, &mdash;accept=列表 </td>
<td> 递归下载  </td>
<td> 接受的文件样式列表，以逗号分隔。  </td>
</tr>
<tr>
<td>-R, &mdash;reject=列表 </td>
<td> 递归下载  </td>
<td> 排除的文件样式列表，以逗号分隔。</td>
</tr>
</tbody>
</table>


<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Wget">https://zh.wikipedia.org/wiki/Wget</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2013/03/18/2965369.html">http://www.cnblogs.com/peida/archive/2013/03/18/2965369.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/08/http/"/>
    <updated>2016-11-08T12:19:14+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/08/http</id>
    <content type="html"><![CDATA[<p>HTTP 全称是 HyperText Transfer Protocol ,即超文本传输协议,简称为 HTTP。</p>

<p>HTTP 最初的设计目的是将HTML页面从Web服务器加载到浏览器,但现在它的作用不止如此。当前HTTP版本有 HTTP/1.0、HTTP/1.1 和 HTTP/2 。</p>

<h1>URL地址</h1>

<p>在介绍HTTP协议之前,不得不提到一个与其息息相关的东西 URL,统一资源定位符,英语：Uniform / Universal Resource Locator，简称为 URL。</p>

<p>当我们在浏览器里输入一个URL时,实际上，这里面包含了一些我们想告诉Web服务器的一些信息,这些信息通过HTTP协议由浏览器发送至Web服务器。</p>

<p>URL中包含了五个基本元素:</p>

<ol>
<li>传送协议。</li>
<li>服务器地址。（通常为域名,有时为IP地址）</li>
<li>端口号。(若为HTTP的默认值“:80”可省略)</li>
<li>资源路径。（以“/”字符分割的服务器下的目录名称）</li>
<li>查询参数。 (URL以GET的方式向服务器数据,其中,参数以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据）</li>
</ol>


<p>一个例子:</p>

<pre><code>http://www.google.com/imghp?hl=zh-CN&amp;tab=wi&amp;ei=6AcjWJC2KZfijwOdvZfIAg&amp;ved=0EKouCBYoAQ
</code></pre>

<ol>
<li>http,是传输协议；</li>
<li>www.google.com 是服务器。</li>
<li>/imghp,是资源路径。</li>
<li>?hl=zh-CN&amp;tab=wi&amp;ei=6AcjWJC2KZfijwOdvZfIAg&amp;ved=0EKouCBYoAQ 是发送至服务器的查询数据。</li>
</ol>


<h1>协议的结构</h1>

<p>HTTP协议分为两部分:</p>

<blockquote><p>1.Request 部分</p></blockquote>

<p>在HTTP请求中,第一行必须是一个请求行,用来说明请求类型,要访问的资源以及使用的版本号,紧接着是 HTTP Header,然后是body,即发给服务器的查询信息。当使用的是&#8221;GET&#8221; 方法的时候,body是为空。</p>

<pre><code>GET http://rungame.me/ HTTP/1.1 //&lt;--请求行
Host: rungame.me
Proxy-Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 ...
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,ja;q=0.4,ceb;q=0.2,ko;q=0.2
If-Modified-Since: Thu, 03 Nov 2016 02:43:30 GMT
...body...
</code></pre>

<blockquote><p>2.Response 部分</p></blockquote>

<p>Response 也分成了三部分,第一部分用状态行替代了请求行。状态行提供了一个状态码来说明所请求的资源情况。第二部分是 Header,然后是返回的请求资源主体 body。</p>

<pre><code>HTTP/1.1 200 OK //&lt;--状态行
Server: GitHub.com
Content-Type: image/png
Last-Modified: Thu, 03 Nov 2016 02:43:30 GMT
Access-Control-Allow-Origin: *
Expires: Wed, 09 Nov 2016 12:15:13 GMT
Cache-Control: max-age=600
X-GitHub-Request-Id: C71B4A18:22F4:4416C6F:582310F9
Content-Length: 1990
Accept-Ranges: bytes
Date: Wed, 09 Nov 2016 12:05:13 GMT
Via: 1.1 varnish
Age: 0
X-Served-By: cache-sea1926-SEA
X-Cache: MISS
X-Cache-Hits: 0
X-Timer: S1478693113.536324,VS0,VE84
Vary: Accept-Encoding
X-Fastly-Request-ID: 9d29c1e4626c3decd2a6c4384ba997e75f9452d5
X-Cache: MISS from 192-241-238-165
X-Cache-Lookup: MISS from 192-241-238-165:1434
Connection: keep-alive

&lt;!DOCTYPE html&gt;
...
</code></pre>

<h1>HTTP Request Header</h1>

<p>HTTP 请求头包含许多键值对，这些键值对有什么意义与作用？</p>

<p><font color='#bd260d'><strong>1.Cache : </strong></font></p>

<ul>
<li><p>If-Modified-Since <br>
用法：If-Modified-Since: Thu, 03 Nov 2016 02:43:30 GMT<br>
把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</p></li>
<li><p>If-None-Match <br>用法：If-None-Match: &ldquo;03f2b33c0bfcc1:0&rdquo; <br>If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 。</p></li>
<li><p>Pragma：Pragma: no-cache  <br>Pargma只有一个用法， 例如： Pragma: no-cache <br>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p></li>
<li><p>Cache-Control  <br>用法： <br>Cache-Control:Public 可以被任何缓存所缓存（）<br>
Cache-Control:Private 内容只缓存到私有缓存中<br>
Cache-Control:no-cache 所有内容都不会被缓存<br>
作用：用来指定Response-Request遵循的缓存机制<br></p></li>
</ul>


<p><font color='#bd260d'><strong>2.Client : </strong></font></p>

<ul>
<li><p>Accept  <br>用法：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br>作用： 浏览器端可以接受的媒体类型；<br>
Accept: <em>/</em> 代表浏览器可以处理所有回发的类型，(一般浏览器发给服务器都是发这个） <br>
Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html ；如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)</p></li>
<li><p>Accept-Encoding   <br>用法：Accept-Encoding: gzip, deflate, sdch<br>作用： 浏览器申明自己接收的文件编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是指字符编码）</p></li>
<li><p>Accept-Language    <br>用法：zh-CN,zh;<br>作用： 浏览器申明自己接收的语言。 <br>
语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p></li>
<li><p>User-Agent   <br>用法： User-Agent: User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)&hellip;<br>作用：告诉HTTP服务器,客户端使用的操作系统和浏览器的名称和版本.</p></li>
<li><p>Accept-Charset   <br>用法：Accept-Charset：utf-8 <br>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p></li>
</ul>


<p><font color='#bd260d'><strong>3.Cookie/Login : </strong></font></p>

<ul>
<li>Cookie<br>作用：最重要的header, 将cookie的值发送给HTTP 服务器</li>
</ul>


<p><font color='#bd260d'><strong>4.Entity : </strong></font></p>

<ul>
<li><p>Content-Length   <br>用法：Content-Length: 38<br>作用：发送给HTTP服务器数据的长度。</p></li>
<li><p>Content-Type   <br>用法：Content-Type: application/x-www-form-urlencoded<br>不常出现，一般出现在response头部，用于指定数据文件类型</p></li>
</ul>


<p><font color='#bd260d'><strong>5.Miscellaneous : </strong></font></p>

<ul>
<li>Referer <br>用法：Referer: <a href="http://ce.sysu.edu.cn/hope/">http://ce.sysu.edu.cn/hope/</a><br>作用：提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</li>
</ul>


<p><font color='#bd260d'><strong>6.Transport : </strong></font></p>

<ul>
<li><p>Connection<br>Connection: keep-alive： 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br>Connection: close： 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接</p></li>
<li><p>Host <br>用法：Host: rungame.me<br>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号（默认80），它通常从HTTP URL中提取出来的</p></li>
</ul>


<h1>HTTP Response Header</h1>

<p><font color='#bd260d'><strong>1.Cache ： </strong></font></p>

<ul>
<li><p>Date <br>用法：Date: Sat, 11 Feb 2012 11:35:14 GMT<br>作用: 生成消息的具体时间和日期</p></li>
<li><p>Expires <br>用法：Expires: Tue, 08 Feb 2022 11:35:14 GMT <br>作用: 浏览器会在指定过期时间内使用本地缓存</p></li>
<li><p>Vary <br>用法：Vary: Accept-Encoding</p></li>
</ul>


<p><font color='#bd260d'><strong>2.Cookie/Login ：</strong></font></p>

<ul>
<li><p>P3P <br>用法：<br>P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR<br>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p></li>
<li><p>Set-Cookie<br>
Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com<br>作用：非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p></li>
</ul>


<p><font color='#bd260d'><strong>3.Entity ：</strong></font></p>

<ul>
<li><p>ETag <br>用法：ETag: &ldquo;03f2b33c0bfcc1:0&rdquo;<br>作用: 和request header的If-None-Match 配合使用</p></li>
<li><p>Last-Modified <br>用法：Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT<br>作用：用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p></li>
<li><p>Content-Type <br>用法：<br>Content-Type: text/html; charset=utf-8<br>
Content-Type:text/html;charset=GB2312<br>
Content-Type: image/jpeg<br>
作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集</p></li>
<li><p>Content-Encoding <br>用法：Content-Encoding：gzip<br>作用：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p></li>
<li><p>Content-Language <br>用法： Content-Language:da<br>WEB服务器告诉浏览器自己响应的对象的语言</p></li>
</ul>


<p><font color='#bd260d'><strong>4.Miscellaneous ： </strong></font></p>

<ul>
<li><p>Server <br>
用法：Server: Microsoft-IIS/7.5<br>作用：指明HTTP服务器的软件信息</p></li>
<li><p>X-AspNet-Version <br>用法：X-AspNet-Version: 4.0.30319<br>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p></li>
<li><p>X-Powered-By <br>用法：X-Powered-By: ASP.NET<br>作用：表示网站是用什么技术开发的</p></li>
</ul>


<p><font color='#bd260d'><strong>5.Transport ：</strong></font></p>

<ul>
<li>Connection <br>用法与作用： <br>Connection: keep-alive：当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br>Connection: close：代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接</li>
</ul>


<p><font color='#bd260d'><strong>6.Location头域 ：</strong></font></p>

<ul>
<li>Location <br>用法：Location：<a href="http://ce.sysu.edu.cn/hope/">http://ce.sysu.edu.cn/hope/</a> <br>作用： 用于重定向一个新的位置， 包含新的URL地址</li>
</ul>


<h1>状态码</h1>

<table>
<thead>
<tr>
<th>响应类型 </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx消息 </td>
<td> 请求已被服务器接收，继续处理  </td>
</tr>
<tr>
<td>2xx成功 </td>
<td> 请求已成功被服务器接收、理解、并接受 </td>
</tr>
<tr>
<td>3xx重定向 </td>
<td> 需要后续操作才能完成这一请求</td>
</tr>
<tr>
<td>4xx请求错误 </td>
<td> 请求含有词法错误或者无法被执行 </td>
</tr>
<tr>
<td>5xx服务器错误 </td>
<td> 服务器在处理某个正确请求时发生错误</td>
</tr>
</tbody>
</table>


<h1>例子</h1>

<p>客户端请求:</p>

<pre><code>GET / HTTP/1.1
Host: cn.bing.com 
</code></pre>

<p>服务器应答:</p>

<pre><code>HTTP/1.1 200 OK
Cache-Control: private, max-age=0
Content-Length: 120331
Content-Type: text/html; charset=utf-8
Vary: Accept-Encoding
Server: Microsoft-IIS/8.5
P3P: CP="NON UNI COM NAV STA LOC CURa DEVa PSAa PSDa OUR IND"

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ...&gt;
&lt;html lang="zh" xml:lang="zh" xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;script type="text/javascript"&gt;
...省略一大堆...
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[netcat]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/07/nc/"/>
    <updated>2016-11-07T17:00:35+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/07/nc</id>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>参数 </th>
<th> 作用 </th>
</tr>
</thead>
<tbody>
<tr>
<td>-w </td>
<td> 设置超时时间(单位:秒) </td>
</tr>
<tr>
<td>-v </td>
<td> 显示命令执行过程</td>
</tr>
<tr>
<td>-n </td>
<td> 直接使用IP地址,而不通过域名系统 </td>
</tr>
<tr>
<td>-z </td>
<td> 零模式IO(与目标服务器连接成功后即关闭,用于扫描端口)。</td>
</tr>
<tr>
<td>-l </td>
<td> 使用监听模式，管控传入的资料。</td>
</tr>
</tbody>
</table>


<blockquote><p>端口扫描</p></blockquote>

<pre><code>$nc -v -z -w 2 192.168.1.66 79-80
nc: connectx to 192.168.1.66 port 79 (tcp) failed: Connection refused
found 0 associations
found 1 connections:
     1: flags=82&lt;CONNECTED,PREFERRED&gt;
    outif en0
    src 192.168.1.49 port 61201
    dst 123.57.38.225 port 80
    rank info not available
    TCP aux info available

Connection to 123.57.38.225 port 80 [tcp/http] succeeded!
</code></pre>

<blockquote><p>传输文件</p></blockquote>

<pre><code>/* 从主机118复制文件到主机49*/
/* 首先,主机49监听端口*/
$ nc -l 6666 &gt; /Users/sbxfc/test.txt
/* 然后,主机118写入 */
$ nc 192.168.1.49 6666 &lt; /root/Documents/tmp_20161107.txt
</code></pre>

<blockquote><p>聊天</p></blockquote>

<pre><code>/* 从主机118复制文件到主机49*/
/* 首先,主机49监听端口*/
$ nc -l 7777 &gt; /Users/sbxfc/test.txt
/* 然后,主机118连接后,在控制台输入就可以保存至test.txt的文件上*/
$ nc 192.168.1.49 7777 
</code></pre>

<blockquote><p>模拟 HTTP 获取信息</p></blockquote>

<pre><code>$nc cn.bing.com 80 
GET / HTTP/1.1
Host: cn.bing.com //接下来,两次回车

HTTP/1.1 200 OK
Cache-Control: private, max-age=0
Content-Length: 120331
Content-Type: text/html; charset=utf-8
Vary: Accept-Encoding
Server: Microsoft-IIS/8.5
P3P: CP="NON UNI COM NAV STA LOC CURa DEVa PSAa PSDa OUR IND"

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ...&gt;
&lt;html lang="zh" xml:lang="zh" xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;script type="text/javascript"&gt;
...省略一大堆...
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Netcat">https://zh.wikipedia.org/wiki/Netcat</a></li>
<li><a href="https://www.oschina.net/translate/linux-netcat-command">https://www.oschina.net/translate/linux-netcat-command</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WLAN密钥解密]]></title>
    <link href="http://sbxfc.github.io/blog/2016/11/01/wlan-stream-cipher/"/>
    <updated>2016-11-01T16:10:22+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/11/01/wlan-stream-cipher</id>
    <content type="html"><![CDATA[<h1>解密操作</h1>

<blockquote><p>使用工具 Wireshark 和 Aircrack-ng</p></blockquote>

<p>首先,打开 Wireshark 并监听无线网接口。如果已开启WIFI,这时候就可以看到许多杂乱无章的捕获数据。</p>

<p>我们进行一下过滤,通过过滤 Beacon帧来寻找WIFI热点(Access Point,简称AP)。Beacon 是由热点发出的,用于告知设备自己的存在的数据帧。Beacon 是管理帧 type=00 (即0x00),并且 subtype=1000(即0x08):</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp75c54425.png" alt="ws" /></p>

<p>选择一个WIFI热点,然后点击查看其帧信息,并记录下MAC地址。(看名称可知,这是一个苹果的网卡接口,是一台开着共享的Mac电脑):</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp11983903.png" alt="ws" /></p>

<p>接着,我们以这个MAC地址线索再寻找一个与其相连的设备。(这个设备是我的iPad,因为之前获得过这个WIFI的密码,所以我把iPad的完整MAC地址隐藏掉了)</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp0a502955.png" alt="ws" /></p>

<p>在得到设备和热点的MAC地址后,我们就可以通过一些工具尝试让他们解除认证,然后抓取他们重连时的认证信息。这里,我用了之前自己写的小工具:</p>

<p><a href="https://github.com/sbxfc/wlan-macos/tree/master/deauth">https://github.com/sbxfc/wlan-macos/tree/master/deauth</a></p>

<pre><code>$ make
$ ./deauth en1 -s xx:xx:xx:xx:b0:73 -a c8:e0:eb:58:34:bd --rate 1 - number 10
</code></pre>

<p>在运行上面的示例之前,要确保你的 Wireshark 正在处于抓包状态。执行后,如果发现捕获到了四次握手数据就可以停止Wireshark了,如果没有那就再来一次。</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp2c8e7312.png" alt="ws" /></p>

<p>在成功捕获握手数据之后,将捕获数据进行保存（Wireshark->文件->另存为）。然后打开 Aircrack-ng 对数据进行解密。 Aircrack-ng 实际上是通过现有的密码字典通过PRG算法生成密钥流与加密后的流进行一系列的比对,从而找到正确的密码值。也就是说,如果你的WiFi密码设置的越复杂也就越难以破解。</p>

<p>在使用 Aircrack-ng 对数据流进行解密时,我们需要一个密码字典,你可以从网上下一个常用的密码字典。在确定设备上安装  Aircrack-ng 之后,就可以在终端下开始解密了:</p>

<pre><code>aircrack-ng -w /Volumes/sbxfc/pwd_dic/破解字典/wordlist/wordlist.txt /Users/sbxfc/Downloads/tmp.pcap
</code></pre>

<p>在运行之后,程序会询问你选择哪一个目标,一般是第一个,后面标识 handshake。输入序列号,然后回车。由于我选择的WIFI热点密码太过简单,回车之后立刻就返回结果了:</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp53ad4572.png" alt="ws" /></p>

<h1>四次握手</h1>

<p>802.11i 中的 RSN（Robust Security Network）定义了无线网络下的安全的连接流程。这个流程也就是 RSNA（Robust Security Network Association）,定义了无线网络下的认证、加密以及密钥管理。</p>

<p>STA 通过 802.1x 的认证后,AP 与 STA 都会拿到同一组 session key。有 RADIUS(认证服务器)时称为 PMK(Pairwise Master Key),无 RADIUS 时 PSK(Pre-Shared Key) 即PMK。之后进行 4-way handshake。</p>

<blockquote><p>在没有RADIUS时,AP 与 STA 会预先设定好一组 passphrase,并用其衍生出PMK。</p></blockquote>

<p>对于网络安全而言,key愈少愈好。4-way handshake 建立了 512 bits的PTK(Pairwise Transient Key)。PTK 由 PMK,AP Nonce,STA Nonce,AP&#8217;MAC,STA&#8217;MAC 生成。4-way handshake 也会产生GTK（Group Temporal Key）,用来解密 multicast和broadcast traffic。这个GTK是所有STA公用的一个key。</p>

<p><img src="http://sbxfc.github.io/images/2016/10/tmp13152092.png" alt="4-handshake" /></p>

<ol>
<li>AP 发送 ANonce 至 STA。</li>
<li>STA 收到后,用 ANonce 和已知信息生成PTK,并通过PTK中的KCK生成检验码MIC,附上SNonce 发送至 AP。</li>
<li>AP 收到后也生成 PTK,然后用PTK中的KCK部分对MIC进行校验。成功,则发送GTK和MIC至STA。</li>
<li>STA 答复。</li>
</ol>


<p>WPA1 TKIP的 PTK 长度512bits,WPA2 CCMP的PTK长度为384bits。其中,TMK1 和 TMK2 只用在 TKIP 加密data时。</p>

<p>PTK由几部分组成:</p>

<table>
<thead>
<tr>
<th>内存区域 </th>
<th> 简称 </th>
<th> 长度(bits)</th>
<th> 名称 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-127   </td>
<td> KCK  </td>
<td>128 </td>
<td> EAPOL-Key Confirmation Key</td>
<td> 计算WPA EAPOL key message 的MIC</td>
</tr>
<tr>
<td>128-255  </td>
<td> KEK  </td>
<td>128</td>
<td> EAPOL-Key Encryption Key</td>
<td> 加密额外要送给STA的data,如 GTK or RSN IE</td>
</tr>
<tr>
<td>256-383  </td>
<td> TEK </td>
<td>128</td>
<td> Temporal Encryption Key</td>
<td> 解密unicast packets</td>
</tr>
<tr>
<td>384-447  </td>
<td> TMK1  </td>
<td>64</td>
<td> Temporal AP Tx MIC Key</td>
<td> 计算AP 发送的unicast packet的MIC</td>
</tr>
<tr>
<td>448-511  </td>
<td> TMK2  </td>
<td>64</td>
<td> Temporal AP Rx MIC Key</td>
<td> 计算STA 发送的unicast packet的MIC</td>
</tr>
</tbody>
</table>


<p>PTK算法:</p>

<p>首先使用PBKDF2（Password-Based Key Derivation Function 2）算法生成一个32字节的PMK key，该算法需要执行4096*2轮,同时由于使用了SSID（0-32字符）进行salt。</p>

<pre><code> PMK = PBKDF2(HMAC−SHA1, pwd, ssid, 4096, 256)
</code></pre>

<p>PTK使用PRF-512（pseudo random functions 512bits）算法产生，通过PMK、固定字符串、AP_Mac、Sta_Mac、ANonce、SNonce六个输入参数得到一个512 bits的PTK。</p>

<pre><code> PTK = PRF-512(PMK, “Pairwise key expansion”, Min(AP_Mac, Sta_Mac) ||Max(AP_Mac, Sta_Mac) || Min(ANonce, SNonce) || Max(ANonce, SNonce))
</code></pre>

<p>MIC算法:</p>

<pre><code>//WAP1
MIC = HMAC(EVP_sha1(), KCK, 16, eapol_data，eapol_size) 
//WAP2
MIC = HMAC(EVP_md5(), KCK, 16, eapol_data，eapol_size)
</code></pre>

<h1>解密原理</h1>

<p><img src="http://sbxfc.github.io/images/2016/10/142303547147.png" alt="4-handshake" /></p>

<p>破解时,利用我们字典中 PSK 和 ESSID 生成PMK。</p>

<p>然后结合已知的STA&#8217;MAC、BSSID、AP&#8217;NONCE、STA&#8217;NONCE计算出PTK。</p>

<p>然后加上原始的报文数据算出MIC,并与AP发送的MIC比较。如果一致，那么该PSK就是密钥。</p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86">https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86</a></li>
<li><a href="http://www.cnblogs.com/rainbowzc/p/5410876.html">http://www.cnblogs.com/rainbowzc/p/5410876.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看类UNIX系统下的进程]]></title>
    <link href="http://sbxfc.github.io/blog/2016/10/17/ps/"/>
    <updated>2016-10-17T16:52:11+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/10/17/ps</id>
    <content type="html"><![CDATA[<h1>ps</h1>

<p>ps程序 ( process status 的简称) 是类Unix系统下用来查看系统进程的命令。在终端里,不带参数运行时,该命令显示与当前登陆用户相关的bash命令:</p>

<pre><code>$ps
 PID  TTY        TIME    CMD
 6122 ttys003    0:00.25 -bash
 6356 ttys003    0:00.01 /Users/sbxfc/...
</code></pre>

<p>如果添加 <font color='#bd260d'><strong>-l</strong></font> 参数,则会在此基础上显示更详细的信息:</p>

<pre><code>$ps -l
  UID  PID   PPID     F     CPU PRI NI SZ        RSS  WCHAN  S   ADDR TTY           TIME CMD
  501  6122  6121     4006   0  31  0  2463084   3212 -      S   0    ttys003    0:00.26 -bash
  501  6356     1     4006   0  31  0  2463148   3052 -      S   0    ttys003    0:00.01 /Users/sbxfc/...
</code></pre>

<p>如果是查看所有程序,通常会使用 <font color='#bd260d'><strong>aux</strong></font> 参数。其中 <font color='#bd260d'><strong>a</strong></font> 列出了一个终端上的所有进程,包括其他用户运行的,<font color='#bd260d'><strong>x</strong></font>列出所有没有控制终端的进程,<font color='#bd260d'><strong>u</strong></font> 添加了一列显示每个进程的控制用户。需要注意的是，为了提高兼容性，使用此语法时&#8221;aux&#8221; 前没有 &ldquo;&ndash;&rdquo; 。</p>

<pre><code>$ps aux
USER   PID   %CPU %MEM VSZ     RSS      TT  STAT STARTED   TIME COMMAND
sbxfc  6105  12.1 1.1  3034064 141676  ??  S    4:55下午  5:00.59 /Applications/Google Chrome.app/Contents/...
sbxfc  5813  5.6  0.5  2784956 62488   ??  S    3:47下午  0:35.94 /Applications/Utilities/Terminal.app/Contents
sbxfc  261   4.6  1.8  3049408 223952  ??  S    9:55上午  19:03.62 /Applications/QQ.app/Contents/MacOS/QQ
sbxfc  6552  2.5  0.2  2516792 22536   ??  S    6:34下午  0:00.35 /System/Library/Frameworks/CoreServices...
...
</code></pre>

<h1>配合grep使用</h1>

<p>ps 可以配合 grep 使用并擦出火花:</p>

<pre><code>$ ps aux | grep chrome
sbxfc 6720   0.0  0.0  2434840    772 s001  S+    7:01下午   0:00.00 grep chrome
</code></pre>

<h1>其他有用参数</h1>

<p>指定用户运行的进程:</p>

<pre><code>$ ps -u sbxfc
</code></pre>

<h1>对应列名</h1>

<table>
<thead>
<tr>
<th>列名  </th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td> %CPU</td>
<td>  进程正在使用多少个CPU</td>
</tr>
<tr>
<td> %MEM</td>
<td>  进程正在使用多少内存</td>
</tr>
<tr>
<td>ADDR    </td>
<td>进程的内存地址</td>
</tr>
<tr>
<td>C或CP</td>
<td> CPU使用率和调度信息</td>
</tr>
<tr>
<td>COMMAND*    </td>
<td>进程名，包括参数（如果有的话）</td>
</tr>
<tr>
<td>NI  </td>
<td>nice值</td>
</tr>
<tr>
<td>F   </td>
<td>标志</td>
</tr>
<tr>
<td>PID </td>
<td>进程ID</td>
</tr>
<tr>
<td>PPID    </td>
<td>父进程ID</td>
</tr>
<tr>
<td>PRI </td>
<td>进程优先级</td>
</tr>
<tr>
<td>RSS </td>
<td>真实内存用量</td>
</tr>
<tr>
<td>S or STAT   </td>
<td>进程状态码</td>
</tr>
<tr>
<td>START or STIME  </td>
<td>进程启动时间</td>
</tr>
<tr>
<td>SZ  </td>
<td>虚拟内存用量</td>
</tr>
<tr>
<td>TIME    </td>
<td>总CPU用量</td>
</tr>
<tr>
<td>TT或TTY    </td>
<td>与进程相关的终端</td>
</tr>
<tr>
<td>UID或USER  </td>
<td>进程所有者的用户名</td>
</tr>
<tr>
<td>WCHAN   </td>
<td>进程所等待事件的内存地址</td>
</tr>
</tbody>
</table>


<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Ps_(Unix)">https://zh.wikipedia.org/wiki/Ps_(Unix)</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds4/ps.htm">https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds4/ps.htm</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php#process_1">http://linux.vbird.org/linux_basic/0440processcontrol.php#process_1</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nslookup工具]]></title>
    <link href="http://sbxfc.github.io/blog/2016/10/10/nslookup/"/>
    <updated>2016-10-10T11:15:36+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/10/10/nslookup</id>
    <content type="html"><![CDATA[<p>输入 nslookup 加上域名后回车,会直接对域名进行查询:</p>

<pre><code>sbxfc$ nslookup sbxfc.ok2.site
Server:     223.5.5.5
Address:    223.5.5.5#53

Non-authoritative answer:
Name:   sbxfc.ok2.site
Address: 35.164.14.188
</code></pre>

<p>直接输入 nslookup 后回车,会进入交互模式,键入<sup>D</sup>(control-D) 或 exit 退出。</p>

<pre><code>sbxfc$ nslookup
&gt; ^D
</code></pre>

<p>默认情况下 nslookup 会查询A（地址记录）</p>

<pre><code>sbxfc$ nslookup
&gt; sbxfc.ok2.site
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
Name:   sbxfc.ok2.site
Address: 35.164.14.188
&gt; ^D
</code></pre>

<p>如果输入的是IP地址(且nslookup的查询类型是A或PTR),那么nslookup就会将地址反转,在尾部添加上in-add.arpa,然后查找PTR记录:(我用的是一台亚马逊ec2主机)</p>

<pre><code>sbxfc$ nslookup
&gt; 35.164.14.188
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
188.14.164.35.in-addr.arpa  name = ec2-35-164-14-188.us-west-2.compute.amazonaws.com.

Authoritative answers can be found from:
</code></pre>

<p>查询name server(NS):</p>

<pre><code>$ nslookup
&gt; set type=NS
&gt; sina.com.cn
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
sina.com.cn nameserver = ns4.sina.com.cn.
sina.com.cn nameserver = ns2.sina.com.cn.
sina.com.cn nameserver = ns1.sina.com.cn.
sina.com.cn nameserver = ns3.sina.com.cn.

Authoritative answers can be found from:
&gt;exit
</code></pre>

<p>指定客户度解析服务器来查询域名的IP:</p>

<pre><code>$ nslookup - 8.8.8.8
&gt; 163.com
Server:     8.8.8.8
Address:    8.8.8.8#53

Non-authoritative answer:
Name:   163.com
Address: 123.58.180.8
Name:   163.com
Address: 123.58.180.7
&gt;exit
</code></pre>

<p>当然也可以这写:</p>

<pre><code>$ nslookup 163.com 8.8.8.8
</code></pre>

<p>查看邮件服务器:</p>

<pre><code>$ nslookup
&gt; set type=MX
&gt; 163.com
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
163.com mail exchanger = 10 163mx01.mxmail.netease.com.
163.com mail exchanger = 10 163mx02.mxmail.netease.com.
163.com mail exchanger = 10 163mx03.mxmail.netease.com.
163.com mail exchanger = 50 163mx00.mxmail.netease.com.

Authoritative answers can be found from:
&gt; set type=A
&gt; 163mx01.mxmail.netease.com
Server:     114.114.114.114
Address:    114.114.114.114#53

Non-authoritative answer:
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.138
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.137
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.140
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.142
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.141
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.143
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.139
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.135
Name:   163mx01.mxmail.netease.com
Address: 220.181.14.136
</code></pre>

<p>查看顶级域信息</p>

<pre><code>$ nslookup - 8.8.8.8
&gt; set type=ns
&gt; me.
Server:     8.8.8.8
Address:    8.8.8.8#53

Non-authoritative answer:
me  nameserver = a0.cctld.afilias-nst.info.
me  nameserver = a2.me.afilias-nst.info.
me  nameserver = b0.cctld.afilias-nst.org.
me  nameserver = b2.me.afilias-nst.org.
me  nameserver = c0.cctld.afilias-nst.info.
me  nameserver = d0.cctld.afilias-nst.org.
me  nameserver = ns.nic.me.
me  nameserver = ns2.nic.me.

Authoritative answers can be found from:
&gt; 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GNU C 中的 __attribute__ 机制]]></title>
    <link href="http://sbxfc.github.io/blog/2016/09/21/attribute-syntax/"/>
    <updated>2016-09-21T18:31:09+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/09/21/attribute-syntax</id>
    <content type="html"><![CDATA[<h1>__attribute__ 机制</h1>

<p>__attribute__ 是 GCC 提供的一种语法,可以帮助我们在编译时对声明的函数、变量和类型做一些特殊处理或者是检查操作。</p>

<p>__attribute__ 的语法格式为: <font color='#bd260d'><strong>__attribute__ ((attribute-list))</strong></font> , attribute-list 是指令集 , __attribute__ 出现在函数、变量和类型声明的 <font color='#bd260d'><strong>&ldquo;;&rdquo;</strong></font> 前。</p>

<p>__attribute__ 有三类,分别为函数属性(Function Attribute) 、变量属性(Variable  Attribute) 和类型属性(Type  Attribute)</p>

<h1>一,函数属性</h1>

<p><font color='#bd260d'><strong>1. format (archetype, string-index, first-to-check)</strong></font></p>

<p>format 属性通过指定 <em>printf, scanf, strftime</em> 或 <em>strfmon</em> 等方法来检测函数的参数是否同样适用于这些指定的格式化字符串方法,如果不适用,编译器在编译时的就会发出警告,从而发现错误。</p>

<pre><code>extern int
my_printf (int value, const char *my_format, ...)
__attribute__ ((format (printf, 2, 3)));

void foo()
{
    my_printf(0, "age = %d\n",17);
    my_printf(0, "age = %d\n","17");
    my_printf(0, "age = %d name = %s\n",17,"sbxfc");
}
</code></pre>

<p>上面示例中, format 属性的第一个参数指定了一个 printf 方法,第二个参数 string-index  表示函数 my_printf 里格式化参数是总参数的第几个,这里我们的格式化参数 <font color='#bd260d'><strong>my_format</strong></font> 是第2个参数,format 属性的第三个参数表示,参数集合 (<font color='#bd260d'><strong>&hellip;</strong></font>) 从函数 my_printf 的第几个参数开始出现。</p>

<p>如无意外,上述示例在 gcc 编译时会提示以下警告信息:</p>

<pre><code>$ gcc -c main.c
main.c:12:31: warning: format specifies type 'int' but the argument has type
  'char *' [-Wformat]
my_printf(0, "age = %d\n","17");
</code></pre>

<p>去掉 __attribute__ 属性,该示例则不会提示错误,但运行时会出错。</p>

<p><font color='#bd260d'><strong>2.  noreturn </strong></font></p>

<p>noreturn 属性表示其指定的函数没有返回值,当编译器执行到这时,要面对现实,不要大惊小怪(~慌忙报错~)。下面是 fatal 的部分代码,在程序出错的位置调用 fatal 函数打印信息,然后直接退出程序,不需要 return。</p>

<pre><code>void fatal () __attribute__ ((noreturn));

void
fatal (/* ... */)
{
  /* ... */ /* Print error message. */ /* ... */
  exit (1);
}
</code></pre>

<p><font color='#bd260d'><strong>3.  deprecated </strong></font></p>

<p>deprecated 属性可以用来标识一个预计将会被弃用的函数,如果开发者使用该函数,编译时就会发出警告,并提示出错的行数。警告信息只会在开发者调用该函数时才会提示:</p>

<pre><code>int old_fn () __attribute__ ((deprecated));
int old_fn ();
int (*fn_ptr)() = old_fn;
</code></pre>

<p>在上面示例中,只会在第3行提出警告:</p>

<pre><code>main.c:7:19: warning: 'old_fn' is deprecated [-Wdeprecated-declarations]
int (*fn_ptr)() = old_fn;
                    ^
main.c:6:5: note: 'old_fn' has been explicitly marked deprecated here
int old_fn ();
</code></pre>

<p>deprecated 也可以用于<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Variable-Attributes.html#Variable-Attributes">变量</a>和<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Type-Attributes.html#Type-Attributes">类型</a>。</p>

<p><font color='#bd260d'><strong> 4. constructor &amp; destructor</strong></font></p>

<p>设置 constructor 属性可以使函数在 main 方法之前执行,而设置 destructor 可以使函数在 main 方法之后执行。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

__attribute__((constructor)) void before_func (){
  printf("before \n");
}

__attribute__((destructor)) void after_func (){
  printf("after \n");
}

int main(){
  printf("main func \n");
  return 0;
}
</code></pre>

<p>不出意外,会看到以下输出:</p>

<pre><code>$ gcc main.c
$ ./a.out 
before 
main func 
after   
</code></pre>

<p>constructor 、 destructor 函数也可以设置执行的优先级:</p>

<pre><code>__attribute__((constructor(PRIORITY)))
__attribute__((destructor(PRIORITY)))
</code></pre>

<h1>二,变量属性</h1>

<p><font color='#bd260d'><strong> 1.  aligned (alignment) </strong></font></p>

<p>aligned 属性让其指定的变量或结构体成员按 alignment 字节大小对齐。如果其中对齐长度有长度大于 alignment的,则按照最大对齐长度来对齐。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//结构体的对齐值为8
struct foo {
  char a;
  int x[2] __attribute__ ((aligned (8)));
};

int main(){
  int s0 = sizeof(struct foo);
  printf("s0 = %d\n",s0);//print s0 = 16
  return 0;
}
</code></pre>

<p><font color='#bd260d'><strong> 2.  packed </strong></font></p>

<p>packed 属性用于设置变量或结构体成员以最小的对齐方式对齐。</p>

<p>在下面的结构体中,由于 x 已经使用 packed 进行对齐,所以此时结构体以 a 的size来对齐:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct foo{
  char a;
  int x[2] __attribute__ ((packed));
};

int main(){
  int s0 = sizeof(struct foo);
  printf("s0 = %d\n",s0);//print s0 = 9
  return 0;
}
</code></pre>

<h1>三,类型属性</h1>

<p><font color='#bd260d'><strong> 1. packed </strong></font></p>

<p>如果 packed 属性用在 struct 或 union 上,表示该结构的成员变量按照紧凑模式对齐,即以变量的实际占用字节对齐,不用编译器进行优化对齐。如果用在 enum 上,则表示使用最小的整数来存储枚举类型。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct my_unpacked_struct{
  char c;
  int i;
};

struct __attribute__ ((__packed__)) my_packed_struct {
   char c;
   int  i;
   struct my_unpacked_struct s;
};

int main(){
  int s0 = sizeof(struct my_unpacked_struct);
  int s1 = sizeof(struct my_packed_struct);
  printf("s0 = %d,s1 = %d\n",s0,s1);//print s0 = 8,s1 = 13
  return 0;
}
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html">https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Function-Attributes.html</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Variable-Attributes.html#Variable-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Variable-Attributes.html#Variable-Attributes</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Type-Attributes.html#Type-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Type-Attributes.html#Type-Attributes</a></li>
<li><a href="http://blog.zhangjikai.com/2015/11/28/%E3%80%90C%E3%80%91alignment/">http://blog.zhangjikai.com/2015/11/28/%E3%80%90C%E3%80%91alignment/</a></li>
<li><a href="http://www.jianshu.com/p/6153eccdbe62">http://www.jianshu.com/p/6153eccdbe62</a></li>
<li><a href="http://blog.wangruofeng007.com/blog/2016/01/13/attribute/">http://blog.wangruofeng007.com/blog/2016/01/13/attribute/</a></li>
<li><a href="http://unixwiz.net/techtips/gnu-c-attributes.html">http://unixwiz.net/techtips/gnu-c-attributes.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS - Property的修饰词]]></title>
    <link href="http://sbxfc.github.io/blog/2016/09/14/objc-modifiers/"/>
    <updated>2016-09-14T14:11:45+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/09/14/objc-modifiers</id>
    <content type="html"><![CDATA[<h1>原子性</h1>

<p><font color='#bd260d'><strong>nonatomic/atomic</strong></font>  是objc里有关属性原子操作的两种修饰词,其中 nonatomic 是非线程安全的,即不对 setter/getter 操作进行加锁,而 atomic 会对生成的 setter/getter 添加<font color='#bd260d'><strong>类似于</strong></font>下面这样的互斥锁操作:</p>

<pre><code>- (void) setProperty:(property_type *) property {
    @synchronized(self){
        _property = property;
    }
}
</code></pre>

<p>尽管,Apple 可能会使用一些比 @synchronized 更加高级的互斥操作,但是由于 atomic 本身并不能保证已加锁的类和对象是 <font color='#bd260d'><strong>thread safe</strong></font> 的,并且 atomic 在加锁时会消耗一些系统资源,我们一般会用 nonatomic 来作为修饰词。</p>

<p>需要注意的是,如果你没有在属性上键入 nonatomic 修饰词,编译器会把 atomic 当做默认修饰词( <a href="http://stackoverflow.com/questions/5168331/why-is-atomic-a-default-property-qualifier-in-objective-c-when-i-find-myself"><font color='#bd260d'><strong>吐槽看这里</strong></font></a> )。</p>

<h1>读写权限</h1>

<p><font color='#bd260d'><strong>readwrite/readonly</strong></font> 定义了属性的访问权限,其中 readwrite 是可读写,当你声明这个修饰词时,编译器会生成该属性的 setter/getter方法。readonly 为只读,当声明该属性时只会生成 getter 方法。</p>

<p>假如你只声明了 readonly 权限,但自己手动实现了 setter 方法,该属性也会变成可读可写的(囧)。所有属性,如果未声明读写权限,编译器会以 readwrite 作为默认方式处理。</p>

<h1>内存管理</h1>

<p><font color='#bd260d'><strong>1.  strong/retain</strong></font> 在 MRC (Mannul Reference Counting) 时代,当我们想得到一个对象的控制权时,我们会对该对象进行 retain 操作。这样一来,该对象的引用次数就会增加1,即便在其他地方,该对象的其他指针被置为 nil 或者是被 release过一次。但由于其总引用次数没有减小至0,系统依旧不会释放该对象,不会出现 &ldquo;EXC_BAD_ACCESS&rdquo; 错误。</p>

<pre><code>/**
 * 使用retain标识属性的内存处理方式时,会在 setter 方法里,
 * 对传入的对象进行引用计数加1的操作。
 */
-(void)setProperty:(property_type*)property{  
     if ( _property != property){  
          [_property release];  
          _property = [property retain];  
     }  
}
</code></pre>

<p>进入 ARC (Auto Reference Counting) 时代,retain 被 strong 取代了。实际上,在ARC环境里,无论是使用 strong 还是 retain ,其作用是完全一致的, strong = retain 。但 ARC 环境里,因为编译器会帮我们自动处理 setter 和 getter 里的 retain 和 release 操作,这时用 strong 修饰词就显得更 ARC 的语意。</p>

<p>在objc里,object 类型的属性默认内存处理方式是 strong,也就是说,即便你没有指明 object 属性内存修饰词时,系统会默认按照 strong 的方式处理该属性。而基本类型(int、float、double、NSInteger，CGFloat等) 的属性,其默认是以 <font color='#bd260d'><strong>assign</strong></font> 的方式处理的。</p>

<p><font color='#bd260d'><strong>2.  assign/weak/unsafe_unretained</strong></font> 使用 assign 修饰的属性,在赋值时 setter 方法里进行的是简单的指针拷贝,并没有像 retain 或 strong 那样进行引用计数的增加。对于基本类型,由于其本身是由系统自动分配和管理的,不需要考虑内存问题,所以可以直接使用指针来赋值。但如果用 assign 修饰 object 属性,一旦属性指向的对象中的其中一个引用指针被为nil,系统就会回收该对象,由此会导致,当我们访问该 object 属性时出现 &ldquo;EXC_BAD_ACCESS&rdquo; 错误。</p>

<p>对于 object 类型的属性,如果我们不想持有该属性指向的对象。我们可以使用 weak 修饰词,weak 修饰词和 assign 类似 ,唯一的区别是,当 weak 修饰的属性如果其指向对象的指针在别处被置为nil,导致该对象被释放,那么 weak 属性里的成员变量指针也会被置为nil,从而不会出现野指针的情况。(delegate 和 Outlet 一般用weak来声明。)。</p>

<p>在ARC之前,我们通常用 assign 来修饰基本类型,而 unsafe_unretained 则通常用于“对象类型”,unsafe_unretained 与 assign 是等价的,在实际使用时 unsafe_unretained 修饰“基础类型”并不会报错 。进入ARC之后,我们用weak代替unsafe_unretained修饰“对象类型”。</p>

<p><font color='#bd260d'><strong>3.  copy</strong></font> 与strong类似，但区别在于属性的成员变量是对传入对象的副本拥有所有权，而非对象本身。</p>

<h1>参见</h1>

<ul>
<li><a href="http://stackoverflow.com/questions/5168331/why-is-atomic-a-default-property-qualifier-in-objective-c-when-i-find-myself">http://stackoverflow.com/questions/5168331/why-is-atomic-a-default-property-qualifier-in-objective-c-when-i-find-myself</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于属性和成员变量的疑惑]]></title>
    <link href="http://sbxfc.github.io/blog/2016/09/13/objc-property/"/>
    <updated>2016-09-13T10:03:20+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/09/13/objc-property</id>
    <content type="html"><![CDATA[<h1>成员变量和属性</h1>

<p>在objc里变量有两种写法，一种是以 <font color='#bd260d'><strong>@property</strong></font> 形式声明的属性,另一种是定义在大括号里 (<font color='#bd260d'><strong>@interface :NSObject{}</strong></font> )的成员变量( <font color='#bd260d'><strong>instance variable</strong></font> )。</p>

<pre><code>@interface MyObject : NSObject {
    NSInteger memberVar; // 成员变量
}

@property NSInteger value; // 属性

@end
</code></pre>

<p>这两者有什么区别呢?</p>

<p>从设计的角度上来讲, @property 方式声明的属性,主要是用来暴露给外部访问用的。而成员变量( instance variable )是内部变量,主要用作内部使用,外部无法访问。</p>

<p>需要留意的是,成员变量既可以在 <font color='#bd260d'><strong>@interface :NSObject{}</strong></font> 里声明,也可以在 <font color='#bd260d'><strong>@Implementation :NSObject{}</strong></font> 里声明。在 <font color='#bd260d'><strong>@Interface</strong></font> 区域声明的成员变量默认权限是protected,能被被子类访问,而在 <font color='#bd260d'><strong>@implementation</strong></font>里声明的成员变量权限是private。在 <font color='#bd260d'><strong>@implementation</strong></font> 里定义私有成员变量更符合面向对象的封装原则,因为此类别的信息不会暴露于公开的interface中。</p>

<p>成员变量和属性在访问时也有所不同,属性可以用<font color='#bd260d'><strong>点表达式(.)</strong></font> 来访问(<font color='#bd260d'><strong>self.name</strong></font>),而成员变量,因为是内部变量可以直接使用变量名(<font color='#bd260d'><strong>name</strong></font>)访问或者通过<font color='#bd260d'><strong>右箭头(&ndash;>)</strong></font>来访问(<font color='#bd260d'><strong>self->name</strong></font>)。</p>

<h1>属性的声明</h1>

<p>经常看到有的人用 <font color='#bd260d'><strong>@property</strong></font>声明了属性,又在<font color='#bd260d'><strong>@interface</strong></font>里定义了相同的成员变量。</p>

<pre><code>@interface MyObject : NSObject{
    NSInteger value;
}

@property NSInteger value;
@end
</code></pre>

<p>首先应当了解一下 @property 的用法。当我们用 @property （和 @synthsize) 声明一个属性时,在 .h 文件里 @property会让编译器帮我们创建两个存取方法的声明:</p>

<pre><code>- (NSInteger)propertyName;      
- (void)setPropertyName:(NSInteger)value;
</code></pre>

<p>而在 .m 文件里, <font color='#bd260d'><strong>@synthesize propertyName</strong></font> 会告诉编译器,帮我们创建这两个声明的实现函数,并且以 propertyName 命名该属性的成员变量。</p>

<pre><code>- (void)setPropertyName:(NSInteger)value{   
    propertyName  =  value;
}

- (NSInteger)propertyName{
    return  propertyName;
}
</code></pre>

<p>因此,在使用 @property （和 @synthsize) 声明属性时,编译器帮我们生成读写方法的同时,也会自动创建一个成员变量,不需要我们手动去创建。</p>

<p>假如,我们不想使用现有的属性名作为成员变量名,我们可以将 <font color='#bd260d'><strong>@synthesize propertyName</strong></font> 改为 <font color='#bd260d'><strong>@synthsize propertyName = xxx</strong></font>  的形式,这样我们的成员变量就变成了 <font color='#bd260d'><strong>xxx</strong></font>。Xcode4.5 以后,如果我们没有写 @synthsize ,系统会为我们自动生成一个 @synthsize 并指定一个以下划线 ( <font color='#bd260d'><strong>_</strong></font> ) 为前缀,加上属性名的成员变量,即  <font color='#bd260d'><strong>@synthsize propertyName = _propertyName</strong></font> 。</p>

<h1>.h和.m文件</h1>

<p>在objc里,类的定义（interface）与实现（implementation）被分成了两个部分。我们知道在 @interface 里面定义的属性和函数主要用于外部访问,但是这里有一个的前提条件:</p>

<pre><code>//MyObject.h
@interface MyObject : NSObject{
    NSInteger memberVar1;
}

@end

//MyObject.m
@interface MyObject(){
    NSInteger memberVar2;
}

@end
</code></pre>

<p>在上面的 .h 和 .m文件里的两个 @interface 定义区域里,我们分辨创建了两个成员变量 memberVar1 和 memberVar2。其中在 .h 里面写的成员变量会暴露出来,而在 .m里写的变量外界是看不到的,也不能访问。</p>

<p>当我们在子类里访问该类的成员变量时,只能看到暴露出来的memberVar1。</p>

<p><img src="http://sbxfc.github.io/images/2016/9/tmp799c4889.png" alt="" /></p>

<p><font color='#bd260d'><strong>所有定义在 .m文件里的变量和函数,无论是 @interface 还是 @implementation ,外界是无法访问的。</strong></font></p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Objective-C">https://zh.wikipedia.org/wiki/Objective-C</a></li>
<li><a href="http://www.cnblogs.com/letmefly/archive/2012/07/20/2601338.html">http://www.cnblogs.com/letmefly/archive/2012/07/20/2601338.html</a></li>
<li><a href="http://www.devtalking.com/articles/you-should-to-know-property/">http://www.devtalking.com/articles/you-should-to-know-property/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译一个C程序]]></title>
    <link href="http://sbxfc.github.io/blog/2016/07/07/compile/"/>
    <updated>2016-07-07T15:37:57+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/07/07/compile</id>
    <content type="html"><![CDATA[<p>GCC是类Unix操作系统下的标准编译器,在Linux或者是以FreeBSD为基础的macOS下可以直接使用。</p>

<h1>编译一个简单的C程序</h1>

<p>下面的代码被包含在一个名为<font color='#bd260d'><strong>test.c</strong></font>的文本文件里:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(){
    printf("Hello World!\n");
}   
</code></pre>

<p>你可以通过macOS终端直接编译该文件:</p>

<pre><code>$gcc test.c -o test
</code></pre>

<p>编译指令会将test.c编译成一个名为test的可执行程序,<font color='#bd260d'><strong>-o</strong></font>参数用于指定编译后的程序名。 执行程序<font color='#bd260d'><strong>(./test)</strong></font>时屏幕上会输出 <em>Hello World!</em></p>

<p>除此之外,你也可以执行下面两行编译命令来生成test程序</p>

<pre><code>$gcc -c test.c
$gcc test.o -o test
</code></pre>

<p>和第一条编译命令相比,除了执行命令多出一行以外,还额外生成了一个名为test.o的文件。这是因为,GCC在编译C程序时要经过预处理、编译、汇编和连接四步。通过第二种方式,编译器首先会将源文件test.c编译成名为hello.o的机器语言程序。接着,再将hello.o和一些用于输出&#8221;Hello World&#8221;的系统库链接在一起,并合成最终的可执行程序test。</p>

<p>而第一种方式同样执行了这两步,只不过编译器在后台悄悄运行,并删除了中间文件test.o</p>

<h1>编译参数</h1>

<p>在编译时,我们可以指定一些参数来告诉编译器如何编译我们的程序</p>

<p>在编译命令里加入<font color='#bd260d'><strong>-g</strong></font>选项,可以开启 gdb 对程序进行调试,通过输入命令 <font color='#bd260d'><strong>gdb ./test</strong></font>进入调试模式</p>

<pre><code>$gcc -g test.c -o test
</code></pre>

<p>在编译命令里加入<font color='#bd260d'><strong>-Wall</strong></font>选项会打印出程序编译时的警告信息,包括一些语法问题。</p>

<pre><code>$gcc -Wall test.c -o test
</code></pre>

<p>加入 <font color='#bd260d'><strong>-O</strong></font>选项,开启默认优化。</p>

<pre><code>$gcc -O test.c -o test
</code></pre>

<p>加入 <font color='#bd260d'><strong>-shared</strong></font> ,用来生成共享文件<font color='#bd260d'><strong>*.so</strong></font>(Shared Object)</p>

<pre><code>$gcc -shadred test.c -o libtest.so
</code></pre>

<h1>链接库（-l&amp;-L）</h1>

<p>当程序需要一些系统库或我们自己生成的类库时,并且这个库文件是在以下三个目录之中时,<font color='#bd260d'><strong>/lib、/usr/lib和/usr/local/lib</strong></font>,我们就可以在编译指令里加入<font color='#bd260d'><strong>-l</strong></font>参数来指定编译时需要链接的库文件。</p>

<p>-l参数和其他参数的用法有所不同,-l后面不加空格并直接跟要链接的库名,比如说我们要连接的库为libm.dylib数学库,那么我们要写成<font color='#bd260d'><strong>-lm</strong></font>的形式,即库名去掉lib和.dylib后的库名。这样,编译器在链接时就会自动在目录<font color='#bd260d'><strong>/lib、/usr/lib和/usr/local/lib</strong></font>下寻找要链接的库文件</p>

<pre><code>gcc test.c -o test -lm
</code></pre>

<p>但是,如果要链接的库不在这三个目录之列时,通过-l链接就会出错。这时可以用到<font color='#bd260d'><strong>-L</strong></font>参数。-L参数用来指定库的目录位置。比如我们用到当前项目下的lib文件夹里的库文件(<font color='#bd260d'><strong>../lib</strong></font>),我们可以写成如下格式:</p>

<pre><code>gcc test.c -o test -L../lib
</code></pre>

<h1>指定头文件目录(-I)</h1>

<p>有时,我们会将头文件放在一个统一的目录里,比如<font color='#bd260d'><strong>include</strong></font>文件夹。
这时候,我们可以在编译指令里加入<font color='#bd260d'><strong>-I</strong></font>参数来指定头文件的目录</p>

<pre><code>gcc test.c -o test -I./include
</code></pre>

<p>当然你也可以在引用头文件的时写成完整路径的形式<font color='#bd260d'><strong>./include/header.h</strong></font></p>

<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/GCC">https://zh.wikipedia.org/wiki/GCC</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/04/03/2998652.html">http://www.cnblogs.com/vamei/archive/2013/04/03/2998652.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动化编译之make]]></title>
    <link href="http://sbxfc.github.io/blog/2016/07/01/makefile/"/>
    <updated>2016-07-01T11:36:32+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/07/01/makefile</id>
    <content type="html"><![CDATA[<p><em>注1：本中使用的make为GNU Make</em></p>

<h1>源文件的编译</h1>

<p>通常,我们将源代码编译成可执行程序时,首先要将源代码文件编译成中间文件(Windows下为.obj文件,在Unix下为.o文件),这个过程称为编译（compile）。然后,将大量的中间文件合成最终执行文件的过程称为链接（link）。</p>

<p>其中,链接主要是链接函数和全局变量,链接器不关心函数所在的源文件,只关心函数的中间文件。有时候生成的中间目标文件太多,而链接时需要明显指出中间目标名,这对于编译很不方便。所以,我们要给中间文件打个包,在Windows下这种包叫“库文件”（Library File),也就是 .lib 文件,在UNIX下,是Archive File,也就是 .a 文件。</p>

<h1>Makefile的使用</h1>

<p>当编译一个大型项目时,往往需要许多次调用编译器,并根据依赖关系,逐步编译整个项目。而通过make工具来处理这些复杂的依赖关系时,我们不需要频繁输入 gcc 命令,而只需要执行一次make就可以完成整个编译过程。所有的依赖关系都被记录在Makefile文本中</p>

<pre><code>target ... : prerequisites ... 
    command 
    ... 
    ... 
</code></pre>

<p>上面是一个基本的Makefile结构,target 用来指定一个目标文件，可以是中间文件，也可以是执行文件。 prerequisites 就是,要生成那个target所依赖的文件或目标。command 也就是生成目标文件make需要执行的命令</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_01.png" alt="make.png" /></p>

<p>上面是一个简单的make示例,test.c程序输出hello world,这个makefile的工作流程如下:</p>

<p>1,当make命令执行时,程序会搜索当前目录下的makefile,Makefile或者GNUmakefile。</p>

<p>2,如果找到,它会找文件中的第一个目标文件(target),在上面的例子中,他会找helloworld这个目标文件,并把这个文件作为最终的目标文件。</p>

<p>3,如果helloworld不存在,或是edit所依赖的后面的.o文件比helloworld这个文件新,那么他就会执行后面的命令来生成这个文件。</p>

<p>4,如果helloworld所依赖的.o文件也存在,那么make会在当前文件夹中找目标.o文件的依赖性,如果找到则再根据那一个规则生成.o。(直到所有的依赖关系都找到,类似于堆栈的过程。)</p>

<p>5,当所有的中间文件.o都存在的时候,make就会执行终极任务,生成helloworld。</p>

<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。</p>

<h1>宏</h1>

<p>当我们往生成最终目标helloworld的依赖里添加了一个用于输出时间的工具类时,这时我们需要在依赖目标里,添加一个print_time.o,然后在command里添加print_time.o,由于我们的makefile并不复杂,所以在这两处修改并不麻烦。但是,如果makefile变得复杂,我们可能会漏掉一个需要加入的地方而导致编译失败。为了维护方便,这时,我们可以在makefile使用宏,类似于文本类型的变量。</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_02.png" alt="make.png" /></p>

<h1>make自动推导</h1>

<p>GNU Make可以说是体贴入微,有些command不需要我们写出,make可以自动推导出该命令,比如生成目标test.o时,可以省略为  <font color='#bd260d'>test.o:</font></p>

<p>只要make看见一个.o目标文件,它就会自动的把.c文件加到依赖关系中,如果make找到一个test.o,那么test.c,就会是test.o的依赖文件。并且 <font color='#bd260d'>gcc -c test.c -o test.o</font> 也会被推导出来</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_03.png" alt="make.png" /></p>

<p>如果觉得这样写看着不太舒服,也可以直接改为下面的终极格式:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/make_04.png" alt="make.png" /></p>

<h1>清理</h1>

<p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的功能,这不仅便于重编译,也很利于保持文件的清洁。</p>

<pre><code>clean :
-rm helloworld $(objects) 
</code></pre>

<h1>示例</h1>

<ul>
<li><a href="https://github.com/sbxfc/gnu-make">https://github.com/sbxfc/gnu-make</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IEEE 802.11 序列帧]]></title>
    <link href="http://sbxfc.github.io/blog/2016/06/23/wlan/"/>
    <updated>2016-06-23T15:27:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/06/23/wlan</id>
    <content type="html"><![CDATA[<p><img src="http://sbxfc.github.io/images/2016/6/ieee80211.png" alt="IEEE_802_11" /></p>

<p>在上面的示意图里,Preamble(序言)和PLCP header是物理层驱动的使用的一些信息,而我们获取的MAC层协议帧是MPDU部分,MPDU是Mac protocal data unit的简称,即IEEE 802.11在 MAC 层的数据单元。</p>

<p>MPDU分为三大类:管理帧、控制帧和数据帧。通过Frame Control里的Type值,我们可以判断当前数据帧是什么类型:</p>

<ul>
<li><p>管理帧(00) 这类数据帧主要用来进行身份验证,发送信号(Beacon)等。</p></li>
<li><p>控制帧(01) 发送RTS/CTS,ACK等一些查询和控制响应帧。</p></li>
<li><p>数据帧(10) 携带更高层的数据(如IP数据包，ISO7层协议)。</p></li>
</ul>


<p>在这三个大类下面,又会根据subtype的不同将数据帧分为不同的类型。</p>

<p>由于,每种数据帧对应的数据格式是不同的(<font color='#bd260d'><strong>除了Frame control部分以外</strong></font>),所以说如果我们解析某个数据帧格式,需要根据具体的类型来判断:</p>

<h1>管理帧(00)</h1>

<p>管理帧根据subtype的不同,又分为如下类型:</p>

<table>
<thead>
<tr>
<th> subtype  </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 </td>
<td> Association request (关联请求) </td>
</tr>
<tr>
<td>0001 </td>
<td> Association response (关联响应)  </td>
</tr>
<tr>
<td>0010 </td>
<td> Reassociation request（重关联请求）</td>
</tr>
<tr>
<td>0011 </td>
<td> Reassociation response（重关联响应）</td>
</tr>
<tr>
<td>1010 </td>
<td> Disassociation（解除关联）</td>
</tr>
<tr>
<td>0100 </td>
<td> Probe request（探测请求）</td>
</tr>
<tr>
<td>0101 </td>
<td> Probe response（探测响应）</td>
</tr>
<tr>
<td>1000 </td>
<td> Beacon（信标,由AP发出,告知BSS的存在）</td>
</tr>
<tr>
<td>1001 </td>
<td> ATIM（通知传输指示消息）</td>
</tr>
<tr>
<td>1011 </td>
<td> Authentication（身份验证）</td>
</tr>
<tr>
<td>1100 </td>
<td> Deauthentication（解除认证）</td>
</tr>
<tr>
<td>1101～1111</td>
<td>Reserved（保留，未使用）</td>
</tr>
</tbody>
</table>


<p>Beacon帧格式:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/ieee80211_beacon.jpeg" alt="IEEE_802_11" /></p>

<p>Probe Request帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/probe_request.jpg" alt="IEEE_802_11" /></p>

<p>Probe Response帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/probe_esponse.jpg" alt="IEEE_802_11" /></p>

<p>ATIM帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/atim.jpg" alt="IEEE_802_11" /></p>

<p>Disassociation与Deauthentication帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/dd.jpg" alt="IEEE_802_11" /></p>

<p>Association Request帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/association_request.jpg" alt="IEEE_802_11" /></p>

<p>Reassociation Request帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/reassociation_request.jpg" alt="IEEE_802_11" /></p>

<p>Authentication帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/authentication.jpg" alt="IEEE_802_11" /></p>

<h1>控制帧(01)</h1>

<table>
<thead>
<tr>
<th> Subtype值   </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1010 </td>
<td>Power Save- Poll（省电－轮询,由休眠的AP定时发送）</td>
</tr>
<tr>
<td>1011 </td>
<td>RTS（Request To Send,请求发送,预约信道,帧长20字节）</td>
</tr>
<tr>
<td>1100 </td>
<td>CTS（Clear To Send,清除发送,收到RTS后,如果同意预约,就通过CTS告知其他人在一定时间内暂停向自己发送数据,避免冲突,帧长14字节）</td>
</tr>
<tr>
<td>1101 </td>
<td>ACK（确认收到的数据帧,如果收到的数据帧校验出错，则不发送ACK，等待重传。）</td>
</tr>
<tr>
<td>1110 </td>
<td>CF-End（无竞争周期结束,让STA脱离协调模式，开始基于竞争模式。)</td>
</tr>
<tr>
<td>1111 </td>
<td>CF-End＋CF-ACK（无竞争周期结束+无竞争周期确认）</td>
</tr>
</tbody>
</table>


<p>RTS帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/rts.jpg" alt="IEEE_802_11" /></p>

<p>CTS帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/cts.jpg" alt="IEEE_802_11" /></p>

<p>ACK帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/ack.jpg" alt="IEEE_802_11" /></p>

<p>PS-Poll:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/pspoll.jpg" alt="IEEE_802_11" /></p>

<h1>数据帧(10)</h1>

<table>
<thead>
<tr>
<th> Subtype值   </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0000 </td>
<td> Data（传输数据）</td>
</tr>
<tr>
<td> 0001 </td>
<td> Data+CF-ACK</td>
</tr>
<tr>
<td> 0010 </td>
<td> Data+CF-Poll</td>
</tr>
<tr>
<td> 0011 </td>
<td> Data+CF-ACK+CF-Poll</td>
</tr>
<tr>
<td> 0100 </td>
<td> Null（无数据的空帧）</td>
</tr>
<tr>
<td> 0101 </td>
<td> CF-ACK（无竞争周期的确认,用于确认之前所收到的帧）</td>
</tr>
<tr>
<td> 0110 </td>
<td> CF-Poll（无竞争周期的轮询,用于通知已经没有数据要传输）</td>
</tr>
<tr>
<td> 0111 </td>
<td> Data+CF-ACK+CF-Poll</td>
</tr>
<tr>
<td> 1000 </td>
<td> Qos Data</td>
</tr>
<tr>
<td> 1001 </td>
<td> Qos Data + CF-ACK</td>
</tr>
<tr>
<td> 1010 </td>
<td> Qos Data + CF-Poll</td>
</tr>
<tr>
<td> 1011 </td>
<td> Qos Data + CF-ACK+ CF-Poll</td>
</tr>
<tr>
<td> 1100 </td>
<td> QoS Null（未传送数据）</td>
</tr>
<tr>
<td> 1101 </td>
<td> QoS CF-ACK（未传送数据）</td>
</tr>
<tr>
<td> 1110 </td>
<td> QoS CF-Poll（未传送数据）</td>
</tr>
<tr>
<td> 1111 </td>
<td> QoS CF-ACK+ CF-Poll（未传送数据）</td>
</tr>
</tbody>
</table>


<p>IBSS帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/ibss.jpg" alt="IEEE_802_11" /></p>

<p>由接入点发出的数据帧格式(From AP):</p>

<p><img src="http://sbxfc.github.io/images/2016/6/from_ap.jpg" alt="IEEE_802_11" /></p>

<p>发送至接入点的数据帧格式(To AP):</p>

<p><img src="http://sbxfc.github.io/images/2016/6/to_ap.jpg" alt="IEEE_802_11" /></p>

<p>WDS数据帧:</p>

<p><img src="http://sbxfc.github.io/images/2016/6/wds.jpg" alt="IEEE_802_11" /></p>

<h1>RadioTap</h1>

<p>当无线网络接口处于monitor模式时,内核会生成一个名为RadioTap的数据添加在IEEE802.11数据帧(MPDU)的前面,该Radiotap记录了热点的信息,如信号强度、MPDU帧信息等信息。意思就是在正常的IEEE802.11数据帧前面,内核又额外给你加了一块RadioTap类型的数据,这块数据记录了一些无线网的属性。</p>

<pre><code>---------------------
|--Header--|--Data--|
---------------------
</code></pre>

<p>RadioTap的结构包括Header和Data两部分,首先看一眼Header:</p>

<pre><code>struct ieee80211_radiotap_header {
    u_int8_t        it_version;     /* set to 0 */
    u_int8_t        it_pad;
    u_int16_t       it_len;         /* entire length */
    u_int32_t       it_present;     /* fields present */
} __attribute__((__packed__));
</code></pre>

<p>it_version 是一个8位的版本号,值始终为0,it_pad未使用,只作字段对齐用,it_len 是整个Radiotap的长度,如果你不关心Radiotap里具体包含哪些信息,可以通过这个值跳过解析Radiotap的解析。it_present 是Data数据的掩码,标识哪些数据出现在接下来的Data里。</p>

<p>在这里面,it_present是最有趣的一个值,它总共有32位,里面的每一位都代表一种数据有没有出现在接下来的Data里。什么意思呢,我们知道每一位的值无非就是0和1两个值,如果该位是1则表示该位代表的数据在RadioTap里的Data部分携带了,并且每一位对应什么值都可以在这里(<a href="http://www.radiotap.org/defined-fields">http://www.radiotap.org/defined-fields</a>)查到,例如是它的size多大或是它代表了啥含义。</p>

<p>it_present代表的数据出场顺序与这32个掩码的位置是依次相关的。也就是第一位携带的数据如果有,永远是靠在最前的,其他的依次排列。通常it_present的最后一位Ext为0,此时Data紧随it_present之后出现。如果Ext为1,表明开发者增加了it_present字段,每个增加的it_present大小都是标准的32位,直到最后一个Ext为0的it_present出现时,Data才会紧接着出现。除Ext之外Present中倒数第2、3位是设备厂商的保留位，不能作为Data掩码使用。</p>

<pre><code>.... .... .... .... .... .... .... ...1 = TSFT : True
.... .... .... .... .... .... .... ..1. = Flags: True
.... .... .... .... .... .... .... .1.. = Rate : True
.... .... .... .... .... .... .... 1... = Channel : True
.... .... .... .... .... .... ...0 .... = FHSS : False
.... .... .... .... .... .... ..1. .... = Antenna signal  : False
.... .... .... .... .... .... .0.. .... = Antenna noise : False 
.... .... .... .... .... .... 0... .... = Lock quality : False
.... .... .... .... .... ...0 .... .... = TX attenuation : False 
.... .... .... .... .... ..0. .... .... = dB TX attenuation : False 
.... .... .... .... .... .0.. .... .... = dBm TX power : False  
.... .... .... .... .... 1... .... .... = Antenna  : True
.... .... .... .... ...0 .... .... .... = dB antenna signal : False
.... .... .... .... ..0. .... .... .... = dB antenna noise : False
.... .... .... .... .1.. .... .... .... = RX flags : False
.... .... .... .... 0... .... .... .... = MCS : False
.... .... .... ...0 .... .... .... .... = A-MPDU status : False
.... .... .... ..0. .... .... .... .... = VHT : False
.... .... .... .0.. .... .... .... .... = ... 
0... .... .... .... .... .... .... .... = Ext:False
</code></pre>

<p>掩码对应信息:</p>

<table>
<thead>
<tr>
<th> 位置编码</th>
<th> 大小 </th>
<th>名称</th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0  </td>
<td>  8byte   </td>
<td> TSFT </td>
<td> 只对接收帧有效,表示MPDU第一个bit到达MAC时的时间,单位是微秒</td>
</tr>
<tr>
<td>1  </td>
<td>  1byte   </td>
<td> Flags</td>
<td> 发送或接收帧属性,包括一些有用信息,比如FCS是否符合 </td>
</tr>
<tr>
<td>2  </td>
<td>  1byte   </td>
<td> Rate </td>
<td> 传输或接收速率,单位500kbs</td>
</tr>
<tr>
<td>3  </td>
<td>  2byte   </td>
<td>  Channel </td>
<td> 发送接收信号的频率，单位是MHz</td>
</tr>
<tr>
<td>4  </td>
<td>  1byte   </td>
<td>  FHSS </td>
<td> 跳频技术，是无线通讯最常用的扩频方式之一</td>
</tr>
<tr>
<td>5  </td>
<td>  1byte   </td>
<td> Antenna signal </td>
<td> 天线的射频信号强度，单位是dBm</td>
</tr>
<tr>
<td>6  </td>
<td>  1byte   </td>
<td> Antenna noise  </td>
<td> 天线的射频噪声强度，单位是dBm；</td>
</tr>
<tr>
<td>7  </td>
<td>  2byte   </td>
<td> Lock quality </td>
<td> 信号质量</td>
</tr>
<tr>
<td>8  </td>
<td>  2byte   </td>
<td> TX attenuation </td>
<td> 与出厂标准最大功率相比的功率衰减，0为最大功率</td>
</tr>
<tr>
<td>9  </td>
<td>  2byte   </td>
<td> dB TX attenuation </td>
<td> 与出厂标准最大功率相比的功率衰减dB值，0为最大功率</td>
</tr>
<tr>
<td>10 </td>
<td>  1byte   </td>
<td> dBm TX power </td>
<td> 传输功率的dBm值，这是在天线端口测量的功率绝对值</td>
</tr>
<tr>
<td>11 </td>
<td>  1byte   </td>
<td> Antenna </td>
<td> 发送或接收该帧的天线索引编号（硬件编号从0开始）；</td>
</tr>
<tr>
<td>12 </td>
<td>  1byte   </td>
<td> dB antenna signal </td>
<td> 天线的射频信号的相对功率强度dB值；</td>
</tr>
<tr>
<td>13 </td>
<td>  1byte   </td>
<td> dB antenna noise </td>
<td> 天线的射频噪音的相对功率强度dB值；</td>
</tr>
</tbody>
</table>


<h1>示例</h1>

<ul>
<li><a href="https://github.com/sbxfc/wlan-macos">https://github.com/sbxfc/wlan-macos</a></li>
</ul>


<h1>参考</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/IEEE_802.11">https://zh.wikipedia.org/wiki/IEEE_802.11</a></li>
<li><a href="http://www.radiotap.org/">http://www.radiotap.org/</a></li>
<li><a href="http://www.radiotap.org/defined-fields">http://www.radiotap.org/defined-fields</a></li>
<li><a href="http://www.cnblogs.com/littlehann/p/3700357.html">http://www.cnblogs.com/littlehann/p/3700357.html</a></li>
<li><a href="http://rick_stone.leanote.com/post/802.11%E5%B8%A7%E8%A7%A3%E6%9E%90">http://rick_stone.leanote.com/post/802.11%E5%B8%A7%E8%A7%A3%E6%9E%90</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocos2d-JSB 内存管理]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/15/memory-of-jsb/"/>
    <updated>2016-01-15T14:42:31+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/15/memory-of-jsb</id>
    <content type="html"><![CDATA[<p>如果你写的Cocos2d-JS程序在iOS/Android原生环境里运行时出现 <font color='#bd260d'>Error : Invalid Native Object</font> ,那么你有可能遇到了JSB的内存问题。</p>

<p>我们知道,Cocos2d-JS在原生环境里运行时,实际上运行的是Cocos2dx引擎而非Cocos2d-HTML5。在程序执行时Javascript通过JSB调用Cocos2dx引擎的API,因为 Javascript 本身有一套垃圾回收机制,Cocos2dx也有一套,当这两者一起运行时,就会由于沟通问题出现一些差错。</p>

<p>Invalid Native Object 的错误原因是,JS端访问了一个已经释放了相应C++绘制对象的JS对象。官网列举了一个这样的示例。首先,在程序里创建了一个全局变量globalNode:</p>

<pre><code>var globalNode = new cc.Node();
...
onTouched:function(sender){
    sender.addChild(globalNode);
}
</code></pre>

<p>当程序运行时,globalNode没有通过 addChild 函数添加场景上,而是在按钮事件onTouched触发时才被添加到场景上。当按钮点击时出现下列错误:</p>

<blockquote><p><font color='#bd260d'><em>jsb: ERROR: File /Users/sbxfc/Documents/XXX/frameworks/cocos2d-x/cocos/scripting/js-bindings/
auto/jsb_cocos2dx_auto.cpp: Line: 1973, Function: js_cocos2dx_Node_addChild<br>
Invalid Native Object</em></font></p></blockquote>

<p>按照我们一贯的思路,可能察觉不出这个程序的问题。我们通过CCNode.js里一段注释作为引子来解析这段程序错误的原因:</p>

<blockquote><p>If you created an engine object and haven&rsquo;t added it into the scene graph during the same frame.JSB&rsquo;s native autorelease pool will consider this object a useless one and release it directly</p></blockquote>

<p>当程序当前帧绘制完成之后,那些没有被添加到场景上的绘制对象将被删除并进行垃圾回收,所以globalNode在C++端的对象会被移除,按正常逻辑globalNode也将被回收,但是由于globalNode是一个全局对象不能被回收,所以就出现了上述错误。</p>

<h1>cc.Node的生命周期</h1>

<p>为了更清除地了解整个过程,我们看一下Node对象被创建和释放的整个流程。首先,我们使用 cc.Node.create() 来创建对象时会执行以下操作:</p>

<p>首先,在游戏启动的时候(applicationDidFinishLaunching),游戏引擎会通过addRegisterCallback将JS代码往C++的映射:</p>

<pre><code>static JSFunctionSpec st_funcs[] = {
    JS_FN("create", js_cocos2dx_CCNode_create, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
    JS_FS_END
};

jsb_CCNode_prototype = JS_InitClass(
    cx, global,
    NULL, // parent proto
    jsb_CCNode_class,
    js_cocos2dx_CCNode_constructor, 0, // constructor
    properties,
    funcs,
    NULL, // no static properties
    st_funcs);
</code></pre>

<p>cc.Node.create() 会被隐射到 C函数 js_cocos2dx_CCNode_create()上,该函数的结构如下:</p>

<pre><code>JSBool js_cocos2dx_CCNode_create(JSContext *cx, uint32_t argc, jsval *vp)
{
    if (argc == 0) {
        cocos2d::CCNode* ret = cocos2d::CCNode::create();
        jsval jsret;
        do {
        if (ret) {
            js_proxy_t *proxy = js_get_or_create_proxy(cx, ret);
            jsret = OBJECT_TO_JSVAL(proxy-&gt;obj);
        } else {
            jsret = JSVAL_NULL;
        }
    } while (0);
        JS_SET_RVAL(cx, vp, jsret);
        return JS_TRUE;
    }
    JS_ReportError(cx, "wrong number of arguments");
    return JS_FALSE;
}
</code></pre>

<p>在该函数里,通过调用 js_cocos2dx_CCNode_create 来创建了一个js_proxy_t类型的对象 proxy,js_cocos2dx_CCNode_create 是通过下面的SpiderMonkey API 完成调用的:</p>

<pre><code>JS_AddObjectRoot(cx, &amp;proxy-&gt;obj);
</code></pre>

<p>JS_AddObjectRoot 将 JSObject 添加到垃圾回收中,proxy->obj将JSObject隐射到Javascript中,也就是说,最后proxy得到了JS端对象(cc.Node)的访问权限。</p>

<p>cc.Node.create()创建的对象最终在Cocos2dx端被保存到内存里,并且通过JS_RemoveObjectRoot来移除JS端对象的引用。</p>

<p>当cocos2d::CCNode对象被移除时,会在下一帧自动释放掉,接着CCObject的析构函数会被调用,代码如下:</p>

<pre><code>// if the object is referenced by Lua engine, remove it
if (m_nLuaID)
{
    CCScriptEngineManager::sharedManager()-&gt;getScriptEngine()-&gt;removeScriptObjectByCCObject(this);
}
else
{
    CCScriptEngineProtocol* pEngine = CCScriptEngineManager::sharedManager()-&gt;getScriptEngine();
    if (pEngine != NULL &amp;&amp; pEngine-&gt;getScriptType() == kScriptTypeJavascript)
    {
        pEngine-&gt;removeScriptObjectByCCObject(this);
    }
}
</code></pre>

<p>析构函数触发了pEngine->removeScriptObjectByCCObject,而该函数做了下面这些事情:</p>

<pre><code>void ScriptingCore::removeScriptObjectByCCObject(CCObject* pObj)
{
    js_proxy_t* nproxy;
    js_proxy_t* jsproxy;
    void *ptr = (void*)pObj;
    nproxy = jsb_get_native_proxy(ptr);
    if (nproxy) {
        JSContext *cx = ScriptingCore::getInstance()-&gt;getGlobalContext();
        jsproxy = jsb_get_js_proxy(nproxy-&gt;obj);
        JS_RemoveObjectRoot(cx, &amp;jsproxy-&gt;obj);
        jsb_remove_proxy(nproxy, jsproxy);
    }
}
</code></pre>

<p>其中,函数JS_RemoveObjectRoot被调用,JS端对象引用被移除,jsb_remove_proxy将会移除掉哈希表中的映射关系。至此,Cocos2d-x完成了整个对象的垃圾回收管理。</p>

<h1>retain()和release()</h1>

<p>在上面的问题里,cc.Node的引用对象是全局变量所以没有被释放掉,而其绘制对象cocos2d::CCNode却被垃圾回收了。</p>

<p>为了避免出现 Invalid Native Object 的情形,我们可以使用retain()函数来使Cocos2dx端的绘制对象增加引用计数,我们知道C++端是通过引用计算来控制内存管理的。当我们需要释放时,只需要手动调用release()即可。但是需要注意的是,retain和release是一一对应关系,retain之后必须要release一下,不然会造成内存泄露。</p>

<h1>其他</h1>

<p>除了全局变量以外,还有一些情形也会导致JS端的对象无法被释放掉。下面是另一个错误示例,首先,创建了一个node对象,node在当前帧没有被添加到场景里,而是在一秒钟(1000ms)后被添加到场景里:</p>

<pre><code>var self = this;
this.node = new cc.Node();
setTimeout(function(){
    self.node.setLocalZOrder(1);
},1000);
</code></pre>

<p>当改程序运行时,会出现 Invalid Native Object 错误:</p>

<p><font color='#bd260d'><em>File /Users/sbxfc/Documents/cocos/projects/demo/frameworks/cocos2d-x/cocos/scripting/js-bindings/auto/jsb_cocos2dx_auto.cpp: Line: 4186, Function: js_cocos2dx_Node_setLocalZOrder js_cocos2dx_Node_setLocalZOrder : Invalid Native Object</em></font></p>

<p>理解该示例错误的关键在于JS里的参数传递和闭包。setTimeout形成的闭包会在程序运行时异步执行,其中self.node通过匿名参数的形式传递到函数内部,而函数参数传递本身是一种值传递,其传递的是对象引用的副本。所以Cocos2dx无法释放setTimeout函数里的self.node,最终也会导致Invalid Native Object错误。</p>

<p>当然,上面的问题也可以使用retain、release对解决。CCNode.js里关于函数retain、release有详细的注释,开发者可以借此了解到有关释放问题和JSB机制不健全的说明,并以此理解引擎开发者的困扰。</p>

<h1>参见</h1>

<ul>
<li><a href="http://bosn.me/js/js-call-by-sharing/">JS是按值传递还是按引用传递?</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/1-about-cocos2d-js/1-1-a-brief-history/zh.md">Javascript Binding</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=wiki&amp;url=/doc/cocos-docs-master/manual/framework/native/wiki/memory-management-of-jsb/zh.md">JSB内存管理</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
