<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[sbxfc]]></title>
  <link href="http://sbxfc.github.io/atom.xml" rel="self"/>
  <link href="http://sbxfc.github.io/"/>
  <updated>2016-02-03T11:26:31+08:00</updated>
  <id>http://sbxfc.github.io/</id>
  <author>
    <name><![CDATA[sbxfc]]></name>
    <email><![CDATA[sbxfc17@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cocos2d-JSB 内存管理]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/15/memory-of-jsb/"/>
    <updated>2016-01-15T14:42:31+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/15/memory-of-jsb</id>
    <content type="html"><![CDATA[<h1>Error : Invalid Native Object</h1>

<p>如果你写的Cocos2d-JS程序在iOS/Android原生环境里运行时出现 <font color='#bd260d'>Error : Invalid Native Object</font> ,那么你有可能遇到了JSB的内存问题。</p>

<p>我们知道,Cocos2d-JS在原生环境里运行的实际上是Cocos2dx引擎而非Cocos2d-HTML5,Javascript程序通过JSB调用Cocos2dx引擎的API,由于 Javascript 本身有一套垃圾回收机制,Cocos2dx也有一套,当两者共同运行时,就会由于沟通问题出现一些差错。</p>

<p>Invalid Native Object 的错误原因是,JS端访问了一个已经释放了相应C++绘制对象的JS对象。</p>

<h1>全局变量不被回收</h1>

<p>官网列举了一个这样的示例。首先,在程序里创建了一个全局变量globalNode:</p>

<pre><code>var globalNode = new cc.Node();
</code></pre>

<p>当程序运行时,globalNode没有通过 addChild 添加到其他Node上,而是通过设置一个按钮的回调来将自己添加到节点上:</p>

<pre><code>onTouched:function(sender){
    sender.addChild(globalNode);
}
</code></pre>

<p>当按钮点击时,控制台会出现下列错误:</p>

<p><font color='#bd260d'><em>jsb: ERROR: File /Users/sbxfc/Documents/XXX/frameworks/cocos2d-x/cocos/scripting/js-bindings/
auto/jsb_cocos2dx_auto.cpp: Line: 1973, Function: js_cocos2dx_Node_addChild<br>
Invalid Native Object</em></font></p>

<p>按照我们一贯的思路,可能察觉不出这个程序的问题。我们通过CCNode.js里一段注释作为引子来解析这段程序错误的原因:</p>

<blockquote><p>If you created an engine object and haven&rsquo;t added it into the scene graph during the same frame.JSB&rsquo;s native autorelease pool will consider this object a useless one and release it directly</p></blockquote>

<p>当程序当前帧绘制完成之后,那些没有被添加到场景上的绘制对象将被删除并进行垃圾回收,所以globalNode在C++端的对象会被移除,按正常逻辑globalNode也将被回收,但是由于globalNode是一个全局对象不能被回收,所以就出现了上述错误。</p>

<h1>cc.Node的生命周期</h1>

<p>为了更清除地了解整个过程,我们看一下Node对象被创建和释放的整个流程。首先,我们使用 cc.Node.create() 来创建对象时会执行以下操作:</p>

<p>首先,在游戏启动的时候(applicationDidFinishLaunching),游戏引擎会通过addRegisterCallback将JS代码往C++的映射:</p>

<pre><code>static JSFunctionSpec st_funcs[] = {
    JS_FN("create", js_cocos2dx_CCNode_create, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
    JS_FS_END
};

jsb_CCNode_prototype = JS_InitClass(
    cx, global,
    NULL, // parent proto
    jsb_CCNode_class,
    js_cocos2dx_CCNode_constructor, 0, // constructor
    properties,
    funcs,
    NULL, // no static properties
    st_funcs);
</code></pre>

<p>cc.Node.create() 会被隐射到 C函数 js_cocos2dx_CCNode_create()上,该函数的结构如下:</p>

<pre><code>JSBool js_cocos2dx_CCNode_create(JSContext *cx, uint32_t argc, jsval *vp)
{
    if (argc == 0) {
        cocos2d::CCNode* ret = cocos2d::CCNode::create();
        jsval jsret;
        do {
        if (ret) {
            js_proxy_t *proxy = js_get_or_create_proxy(cx, ret);
            jsret = OBJECT_TO_JSVAL(proxy-&gt;obj);
        } else {
            jsret = JSVAL_NULL;
        }
    } while (0);
        JS_SET_RVAL(cx, vp, jsret);
        return JS_TRUE;
    }
    JS_ReportError(cx, "wrong number of arguments");
    return JS_FALSE;
}
</code></pre>

<p>在该函数里,通过调用 js_cocos2dx_CCNode_create 来创建了一个js_proxy_t类型的对象 proxy,js_cocos2dx_CCNode_create 是通过下面的SpiderMonkey API 完成调用的:</p>

<pre><code>JS_AddObjectRoot(cx, &amp;proxy-&gt;obj);
</code></pre>

<p>JS_AddObjectRoot 将 JSObject 添加到垃圾回收中,proxy->obj将JSObject隐射到Javascript中,也就是说,最后proxy得到了JS端对象(cc.Node)的访问权限。</p>

<p>cc.Node.create()创建的对象最终在Cocos2dx端被保存到内存里,并且通过JS_RemoveObjectRoot来移除JS端对象的引用。</p>

<p>当cocos2d::CCNode对象被移除时,会在下一帧自动释放掉,接着CCObject的析构函数会被调用,代码如下:</p>

<pre><code>// if the object is referenced by Lua engine, remove it
if (m_nLuaID)
{
    CCScriptEngineManager::sharedManager()-&gt;getScriptEngine()-&gt;removeScriptObjectByCCObject(this);
}
else
{
    CCScriptEngineProtocol* pEngine = CCScriptEngineManager::sharedManager()-&gt;getScriptEngine();
    if (pEngine != NULL &amp;&amp; pEngine-&gt;getScriptType() == kScriptTypeJavascript)
    {
        pEngine-&gt;removeScriptObjectByCCObject(this);
    }
}
</code></pre>

<p>析构函数触发了pEngine->removeScriptObjectByCCObject,而该函数做了下面这些事情:</p>

<pre><code>void ScriptingCore::removeScriptObjectByCCObject(CCObject* pObj)
{
    js_proxy_t* nproxy;
    js_proxy_t* jsproxy;
    void *ptr = (void*)pObj;
    nproxy = jsb_get_native_proxy(ptr);
    if (nproxy) {
        JSContext *cx = ScriptingCore::getInstance()-&gt;getGlobalContext();
        jsproxy = jsb_get_js_proxy(nproxy-&gt;obj);
        JS_RemoveObjectRoot(cx, &amp;jsproxy-&gt;obj);
        jsb_remove_proxy(nproxy, jsproxy);
    }
}
</code></pre>

<p>其中,函数JS_RemoveObjectRoot被调用,JS端对象引用被移除,jsb_remove_proxy将会移除掉哈希表中的映射关系。至此,Cocos2d-x完成了整个对象的垃圾回收管理。</p>

<h1>retain()和release()</h1>

<p>在上面的问题里,cc.Node的引用对象是全局变量所以没有被释放掉,而其绘制对象cocos2d::CCNode却被垃圾回收了。</p>

<p>为了避免出现 Invalid Native Object 的情形,我们可以使用retain()函数来使Cocos2dx端的绘制对象增加引用计数,我们知道C++端是通过引用计算来控制内存管理的。当我们需要释放时,只需要手动调用release()即可。但是需要注意的是,retain和release是一一对应关系,retain之后必须要release一下,不然会造成内存泄露。</p>

<h1>其他</h1>

<p>除了全局变量以外,还有一些情形也会导致JS端的对象无法被释放掉。下面是另一个错误示例,首先,创建了一个node对象,node在当前帧没有被添加到场景里,而是在一秒钟(1000ms)后被添加到场景里:</p>

<pre><code>var self = this;
this.node = new cc.Node();
setTimeout(function(){
    self.node.setLocalZOrder(1);
},1000);
</code></pre>

<p>当改程序运行时,会出现 Invalid Native Object 错误:</p>

<p><font color='#bd260d'><em>File /Users/sbxfc/Documents/cocos/projects/demo/frameworks/cocos2d-x/cocos/scripting/js-bindings/auto/jsb_cocos2dx_auto.cpp: Line: 4186, Function: js_cocos2dx_Node_setLocalZOrder js_cocos2dx_Node_setLocalZOrder : Invalid Native Object</em></font></p>

<p>理解该示例错误的关键在于JS里的参数传递和闭包。setTimeout形成的闭包会在程序运行时异步执行,其中self.node通过匿名参数的形式传递到函数内部,而函数参数传递本身是一种值传递,其传递的是对象引用的副本。所以Cocos2dx无法释放setTimeout函数里的self.node,最终也会导致Invalid Native Object错误。</p>

<p>当然,上面的问题也可以使用retain、release对解决。CCNode.js里关于函数retain、release有详细的注释,开发者可以借此了解到有关释放问题和JSB机制不健全的说明,并以此理解引擎开发者的困扰。</p>

<h1>参见</h1>

<ul>
<li><a href="http://bosn.me/js/js-call-by-sharing/">JS是按值传递还是按引用传递?</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/1-about-cocos2d-js/1-1-a-brief-history/zh.md">Javascript Binding</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=wiki&amp;url=/doc/cocos-docs-master/manual/framework/native/wiki/memory-management-of-jsb/zh.md">JSB内存管理</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POSIX - select]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/11/unix-select/"/>
    <updated>2016-01-11T11:01:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/11/unix-select</id>
    <content type="html"><![CDATA[<h1>I/O 复用 和 select函数</h1>

<p>在《UNIX网络编程》里描述了这样一个例子,当客户端通过TCP协议正常连接服务端之后,紧接着,客户端进入标准输入的阻塞状态。此时,服务器突然重启,因为正处于输入状态所以客户端无法通过read函数读取对端返回EOF状态,直到输入结束,客户端恢复read为止(可能已久过去了许多时间)。</p>

<p>这种情况不是我们预期的结果。我们想让程序有一种预先设置内核通知的能力,当内核一旦发现进程指定的一个或多个I/O条件已就绪(比如输入完成,或可以进行读取数据时),它就告知进程。这个能力称为I/O复用,是由select和poll函数支持的,还有前者较新的POSIX变种pselect。</p>

<p><img src="http://sbxfc.github.io/images/2016/1/io_multiplexing.png" alt="IO multiplexing" /></p>

<p>上图显示了IO复用的一般流程,首先,在图示集流阀(select)的位置,我们设置了许多需要监听的事件,然后select进入睡眠状态,当这些事件的其中一个或多个事件条件满足时,唤醒select函数,接着来执行相应的操作。</p>

<p>关于IO复用有一个很形象比喻:</p>

<p><a href="http://www.zhihu.com/question/32163005/answer/55687802">一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，可以干点别的玩玩手机。至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间玩手机了。io多路复用大概就是指这几个醉汉共用一个服务员。</a></p>

<h1>select函数</h1>

<p>select函数允许程序指示内核等待多个事件的任何一个发生,并且在一个或多个事件发生时,或是经历一段指定的时间后才唤醒它。</p>

<pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;

struct timeval{
    long tv_sec;/*秒*/
    long tv_usec;/*毫秒*/
};

int select(int maxfd, fd_set* readfds, fd_set* writefds, fd_set* errorfds, struct timeval* timeout);
</code></pre>

<p>一),首先从最后一个参数说起。timeout告知内核等待指定描述符中的任何一个就绪所花费时间。该参数会有以下三种情况:</p>

<ol>
<li>永远等待下去 : 仅在有一个描述符准备好时I/O才返回。为此,我们把该参数设置为空指针(NULL)。</li>
<li>等待一段固定时间 : 在有一个描述符准备好I/O时返回,但等待时间不超过由timeval结构中指定的时间。</li>
<li>根本不等待 : 检查描述符后立刻返回,这称为轮询(polling)。为此,该参数必须指向一个timeval结构,而且其中的定时器值必须为0。</li>
</ol>


<p>二),中间的三个参数readfds,writefds,errorfds用于指定我们让内核试读、写和异常条件的描述符集合。目前支持的异常条件只有两个:</p>

<ol>
<li>某个套接字的<strong>带外数据</strong>的到达。</li>
<li>某个已置为分组模式的伪终端存在可从其他端读取的控制状态信息。</li>
</ol>


<p>如果该三个参数都为NULL,那么我们就有了一个比Unix的sleep更精确的定时器(sleep以秒为最小单位)。</p>

<p>三),maxfd 参数指定待测试的描述符个数,它的值是待测试的最大描述符加1,描述符0,1,2&hellip;maxfd-1将都被测试。</p>

<h1>示例代码</h1>

<p><a href="https://github.com/sbxfc/POSIX-select">https://github.com/sbxfc/POSIX-select</a></p>

<h1>运行</h1>

<p>1,客户端</p>

<pre><code>//Mac终端 
$ gcc client_select.c -o client
$ ./client
$ hi //客户端输入
$ input is readable //输出~~
$ socket is readable //输出~~
$ hi //回射服务器返回
</code></pre>

<p>2,服务端(回射服务器)</p>

<pre><code>$ gcc server_select.c
$ ./a.out 
</code></pre>

<h1>参见</h1>

<hr />

<ul>
<li>&lt;UNIX网络编程></li>
<li><a href="https://zh.wikipedia.org/zh/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">https://zh.wikipedia.org/zh/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Select_(Unix)">https://zh.wikipedia.org/wiki/Select_(Unix)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POSIX - signal]]></title>
    <link href="http://sbxfc.github.io/blog/2016/01/04/unix-signal/"/>
    <updated>2016-01-04T14:24:14+08:00</updated>
    <id>http://sbxfc.github.io/blog/2016/01/04/unix-signal</id>
    <content type="html"><![CDATA[<h1>信号产生</h1>

<p>1,通过 raise 发送信号给当前进程。</p>

<pre><code>#include &lt;signal.h&gt; 

/**
 * 成功返回0,否则返回 -1
 * @param signo 信号类型
 */
int raise(int signo) 
</code></pre>

<p>2,在权限允许的情况下通过 kill 发送信号给指定进程。</p>

<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt; 

/**
 * @param pid 进程ID,
 * 当pid &gt; 0时,信号发送至ID为pid的进程,
 * 当pid = 0时,信号发送至同一进程组的进程,
 * 当pid &lt; 0&amp;&amp;pid != -1时,信号发送至进程组ID为(-1*pid)的所有进程
 * 当pid = -1时,信号发送至除自身进程以外的所有ID大于1的进程
 * 
 * @param signo 信号类型
 * 当 signo = 0 时,实际不发送任何信号,但照常进行错误检查,
 * 因此,可用于检查目标进程是否存在,以及当前进程是否具有向目标发送信号的权限
 * (root权限的进程可以向任何进程发送信号，非root权限的进程
 * 只能向属于同一个session或者同一个用户的进程发送信号)
 */
int kill(pid_t pid,int signo)
</code></pre>

<p>3,sigqueue(Linux) 相比于kill,sigqueue传递了更多的附加信息,但只能向一个进程发送信号。成功返回0,否则返回 -1。</p>

<p>在调用sigqueue时,sigval_t指定的信息会拷贝到3参数信号处理函数（3参数信号处理函数指的是信号处理函数由sigaction安装,并设定了sa_sigaction
指针）的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。
sigqueue系统调用支持发送带参数信号,所以比kill()系统调用的功能要灵活和强大得多。(Note:sigqueue是Linux系统下信号发送函数,我的Mac机没有所以只摘抄了一些介绍。)</p>

<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt; 

typedef union sigval {
    int  sival_int;
    void *sival_ptr;
}sigval_t;

/**
 * @param pid 进程ID
 * @param signo 信号值 sigqueue 不能发送信号给一个进程组,如果 signo = 0,将会执行错误检,
 * 但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号
 */
int sigqueue(pid_t pid, int signo, const union sigval val) 
</code></pre>

<p>4,alarm 在指定的时间seconds秒后,将向进程本身发送SIGALRM信号，又称为闹钟时间。进程调用alarm后,任何以前的alarm()调用都将无效。如果参数seconds为零,那么进程内将不再包含任何闹钟时间。返回值,如果调用alarm()前,进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间,否则返回0。</p>

<pre><code>#include &lt;unistd.h&gt; 
unsigned int alarm(unsigned int seconds); 
</code></pre>

<p>5,setitimer setitimer比alarm功能强大,setitimer调用成功返回0,否则返回-1。支持3种类型的定时器:</p>

<ul>
<li>ITIMER_REAL:设定绝对时间;经过指定的时间后，内核将发送SIGALRM信号给本进程;</li>
<li>ITIMER_VIRTUAL 设定程序执行时间;经过指定的时间后,内核将发送SIGVTALRM信号给本进程；</li>
<li>ITIMER_PROF 设定进程执行以及内核因本进程而消耗的时间和,经过指定的时间后,内核将发送ITIMER_VIRTUAL信号给本进程;</li>
</ul>


<!--more-->


<pre><code>#include &lt;sys/time.h&gt;
/**
* @param which 定时器类型
* @param value 
*/
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));
</code></pre>

<p>6,abort 向进程发送SIGABRT信号,默认情况下进程会异常退出,当然可定义自己的信号处理函数。即使SIGABRT被进程设置为阻塞信号,调用abort()后，SIGABRT仍然能被进程接收。该函数无返回值。</p>

<pre><code>#include &lt;stdlib.h&gt;
void abort(void);
</code></pre>

<h1>安装信号(信号监听)</h1>

<p>如果进程想要处理某一信号,就需要在进程里安装该信号。</p>

<p>1,signal</p>

<pre><code>#include &lt;signal.h&gt; 

/**
* 第一个参数信号值。
* 第二个参数是信号值的处理。第二个参数如果设为 SIG_IGN 表示可忽略该信号,
* 如果设为 SIG_DFL 表示采用系统的默认处理方式,也可以指定一个处理函数。
*/
void (*signal(int, void (*)(int)))(int);
</code></pre>

<p>2,sigaction</p>

<pre><code>#include &lt;signal.h&gt; 

/**
 * @param union 联合数据结构中的两个元素_sa_handler以及*_sa_sigaction指定信号关联函数,
 * 即用户指定的信号处理函数。除了可以是用户自定义的处理函数外,还可以为SIG_DFL(采用缺省的处理方式),
 * 也可以为SIG_IGN（忽略信号）
 * @param sa_restorer,已过时,POSIX不支持它,不应再被使用。
 */
struct sigaction {
    union{
        __sighandler_t _sa_handler;
        void (*_sa_sigaction)(int,struct siginfo *, void *)；
    }_u
    sigset_t sa_mask；
    unsigned long sa_flags； 
    void (*sa_restorer)(void)；
}

/**
* @param signum 信号值,可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号。
* @param act 指向结构sigaction的一个实例的指针,在结构sigaction的实例中,
* 指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理。
* @param oldact oldact指向的对象用来保存原来对相应信号的处理,可指定oldact为NULL。
* 如果把第二、第三个参数都设为NULL,那么该函数可用于检查信号的有效性。
*/
int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));
</code></pre>

<h1>阻塞信号/恢复信号</h1>

<p>有时候我们不希望信号立刻执行,同时也不想信号被忽略掉(SIG_IGN)。这时,我们可以设置阻塞信号,并在信号恢复后接收阻塞的信号。</p>

<p>如果信号在被阻塞期间产生了一次或多次,那么该信号被解除阻塞之后通常只提交一次,也就是说Unix信号默认是不排队的。</p>

<pre><code>#include &lt;signal.h&gt;

/**
 * @func 1
 * @param how 选择阻塞方式,how有以下三种值:
 * SIG_BLOCK 添加set阻塞信号集合,第二个参数为本次设置之前的阻塞信号集合
 * SIG_UNBLOCK 如果当前进程阻塞集中包含set阻塞信号集合,则解除该阻塞信号集合
 * SIG_SETMASK 设置当前阻塞集为set指定的集合,第二个参数NULL
 */
int sigprocmask(int how,  const  sigset_t *set, sigset_t *oldset))；

/**
 * 获取当前已递送到进程,却被阻塞的所有信号,
 * 从set指向的信号集中获取返回结果。
 */
int sigpending(sigset_t *set));

/**
 * @func 2
 * 获取当前已递送到进程,却被阻塞的所有信号,
 * 从set指向的信号集中获取返回结果。
 */
int sigsuspend(const sigset_t *mask));

/**
 * @func 3
 * 用于在接收到某个信号之前, 临时用mask替换进程的信号掩码, 并暂停进程执行，直到收到信号为止。
 * 也就是说,进程执行到sigsuspend时,sigsuspend并不会立刻返回,进程处于TASK_INTERRUPTIBLE状态
 * 并立刻放弃CPU,等待UNBLOCK（mask之外的）信号的唤醒。进程在接收到UNBLOCK（mask之外）信号后,
 * 调用处理函数，然后把现在的信号集还原为原来的,sigsuspend返回,进程恢复执行。
 * 该系统调用始终返回-1，并将errno设置为EINTR。
 */
sigsuspend(const sigset_t *mask));
</code></pre>

<h1>完整示例</h1>

<ul>
<li><a href="https://github.com/sbxfc/signal">https://github.com/sbxfc/signal</a></li>
</ul>


<h1>参见</h1>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7">Unix信号</a></li>
<li><a href="http://en.cppreference.com/w/c/program/raise">http://en.cppreference.com/w/c/program/raise</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html">http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Kill_(%E5%91%BD%E4%BB%A4)">https://zh.wikipedia.org/wiki/Kill_(%E5%91%BD%E4%BB%A4)</a></li>
<li>&lt;kernal/signal.c></li>
<li><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/sigqueue.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/sigqueue.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html">http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html">http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Xcode里使用libevent库]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/30/libevent/"/>
    <updated>2015-12-30T17:43:19+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/30/libevent</id>
    <content type="html"><![CDATA[<h1>编译</h1>

<p>从官网下载最新的release包<a href="http://libevent.org/">libevent-2.0.22-stable.tar.gz</a></p>

<p>解压并进入相应目录后,执行下列编译代码:</p>

<pre><code>./configure &amp;&amp; make  
sudo make install
</code></pre>

<p>完成编译后按Command+Shilt+G进入 /usr/local/lib 文件夹就可以看到生成的文件目录 libevent-2.0.22</p>

<h1>使用示例</h1>

<p>新建一个Command Line Tool 的c++项目,首先在Build Phases->Link Binary With Libraries里添加三个.a库文件 libevent_core.a、libevent_extra.a、libevent_phreads.a(这几个库文件的选择视情况而定)。</p>

<p>检查Building Setting里的Library Search Paths是否已添加了libevent库文件目录,如果没有则添加(以下是我本机路径):</p>

<pre><code>/usr/local/libevent-2.0.22/lib //库文件目录
</code></pre>

<p>在Header Search Paths里将头文件的目录添加进去(以下是我本机路径):</p>

<pre><code>/usr/local/libevent-2.0.22/include //头文件的目录
</code></pre>

<p>在main.cpp添加简单定时器代码:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

// libevent头文件
#include &lt;event.h&gt;
using namespace std;

struct event evt;
struct timeval tv;

// 定时事件回调函数
void time_cb(int sock, short event, void *arg)
{
    printf("timer wakeup\n");
    //重新添加定时事件（定时事件触发后默认自动删除）
    event_add((struct event*)arg, &amp;tv);
}

int main()
{
    //初始化
    struct event_base *base = event_init();

    tv.tv_sec = 1; //1s period
    tv.tv_usec = 0;

    //设置定时事件
    evtimer_set(&amp;evt,time_cb, &amp;evt);

    // 添加定时事件
    event_add(&amp;evt, &amp;tv);

    //事件循环
    event_base_dispatch(base);

    return 0;
}
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="http://libevent.org/">http://libevent.org/</a></li>
<li>libevent源码深度剖析.pdf</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - 纹理的选择 ]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/04/cocos2d-texture/"/>
    <updated>2015-12-04T12:15:05+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/04/cocos2d-texture</id>
    <content type="html"><![CDATA[<p>普通的2D纹理就是一张图片,在cocos2d里,纹理的使用主要分为两步:</p>

<ul>
<li>一,从本地加载纹理图片,并将纹理数据读取到内存。</li>
<li>二,将内存里的纹理数据以copy的形式上传到GPU内存。</li>
</ul>


<p><font color='#bd260d'><strong>前者主要涉及到的问题是图片尺寸以及加载后的内存占用。</strong></font>例如,我们要从本地加载了一张1024*1024的png图片(假设是RGBA8888格式),其大小约为1024*1024*4 = 4MB。这意味着,如果这张图片打包进安装包就会使整个程序增加4MB,如果在运行时加载到游戏里就相当于多了至少4MB内存。</p>

<p>对于一个有责任心(小肚鸡肠)的开发者来说,程序无缘无故增加了4MB内存,无疑是令人耿耿于怀的。能不能把尺寸或者运行时内存减少一点呢?答案是可以的。</p>

<p>要解决纹理的内存问题,首先,我们应当了解一下纹理图片为何会占了这么多内存。对于,我们常见的图片,无论是png还是jpg图片,他们都是非压缩纹理。非压缩纹理的意思是,这些图片的RGBA四个通道的像素数据在文件里都是按照一定顺序规则排列的。类似于RGBA,RGBA,&hellip;.,RGBA这样的排列,不同的非压缩格式图片的区别在于,有一些只使用了rgb三个通道值,有一些使用的通道精度是小于2<sup>8</sup>。</p>

<p>cocos2d支持十余种格式的非压缩纹理,上面提到的RGBA8888就是其中一种,也是最常见的一种(一般来说,没有特殊设置图片的像素格式就是RGBA8888)。并且图片的扩展名和它的像素格式没什么直接关系,一个png图片其像素格式可能是RGBA8888、RGBA4444也或者是其他格式。</p>

<p>说到这里,那么RGBA8888纹理有什么特别的地方呢？首先,该纹理格式上的每个像素点包括了R、G、B以及Alpha四个通道值,并且每个通道值是精度2<sup>8</sup>,图片数据是以二进制存储的,我们知道2<sup>8</sup>的bit值等于1byte,所以RGBA8888格式的纹理每个像素通道大小是1byte,所以该格式的纹理每个像素大小就是4*1byte = 4byte。</p>

<p>以此推之,RGBA4444像素格式就是通道精度为 2<sup>4</sup>,包含RGBA四个通道的纹理。其大小为4*0.5byte = 2byte。由此可见,RGBA4444纹理的大小是RGBA8888的一半。也就是说,如果我们有张RGBA8888的纹理图片,如果能把它转化为RGBA4444,其尺寸立刻就减小了二分之一。多么诱人,但是我们也注意到RGBA4444相较于RGBA8888,其精度只有2<sup>4</sup>=16。这种精度的损失对一些颜色渐变的纹理来说,影响比较明显。但是无论精度区间是[0,16]还是[0,256],这些像素都会被映射到OpenGL支持的[0,1]这个颜色区间。</p>

<p>所以,我们应当根据实际情况选取合适的像素格式来减少图片尺寸和运行时的内存。<font color='#bd260d'><strong>通常来说,对于非压缩纹理 rgb565 和 rgba5551(RGB5A1) 的效果和内存占用相对会好一些。</strong></font></p>

<p>cocos2d支持的非压缩纹理像素格式:</p>

<pre><code>    enum class PixelFormat
    {
        //! auto detect the type
        AUTO,
        //! 32-bit texture: BGRA8888
        BGRA8888,
        //! 32-bit texture: RGBA8888
        RGBA8888,
        //! 24-bit texture: RGBA888
        RGB888,
        //! 16-bit texture without Alpha channel
        RGB565,
        //! 8-bit textures used as masks
        A8,
        //! 8-bit intensity texture
        I8,
        //! 16-bit textures used as masks
        AI88,
        //! 16-bit textures: RGBA4444
        RGBA4444,
        //! 16-bit textures: RGB5A1
        RGB5A1,

        //省略了压缩纹理
        //...
     }
</code></pre>

<h1>加载时的设置</h1>

<p><font color='#bd260d'><strong>不同的非压缩纹理时,在加载时需要注意格式问题。</strong></font></p>

<p>cocos2d对纹理的默认处理方式是PixelFormat::NONE,这个设置在游戏运行时会被转化为默认值为&#8221;RGBA8888&#8221;。但是,如果要加载的纹理图片的格式RGBA4444,这时引擎就会通过转换函数将RGBA4444转为RGBA8888。</p>

<p>这种转换不是我们想要的,我们想直接加载并绘制RGBA4444这种格式的纹理图片。因为RGBA4444是OpenGL可以直接读取并渲染的格式,我们不需要再将其转化为其他格式。(转换不但会耗费一定的CPU,也会增加运行时内存(rgba4444->rgba888内存增加一倍))</p>

<p>所以,在加载时如果遇到非RGBA8888的情况,需要进行代码声明:</p>

<pre><code>//在这里,我们高呼,我们加载的格式是RGBA5551,不用帮我们转换
[Texture2D setDefaultAlphaPixelFormat:kTexture2DPixelFormat_RGB5A1];
Sprite *s1 = [Sprite spriteWithFile:@"rgba5551.png"];
[self addChild:s1];

//在RGBA5551加载完后,我们告诉引擎你可以去按照你默认的格式(RGBA8888)去处理其他纹理了
[Texture2D setDefaultAlphaPixelFormat:kTexture2DPixelFormat_RGBA8888];
Sprite *s2 = [Sprite spriteWithFile:@"rgba8888.png"];
[self addChild:s2];
</code></pre>

<p>需要注意的是,在Sprite里,除了initWithTexture以外,其他全部创建方法会将纹理自动加载到内存并向GPU内存上传纹理数据。所以,实际开发中如果图像资源中同时包含多种纹理格式,一定要小心处理。</p>

<p>OpenGL通过glTexImage2D上传非压缩纹理,虽然GPU拥有高效的图像处理速度,但是从本地内存向显卡内存传递图片数据仍然是CPU和GPU共同处理的过程,资源的绘制效率也会受资源数据的大小限制(传输中的宽带问题,数据越大传输时间越长),所以预先上传纹理数据会对纹理的绘制效率有很大的提高,可以参见Texture2DCache对纹理缓存的管理。</p>

<p>下面的代码是Cocos里向 GPU 内存上传非压缩纹理数据的源码:</p>

<pre><code>glTexImage2D(GL_TEXTURE_2D, i, info.internalFormat, 
             (GLsizei)width, (GLsizei)height, 0, info.format, info.type, data);
</code></pre>

<p>其中,第三个参数的可选值为:</p>

<pre><code>GL_RGB,GL_RGBA,GL_ALPHA,GL_LUMINANCE,GL_LUMINANCE_ALPHA 
</code></pre>

<p>倒数第二个参数的格式可选值为:</p>

<pre><code>GL_UNSIGNED_BYTE,GL_UNSIGNED_SHORT_5_6_5,GL_UNSIGNED_SHORT_4_4_4_4,GL_UNSIGNED_SHORT_5_5_5_1
</code></pre>

<p>是不是有点熟悉,这两个参数的组合其实就是我们上面提到的某一个像素格式,比如RGBA4444对应的就是GL_RGBA和GL_UNSIGNED_SHORT_4_4_4_4。</p>

<h1>压缩纹理</h1>

<p>除了非压缩纹理外,cocos2d也支持压缩纹理,压缩纹理是通过一些优化算法将像素数据进行压缩,这些压缩纹理可以在相应的GPU直接解析(比如PVR格式的文件就可以直接 PowerVR图形芯片 解析)。</p>

<p>在OpenGL里,压缩纹理通过 glCompressedTexImage2D 接口将纹理数据从本地上传到GPU内存:</p>

<pre><code>glCompressedTexImage2D(GL_TEXTURE_2D,   i,  info.internalFormat,
                       (GLsizei)width,  (GLsizei)height,    0,  datalen, data);
</code></pre>

<p>Cocos里支持的压缩纹理格式:</p>

<pre><code>enum class PixelFormat
{
    ...

    //! 4-bit PVRTC-compressed texture: PVRTC4
    PVRTC4,
    //! 4-bit PVRTC-compressed texture: PVRTC4 (has alpha channel)
    PVRTC4A,
    //! 2-bit PVRTC-compressed texture: PVRTC2
    PVRTC2,
    //! 2-bit PVRTC-compressed texture: PVRTC2 (has alpha channel)
    PVRTC2A,
    //! ETC-compressed texture: ETC
    ETC,
    //! S3TC-compressed texture: S3TC_Dxt1
    S3TC_DXT1,
    //! S3TC-compressed texture: S3TC_Dxt3
    S3TC_DXT3,
    //! S3TC-compressed texture: S3TC_Dxt5
    S3TC_DXT5,
    //! ATITC-compressed texture: ATC_RGB
    ATC_RGB,
    //! ATITC-compressed texture: ATC_EXPLICIT_ALPHA
    ATC_EXPLICIT_ALPHA,
    //! ATITC-compresed texture: ATC_INTERPOLATED_ALPHA
    ATC_INTERPOLATED_ALPHA,
    //! Default texture format: AUTO
    DEFAULT = AUTO,

    NONE = -1
};
</code></pre>

<h1>纹理选择</h1>

<ul>
<li><p><font color='#bd260d'><strong>在 iOS 设备上最好使用PVR格式的压缩格式</strong></font>,因为iOS设备采用的是 PowerVR 图形芯片,PVR格式图片在PowerVR图形芯片中效率极高，占用显存也小。<a href="http://blog.chukong-inc.com/index.php/2013/02/04/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96cocos2d-x%E6%B8%B8%E6%88%8F%E7%9A%84%E5%86%85%E5%AD%98/">其中PVRTC4格式的PVR有损压缩包pvr.ccz,尺寸是原来的1/8</a></p></li>
<li><p><font color='#bd260d'><strong>在 Android 设备上使用双层 ETC1 的压缩纹理</strong></font>(极少数的GPU对ETC格式支持有问题。)。</p></li>
</ul>


<h1>TexturePacker</h1>

<p>TexturePacker是一款很出众的纹理压缩工具,上述的纹理格式都可以通过TexturePacker工具导出,下图是以导出一个PVRTC4格式的pvr.ccz文件的截图:</p>

<p><img src="http://sbxfc.github.io/images/2015/12/texture_packer.png" alt="" /></p>

<h1>参见</h1>

<ul>
<li><a href="http://blog.chukong-inc.com/index.php/2013/02/04/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96cocos2d-x%E6%B8%B8%E6%88%8F%E7%9A%84%E5%86%85%E5%AD%98/">如何优化Cocos2d-X游戏的内存</a></li>
<li><a href="http://blog.csdn.net/kaitiren/article/details/8054856">pvr与png的内存占用</a></li>
<li><a href="http://pngmini.com/">ImageAlpha Mac</a></li>
<li><a href="https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml">https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml</a></li>
<li><a href="http://www.learn-cocos2d.com/2011/11/depth-ios-cocos2d-performance-analysis-test-project/#image-formats">http://www.learn-cocos2d.com/2011/11/depth-ios-cocos2d-performance-analysis-test-project/#image-formats</a></li>
<li><a href="http://matrixcn.tumblr.com/post/75239316805/%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2png%E5%9B%BE%E7%89%87%E5%88%B0rgba4444">http://matrixcn.tumblr.com/post/75239316805/%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2png%E5%9B%BE%E7%89%87%E5%88%B0rgba4444</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript - 基于Prototype的对象结构]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/03/js-prototype/"/>
    <updated>2015-12-03T18:11:18+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/03/js-prototype</id>
    <content type="html"><![CDATA[<p>Javascript是基于Prototype的编程语言,而非我们熟悉的基于Class的编程语言。</p>

<p>在Javascript里,当我们new一个对象实例时,该对象的Prototype属性会被实例继承,但是Prototype和实例之间是引用关系。</p>

<p>当我们为实例对象的一个属性赋值时实际上并不是对Prototype里的属性进行修改,而是在实例上设置一个新属性。当程序访问该实例上的属性时,编译器会首先搜索实例自身的属性(即新添加的属性),如果没找到才会去搜索其继承的Prototype上的值:</p>

<pre><code>function Person{}
Person.prototype.name = "sbxfc";

var p = new Person();
//p身上没有name属性,转而去Person身上找
console.log(p.name);

//该name属性非Person上的name属性
p.name = "ss";
console.log(p.name);
</code></pre>

<h1>参见:</h1>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/09/19/javascriptYouMustKnowPrototype.html">http://www.cnblogs.com/mindsbook/archive/2009/09/19/javascriptYouMustKnowPrototype.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - scheduler(调度器)]]></title>
    <link href="http://sbxfc.github.io/blog/2015/12/01/cocos-scheduler/"/>
    <updated>2015-12-01T12:12:18+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/12/01/cocos-scheduler</id>
    <content type="html"><![CDATA[<p>在cocos2d里,场景的每帧刷新是由一个与屏幕帧频相等的定时器来驱动绘制的,在iOS环境里,这个定时器是CADisplayLink</p>

<p>每当屏幕上一帧刷新结束时,主线程里维持程序生命周期的NSRunLoop就会向CADisplayLink发送通知。接着,CADisplayLink会触发一个名为doCaller的回调函数,在该回调函数里cocos2d引擎进行了一系列的帧刷新操作。</p>

<p>在这个过程里,除了执行基本的场景刷新以外,cocos2d还定义了一个名为scheduler(调度器)的定时器,让开发者可以参与管理与每帧刷新息息相关的操作</p>

<pre><code>//在Cocos引擎里,当Director初始化时会启动该CADisplayLink定时器
//doCaller函数会执行每帧的刷新操作
-(void) startMainLoop
{
    // Director::setAnimationInterval() is called, we should invalidate it first
    [self stopMainLoop];

    displayLink = [NSClassFromString(@"CADisplayLink") 
                    displayLinkWithTarget:self selector:@selector(doCaller:)];
    [displayLink setFrameInterval: self.interval];
    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
}
</code></pre>

<p><font color='#bd260d'><strong>scheduler的回调函数优先于场景刷新函数被执行,这意味着,如果我们在scheduler回调函数里做一些UI刷新操作,这些操作会在下一帧被及时更新。</strong></font></p>

<pre><code>_scheduler-&gt;update(_deltaTime);   //调用scheduler
...
_runningScene-&gt;render(_renderer);//渲染场景
</code></pre>

<h1>基本用法</h1>

<p>任何Node对象以Node的子类都可以直接调用scheduleUpdate方法,然后通过重载update函数来执行回调操作:</p>

<pre><code>this-&gt;scheduleUpdate();

//*.h
void update(float dt) override;
//*.cpp
void HelloWorld::update(float delta){
    //Do something!
}
</code></pre>

<h1>自定义scheduler</h1>

<p>除基础用法以外,还可以通过指定执行频率和回调函数来创建自定义调度器:</p>

<pre><code>this-&gt;schedule(schedule_selector(HelloWorld::updateCustom), 1.0f, kRepeatForever, 0);

//*.h
void updateCustom(float dt);
//*.cpp
void HelloWorld::updateCustom(float dt){
    //Do something!
}
</code></pre>

<p>自定义的scheduler在回调时使用一个Timer来计时,所以会花费更多的内存和计算时间,而且由于其内部实现机制,其间隔时间至少大于0.1秒。这种scheduler更适合作为定时器来使用。</p>

<h1>优先级</h1>

<p>我们还可以为调度器指定优先级，来处理回调方法执行的先后顺序逻辑。</p>

<pre><code>void Node::scheduleUpdate(){
    scheduleUpdateWithPriority(0);
}

void Node::scheduleUpdateWithPriority(int priority){
    _scheduler-&gt;scheduleUpdate(this, priority, !_running);
}
</code></pre>

<h1>移除</h1>

<p>Scheduler会随Node对象移除而停止,当然你也可以显示地执行移除函数</p>

<pre><code>node-&gt;unschedulerUpdate();
node-&gt;unschedule(SEL_SCHEDULE selector, float delay);
</code></pre>

<h1>参考</h1>

<ul>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/scheduler/zh.md">http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/scheduler/zh.md</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - Spine骨骼动画]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/25/cocos-spine/"/>
    <updated>2015-11-25T14:14:58+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/25/cocos-spine</id>
    <content type="html"><![CDATA[<p>Spine是一款出众的2D的骨骼动画编辑器。</p>

<h1>使用步骤</h1>

<p>1.首先,在SETUP模型下选中右侧的Images标签页,然后点击Browse将包含图片资源的文件夹添加进来。</p>

<p>2.将Images下的图片拖入场景,并按照角色的样子将各个部位拼接起来。可通过右侧Draw Order调整图片的绘制顺序;</p>

<p>3.创建骨骼,并绑定图片到骨骼上,注意各骨骼的父子关系。</p>

<p>4.切换到ANIMATE模式,选中要“动”的骨骼,对其进行旋转、移动、缩放等操作,每次改动后要记得打关键帧。</p>

<p>5.选择菜单中的Texture Packer选项,导出Cocos2d-x工程需要的json文件和atlas以及png合图。</p>

<h1>在Cocos2d-x里使用</h1>

<p>首先,包含Spine动画需要的相关头文件:</p>

<pre><code>#include &lt;spine/spine-cocos2dx.h&gt;
#include "spine/spine.h"
using namespace spine;
</code></pre>

<p>然后,使用SkeletonAnimation创建Spine动画</p>

<pre><code>auto skeletonNode = new SkeletonAnimation("player.json", "player.atlas");
skeletonNode-&gt;setAnimation(0, "walk", true);
skeletonNode-&gt;debugBones = false;
skeletonNode-&gt;setPosition(CCRANDOM_0_1() * windowSize.width, 0 + CCRANDOM_0_1() * windowSize.height);
addChild(skeletonNode);
</code></pre>

<h1>参见:</h1>

<ul>
<li><a href="http://zh.esotericsoftware.com/spine-in-depth">http://zh.esotericsoftware.com/spine-in-depth</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/spine/zh.md">http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/spine/zh.md</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Xcode上运行Cocos2d-JS工程]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/23/run-cocos2d-js-on-xcode/"/>
    <updated>2015-11-23T17:21:14+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/23/run-cocos2d-js-on-xcode</id>
    <content type="html"><![CDATA[<p>在Mac下通过命令生成Cocos2d-JS项目时,编译命令也会生成相应的Xcode集成环境,用Xcode打开下面目录下的工程就可以直接在真机或模拟器下运行调试:</p>

<pre><code>project
    /frameworks
        /runtime-src
            /proj.ios_mac
                /project.xcodeproj
</code></pre>

<p>使用Xcode 7.0以上版本会出现如下错误:</p>

<pre><code>error:-fembed-bitcode is not supported on versions of iOS prior to 6.0
</code></pre>

<p>修改方法,选择General->Deployment Target 6.0以上<br>
或者设置Build Settings->Build Options->Enabled Bitcode为NO。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - 批次绘制]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/19/cocos-auto-batching/"/>
    <updated>2015-11-19T16:52:57+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/19/cocos-auto-batching</id>
    <content type="html"><![CDATA[<h1>自动批绘制</h1>

<p>从3.0版本以后,cocos2d的图形渲染模块实现了自动批绘制(Auto-batching)的优化。引擎的渲染部分对相同材质的连续渲染指令(QuadCommand)进行过滤,如果当前的渲染对象的材质和上一次渲染的材质一样,就不渲染了,保存一下所需的信息,继续遍历下一个,直到发现当前材质和上一个材质不一样，才重新开始渲染。</p>

<p>这样一来,渲染指令里相邻的且材质ID相同的多个draw call就能减少为一个,过程如下图:</p>

<p><img src="http://sbxfc.github.io/images/2015/10/auto-batching.png" alt="" /></p>

<p>最简单的满足条件就是我们用同一张图片连续创建精灵,这些精灵在绘制时只需要一个draw call:</p>

<pre><code>for (int i = 0; i &lt; 10000; i++)
{
    Sprite* sprite = Sprite::create("HelloWorld.png");
    sprite-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite);
}
</code></pre>

<p>需要注意的是,在渲染开始前引擎会对渲染指令根据zOrder进行一次排序。所以,连续添加的相同Sprite需要保证期zOrder是一样的。当然,我们也可以利用zOrder排序的这个机制,对非连续添加的相同纹理精灵设置相同zOrder来满足自动批绘制的条件:</p>

<pre><code>for(int i = 0; i &lt; 10000; i++)
{
    Sprite* sprite1 = Sprite::create("CloseNormal.png");
    sprite1-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite1);

    Sprite* sprite2 = Sprite::create("CloseSelected.png");
    sprite2-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite2);
    sprite2-&gt;setZOrder(1);
}
</code></pre>

<p>由于,Auto-batching的使用条件是使用QuadCommands渲染命令的连续的相同材质ID的Sprite或ParticleSystem objects。所以,我们也可以使用精灵帧表单来实现Auto-batching。</p>

<pre><code>SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile("TankMovePlist.plist");
for(int i = 0; i &lt; 10000; i++)
{
    char buf[64];
    sprintf(buf,"image/M26_b_%d.png", i%8 + 4);
    SpriteFrame *frame= SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName(buf);
    Sprite *sprite = Sprite::createWithSpriteFrame(frame);
    sprite-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    this-&gt;addChild(sprite);
}
</code></pre>

<p>进而将Auto-Batching用在动画上:</p>

<pre><code>SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile("TankMovePlist.plist");
for(int i = 0; i &lt; 700; i++)
{
    auto s_tank = Sprite::createWithSpriteFrameName("image/M26_b_4.png");

    auto tankMoveAnimation = Animation::create();
    tankMoveAnimation-&gt;setDelayPerUnit(0.1);
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_4.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_5.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_6.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_7.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_8.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_9.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_10.png"));
    tankMoveAnimation-&gt;addSpriteFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("image/M26_b_11.png"));
    s_tank-&gt;runAction(RepeatForever::create(Animate::create(tankMoveAnimation)));
    s_tank-&gt;setPosition(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height);
    addChild(s_tank);
}
</code></pre>

<p>运行效果:</p>

<p><img src="http://sbxfc.github.io/images/2015/10/tank_move.png" alt="" /></p>

<h1>使用SpriteBatchNode绘制精灵</h1>

<p>和Auto-batching的对绘制优化的策略一样,SpriteBatchNode将多个精灵放到一个纹理上,绘制的时候直接统一绘制该texture，不需要单独绘制子节点。</p>

<pre><code>SpriteBatchNode* batchNode = SpriteBatchNode::create("HelloWorld.png", 10000);
addChild( batchNode);

for ( int i = 0; i &lt; 10000; ++i)
{
    Sprite* sprite = Sprite::createWithTexture( batchNode-&gt;getTexture());
    sprite-&gt;setPosition(Point(CCRANDOM_0_1() * winSize.width, 0 + CCRANDOM_0_1() * winSize.height));
    batchNode-&gt;addChild( sprite);
}
</code></pre>

<p>再添一个官网文档上提供的例子:</p>

<pre><code>auto batch = SpriteBatchNode::create("Images/grossini_dance_atlas.png", 1);
addChild(batch, 0, kTagSpriteBatchNode);        

auto sprite1 = Sprite::createWithTexture(batch-&gt;getTexture(), Rect(85*0, 121*1, 85, 121));
auto sprite2 = Sprite::createWithTexture(batch-&gt;getTexture(), Rect(85*1, 121*1, 85, 121));

auto s = Director::getInstance()-&gt;getWinSize();
sprite1-&gt;setPosition( Point( (s.width/5)*1, (s.height/3)*1) );
sprite2-&gt;setPosition( Point( (s.width/5)*2, (s.height/3)*1) );

batch-&gt;addChild(sprite1, 0, kTagSprite1);
batch-&gt;addChild(sprite2, 0, kTagSprite2);
</code></pre>

<h1>参见:</h1>

<ul>
<li><a href="https://github.com/chukong/cocos-docs/blob/master/manual/framework/native/v3/auto-batching/zh.md">https://github.com/chukong/cocos-docs/blob/master/manual/framework/native/v3/auto-batching/zh.md</a></li>
<li><a href="http://blog.csdn.net/chenqiai0/article/details/46820669">http://blog.csdn.net/chenqiai0/article/details/46820669</a></li>
<li><a href="http://www.cocos2d-x.org/docs/tutorial/framework/html5/parkour-game-with-javascript-v3.0/chapter5/zh">在cocos2d-js上运行动画</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d - 屏幕适配]]></title>
    <link href="http://sbxfc.github.io/blog/2015/11/09/cocos-resolution/"/>
    <updated>2015-11-09T17:50:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/11/09/cocos-resolution</id>
    <content type="html"><![CDATA[<p>现在,几乎每人都有一台移动设备。无论是手机还是iPad,这些设备的尺寸千差万别。因此,想开要发一款能在不同屏幕上友好显示的游戏,就要综合这些设备的特点,设计合理的适配方案。</p>

<p>从2.0.4开始,Cocos2d-x就提出了自己的多分辨率适配方案,经过这几年的发展已趋于成熟。对于开发者来说,如果能掌握这些技巧,就能够很好地解决适配问题。</p>

<h1>资源到设计尺寸</h1>

<p>在Cocos里,官方把适配方案分为了两步,第一步是资源到设计尺寸的适配。</p>

<p>因为设备尺寸是参差不齐的,当我们在开发游戏时并不会假定界面是基于某台设备来设计的。通常,我们会选择一个较为通用的尺寸来进行界面布局(比如1027*768),这时选取的这个尺寸称为设计尺寸。</p>

<p>而从资源到设计尺寸的映射,其实就是图片到设计尺寸的映射。例如,我们为iPhone3G和iPhone 4设计一款游戏。iPhone 3G的分辨率是320*480,而iPhone 4的分辨率是640*960。尽管这两种设备分辨率不同,但是屏幕尺寸一样大。在这样的情况下,我们使用同样的设计尺寸,只不过将iPhone4的图片资源换成2倍的即可。</p>

<p>通过 cocos2d 的setContentScaleFactor函数可以设置所有加载资源的缩放因子:</p>

<pre><code>director-&gt;setContentScaleFactor(2);
</code></pre>

<p>设置完之后,一张640*960的背景图在一个sprite显示时,高宽变为为320*480,而分辨率变为了原本的4倍。这样一来,iPhone 3G和iPhone 4的屏幕适配做好了。</p>

<p>当然,因为改变了缩放因子,这两种设备设置加载的资源就不同,为了方便管理,我们会为它们设置不同的资源目录:</p>

<pre><code>/Resource
    /iphone
    /iphonehd
</code></pre>

<p>并根据具体设备指定Resource下的默认资源路径:</p>

<pre><code>vector&lt;string&gt; searchPath;
if (iPadHD){    
    searchPath.push_back("iphonehd");
}else if(iPhone){
    searchPath.push_back("iphone");
}
//如果这两个目录下没有所需的资源,加载common目录资源
searchPath.push_back("common");
FileUtils::getInstance()-&gt;setSearchPaths(searchPath);
</code></pre>

<p>现在iPhone 3G近乎绝迹,大部分iOS设备都是高清设备。所以,不必考虑为iPhone设备设置普清图。但是普清的iPad2用的还是比较多的(最后会介绍一点iOS原生语言的适配方法)。</p>

<h1>适配屏幕分辨率</h1>

<p>一开始时,我们在一个预设的尺寸上进行界面布局,当程序运行在实际设备上时,我们需要为其选择一个合适的适配方案。比如设计尺寸是320*480,而实际分辨率是320*500,这样一样,如果不做适配上下就会空出一条黑色缝隙。设计尺寸到屏幕分辨率的适配就是设计窗口如何缩放来适应实际屏幕的分辨率的过程。</p>

<p>Cocos提供了五种设计尺寸到屏幕分辨率的适配方案,通过setDesignResolutionSize函数来设置。DW、DH指设计尺寸的宽、高,后面的参数是适配方案的枚举值:</p>

<pre><code>setDesignResolutionSize(DW,/*分辨率宽*/
                         DH,/*分辨率高*/
                         resolutionPolicy) 
</code></pre>

<p>适配方案resolutionPolicy有五种选择:</p>

<ul>
<li>ResolutionPolicy::SHOW_ALL 屏幕宽、高分别和设计分辨率宽、高计算缩放因子，取较小者作为宽、高的缩放因子。保证了设计区域全部显示到屏幕上，但可能会有黑边。</li>
<li>ResolutionPolicy::EXACT_FIT 屏幕宽与设计宽的比例作为X方向的缩放因子，屏幕高与设计高的比例作为Y方向的缩放因子。保证了设计区域完全铺满屏幕，但是可能会出现图像拉伸。</li>
<li>ResolutionPolicy::NO_BORDER 屏幕宽、高分别和设计分辨率宽、高计算缩放因子，取较(大)者作为宽、高的缩放因子。保证了设计区域总能一个方向上铺满屏幕，而另一个方向一般会超出屏幕区域。</li>
<li>ResolutionPolicy::FIXED_HEIGHT 保持传入的设计分辨率高度不变,根据屏幕分辨率修正设计分辨率的宽度。(按照适配尺寸的宽度将屏幕撑满,宽度可根据屏幕的分辨率拉伸或者是裁剪)</li>
<li>ResolutionPolicy::FIXED_WIDTH 保持传入的设计分辨率宽度不变,根据屏幕分辨率修正设计分辨率的高度。</li>
</ul>


<p>最后两种适配方案,是我们常用的适配方式。以ResolutionPolicy::FIXED_HEIGHT为例,假如我们的设计尺寸是320*480,在640*1000的设备上运行时,原先一个点为(100,100)的sprite,其实际位置就出现在屏幕上(200,208)这个像素点的位置。实际界面上的图片如果没有设置根据分辨率和设计尺寸的变化而改变,将不会变化。</p>

<p>在Cocos2d-x里的cpp-empty-test项目里有一个AppMacros.h的文件,是官方针对iphone、ipad和ipadhd所做的适配方案。另外,还有一些重要的接口:</p>

<pre><code>Director::getInstance()-&gt;getOpenGLView()-&gt;setDesignResolutionSize() //设计分辨率大小及模式 
Director::getInstance()-&gt;setContentScaleFactor() //内容缩放因子 
FileUtils::getInstance()-&gt;setSearchPaths() //资源搜索路径 
Director::getInstance()-&gt;getOpenGLView()-&gt;getFrameSize() //屏幕分辨率 
Director::getInstance()-&gt;getWinSize()       //设计分辨率 
Director::getInstance()-&gt;getVisibleSize() //设计分辨率可视区域大小 
Director::getInstance()-&gt;getVisibleOrigin()//可视区域起点
</code></pre>

<h1>iOS原生语言的适配方式</h1>

<p>从iPad3、iPad mini2和iPhone4开始,苹果的设备都采用了&#8221;Retina&#8221;显示技术,即将多个像素点压缩至一块屏幕里。比如,一台iPhone4设备,GPU在工作时渲染出960*640个像素点,其中每四个像素一组,输出到原来屏幕上一个像素的显示区域里。这样一来，用户所看到的图标与文字的大小与原来的480x320分辨率显示屏相同，但精细度是原来的4倍。</p>

<p>在iOS原生开发中,iPad3、iPad mini2和iPhone4等等这些设备在读取图片时会优先选择文件名后缀是@2x的图片。比如,我们要为iPhone4上的应用添加一张背景图,我们会做一张640*960大小的图并命名为bkg@2x.png。如果是iPhone 3G设备,我们做一张320*480的图片即可。运行时不同设备优先去加载相应分辨率的图片。(iPad3、iPad mini2和iPhone4等这些Retina设备图片资源与屏幕尺寸的比值为2,到了iPhone6 PLUS这个比值达到了2.46左右,加载的图片格式也变为了@3x)</p>

<h1>参见:</h1>

<ul>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/multi-resolution/zh.md">Cocos2d-x 多分辨率适配完全解析</a></li>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/4-essential-concepts/4-4-resolution-policies/zh.md+">Cocos2d-JS的屏幕适配方案</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[glm数学库]]></title>
    <link href="http://sbxfc.github.io/blog/2015/10/29/glm/"/>
    <updated>2015-10-29T11:56:31+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/10/29/glm</id>
    <content type="html"><![CDATA[<p>glm库是一个C++头文件形式的几何数学库,用于GLSL规范下的图形绘制。(OpenGL Mathematics (GLM) is a header only C++ mathematics library for graphics software based on the OpenGL Shading Language (GLSL) specifications.)</p>

<p>下载glm库:<br>
<a href="http://glm.g-truc.net/">http://glm.g-truc.net/</a><br>
<a href="https://github.com/g-truc/glm/releases">https://github.com/g-truc/glm/releases</a></p>

<p>如果使用Xcode,下载之后将解压后的glm文件夹路径(根目录)包含在Build Settings/Header Search Path里即可,使用时include相应的文件。</p>

<p>示例如下:</p>

<pre><code>#include &lt;glm/vec3.hpp&gt; // glm::vec3
#include &lt;glm/vec4.hpp&gt; // glm::vec4
#include &lt;glm/mat4x4.hpp&gt; // glm::mat4
#include &lt;glm/gtc/matrix_transform.hpp&gt; // glm::translate, glm::rotate, glm::scale, glm::perspective
glm::mat4 camera(float Translate, glm::vec2 const &amp; Rotate)
{   
    glm::mat4 Projection = glm::perspective(45.0f, 4.0f / 3.0f, 0.1f, 100.f);
    glm::mat4 View = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -Translate));
    View = glm::rotate(View, Rotate.y, glm::vec3(-1.0f, 0.0f, 0.0f));
    View = glm::rotate(View, Rotate.x, glm::vec3(0.0f, 1.0f, 0.0f));
    glm::mat4 Model = glm::scale(glm::mat4(1.0f), glm::vec3(0.5f));
    return Projection * View * Model;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebSocket数据帧]]></title>
    <link href="http://sbxfc.github.io/blog/2015/10/15/ccjs-websocket/"/>
    <updated>2015-10-15T17:35:06+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/10/15/ccjs-websocket</id>
    <content type="html"><![CDATA[<p>WebSocket通过onmessage函数接收服务器返回的数据,其中evt.data的数据格式可能为String、ArrayBuffer或Blob三者之一。这个数据格式是由服务器返回数据里的数据帧的opcode决定的。</p>

<p>所以,即便服务器返回的数据是byte或者char,如果opcode的值仍是文本类型,客户端还是会收到一个字符串。</p>

<ul>
<li><a href="https://w3c.github.io/websockets/#websocket">https://w3c.github.io/websockets/#websocket</a></li>
<li><a href="http://www.cnblogs.com/fengyunlishi/archive/2013/05/10/3071893.html">http://www.cnblogs.com/fengyunlishi/archive/2013/05/10/3071893.html</a></li>
</ul>


<h1>代码:</h1>

<p><a href="https://github.com/sbxfc/CocosJSWebSocket">https://github.com/sbxfc/CocosJSWebSocket</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2d-JS 初探]]></title>
    <link href="http://sbxfc.github.io/blog/2015/10/09/ccjs-start/"/>
    <updated>2015-10-09T18:21:41+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/10/09/ccjs-start</id>
    <content type="html"><![CDATA[<h1>锚点和坐标</h1>

<p>Cocos引擎使用的是右手<a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E5%9D%90%E6%A0%87%E7%B3%BB">笛卡尔坐标系</a>,相对于我们熟悉的标准屏幕坐标系,其坐标原点在屏幕的左下角。</p>

<p>在Cocos里,显示对象以锚点(anchor)对齐。即一个sprite如果坐标设置为【0,0】并且锚点也是【0,0】的话,它的左下角就与屏幕的左下角对齐。但是默认情况下,非Layer对象的默认节点都是【0.5,0.5】。所以,如果没注意直接将坐标设置为【0,0】时,就会导致图片上半边和下半边出现在屏幕外。</p>

<pre><code>var sprite  = cc.Sprite.create(res.bkg_image);
sprite.anchorX = 0;
sprite.anchorY = 0; 
sprite.x = 0;
sprite.y = 0;
this.addChild(sprite);
</code></pre>

<h1>定位</h1>

<p>cc.winSize表示游戏窗口大小,而cc.visibleRect表示游戏的可视区域。在有些情况下,游戏窗口大小并不等于显示区域大小。如果在屏幕上方显示一个文本或精灵推荐使用cc.visibleRect</p>

<pre><code>var visibleRect = cc.visibleRect;
var topLeft = visibleRect.topLeft;
</code></pre>

<h1>自定义事件</h1>

<p>自定义事件的使用和JS、AS3类似,首先是建立一个事件监听器,并且设置相应的处理函数:</p>

<pre><code>var listener = cc.EventListener.create({
    event: cc.EventListener.CUSTOM,
    eventName: "game_custom_event",
    callback: function(event){
        // 可以通过getUserData来设置需要传输的用户自定义数据
        console.log("Custom event received : " + event.getUserData().toString());
    }
});
cc.eventManager.addListener(listener, 1);
</code></pre>

<p>在触发事件的地方使用dispatchEvent抛出事件:</p>

<pre><code>var event = new cc.EventCustom("game_custom_event");
event.setUserData("Hello World");
cc.eventManager.dispatchEvent(event);
</code></pre>

<p>其中,addListener函数的第二个参数可以填一个显示对象,也可以填一个数字。如果以显示对象为参数时,当该对象被回收则监听器也被移除。如果以数值为参数,该数值的大小决定了事件的优先级,数值越大则优先级越低。显示对象为参数的事件优先级为0 (ps.若一个以非显示对象为参数的addListener函数的第二个参数填0时,在一些情况下会出现问题)</p>

<p>这些可以在官方文档里的<a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/html5/v3/eventManager/zh.md">事件分发机制</a>中找到:</p>

<ul>
<li><a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/html5/v3/eventManager/zh.md">http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/html5/v3/eventManager/zh.md</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS - iOS9 键盘系统]]></title>
    <link href="http://sbxfc.github.io/blog/2015/09/28/ios9kb/"/>
    <updated>2015-09-28T18:29:52+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/09/28/ios9kb</id>
    <content type="html"><![CDATA[<p>我们知道,访问UIApplication的windows属性可以获取当前显示的所有非系统window。其中,在iOS9之前类型为UITextEffectWindow的window就是键盘窗口,结构大致如下:</p>

<pre><code>windows = { UIWindow,UITextEffectWindow }
</code></pre>

<p>但在iOS9之后,新增了一个类型为 UIRemoteKeyboardWindow 的窗口用来显示键盘按钮,所以想获取键盘上的按钮,就需要得到UIRemoteKeyboardWindow</p>

<pre><code>windows = { UIWindow,UITextEffectWindow,UIRemoteKeyboardWindow }
</code></pre>

<p>获取一个键盘窗口(swift):</p>

<pre><code>internal var keyboardWindow: UIWindow? {
    let windows = UIApplication.sharedApplication().windows
    for window in windows {
        let views = window.subviews
        for subview in views{
            let className = NSStringFromClass(subview.dynamicType)
            if className == "UIKeyboard" {
                return window
            }
        }
    }

    for window in windows.reverse() {
        let className = NSStringFromClass(window.dynamicType)
        if className == "UIRemoteKeyboardWindow" {
            return window
        }
    }

    //获取UITextEffectWindow
    if windows.count &gt; 1 {
        return windows.last!
    }

    //fail
    return nil
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符集及编码]]></title>
    <link href="http://sbxfc.github.io/blog/2015/07/29/character-encoding/"/>
    <updated>2015-07-29T18:01:48+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/07/29/character-encoding</id>
    <content type="html"><![CDATA[<p>计算机是二进制设备,并且识别的数据也是二进制格式。我们常用的字符、数字或者标点最终都要被转化成二进制的形式。一个char类型的数字1在内存里的存储:</p>

<pre><code>—————————————————
|0|0|0|0|0|0|0|1|
—————————————————
</code></pre>

<p>计算机处理二进制的形式的数据,但是我们使用计算机去工作或娱乐的时候很难追踪到二进制的影子。我们看到的是大量的文字、图片、甚至是影像等。这中间发生了什么呢？</p>

<h1>前人的智慧</h1>

<p>最初人们发明了无线电电报,并通过点(.)、划(&ndash;)和中间停顿将每个字符和标点符号彼此的发送出去。&#8221;滴&#8221; 和 &ldquo;嗒&rdquo; 分别代指点和划。比如字母‘X’对应的组合就是:</p>

<pre><code>- . . -
</code></pre>

<p>单词之间使用小停顿,一个句子之间使用大停顿。这种把字符用可变长度的信号表示的编码方式称为莫尔斯电码。</p>

<h1>ASCII</h1>

<p>到了计算机时代,因为计算只识别&#8221;0&#8221;或&#8221;1&#8221;这两种数据,这很类似于莫尔斯电码里的点和划。于是,人们借鉴莫尔斯电码用8位的&#8221;0&#8221;和&#8221;1&#8221;的不同组合来表示英文中出现的26个小写字母、26个大些字母、英式符号、0-9的阿拉伯数字以及计算机终端的特殊动作,这就是ASCII码。</p>

<p>大写的‘X’对应的ASCII码:</p>

<pre><code>—————————————————
|0|1|0|1|1|0|0|0|  = ‘X’
—————————————————
</code></pre>

<p>字母&#8217;X&#8217;就是一个字符,而54个大小写字母、英式符号以及10个阿拉伯数字就是ASCII的字符集,&lsquo;0101 1000&#8217;这种八个字节的数据就是ASCII的编码。除此之外,还有几个概念。比如,还有一些概念:</p>

<ul>
<li>比特(bit) : 也可称为&#8221;位&#8221;,是计算机信息中的最小单位,是 binary digit(二进制数位)的缩写,指二进制中的一位。</li>
<li>字节(byte): 计算机中信息计量的一种单位,一个位就代表&#8221;0&#8221;或&#8221;1&#8221;,每8个位(bit)组成一个字节(byte)</li>
<li>字符(Character):文字与符号的总称,可以是各个国家的文字、标点符号、图形符号、数字等。</li>
<li>字符集(Character
Set):是多个字符的集合</li>
<li>编码(Encoding):信息从一种形式或格式转换为另一种形式的过程</li>
<li>字符编码(Character Encoding): 按照何种规则存储字符</li>
</ul>


<p>8位(bit)总共有2的8次方,256种不同的组合。而ASCII码只用到了128种,刚好占了后7位。</p>

<h1>EASCII &amp; ANSI编码</h1>

<p>最初计算机只在美国使用,这些字符显然足够用了。但是后来,计算机传到了欧洲各国,为了支持本国语言他们将后面128种没有使用到的字节编入本国的文字和符号。比如法国的 é 对应的编码为130(1000 0010)</p>

<p>但是,这里又出现了新的问题。不同的国家有不同的字母,因此,哪怕它们都使用256个符号的编码方式,代表的字母却不一样。比如,
130在法语编码中代表了é,在希伯来语编码中却代表了字母Gimel
但是不管怎样,所有这些编码方式中,0&mdash;127表示的符号是一样的,不一样的只是128&mdash;255的这一段。
EASCII由此应运而生,EASCII码比ASCII码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号。</p>

<p>再后来,计算机传入了亚洲国家。对于像中国这样动辄几万个汉字字符的语言。使用ASCII码显示不行。于是中国国家标准总局在1981年,
正式制订了中华人民共和国国家标准简体中文字符集,项目代号 <font color="#bd260d">GB2312</font> 或 <font color="#bd260d">GB2312-80</font>。</p>

<p><img src="http://sbxfc.github.io/images/2015/8/th.jpeg" alt="" /></p>

<p>其他国家和地区也制定了不同的标准,比如日本的<font color="#bd260d">JIS</font> 、香港和台湾的繁体中文 <font color="#bd260d">BIG5</font></p>

<h1>Unicode</h1>

<p>由于每个国家都各自定义自己的标准,但带来的结果就是谁也不懂对方的编码体系。于是,世界相关组织意识到了这个问题,并开始尝试制定统一的编码标准。最初尝试做这件事情的两个组织是<font color="#bd260d">国际标准化组织(ISO)</font>和<font color="#bd260d">统一码联盟</font>。国际标准化组织(ISO)及国际电工委员会(IEC)于1984年联合成立了<font
color="#bd260d">ISO/IEC小组</font>(GB为国标汉语拼音的首字母),主要用于开发统一编码项目；
而Xerox、Apple等软件制造商则于1988年组成了统一码联盟,用于开发统一码项目。两个组织都在编写统一字符集,但后来他们发现各自在做相同的工作,同时世界上也不需要两个不兼容的字符集,于是两个组织就此合并了双方的工作成果,
并为创立一个单一编码表而协同工作。</p>

<p>1991年,两个组织共同的工作成果Unicode 1.0正式发布。(最新的一个版本 是2014年6月15日发布的Unicode 7.0。)</p>

<h1>ISO/IEC 8859</h1>

<p>ISO/IEC小组在1984年成立后的第三年(即1987年)开始启动ISO 8859标准的编写,ISO
8859是一系列8位字符集的标准,主要为世界各地的不同语言(除CJK)而单独编写的字符集,一共定义了15个字符集:</p>

<ul>
<li>ISO/IEC 8859-1:西欧语言</li>
<li>ISO/IEC 8859-2:中欧语言</li>
<li>ISO/IEC 8859-3:南欧语言</li>
<li>ISO/IEC 8859-4:北欧语言</li>
<li>ISO/IEC 8859-5:斯拉夫语</li>
<li>ISO/IEC 8859-6:阿拉伯语</li>
<li>ISO/IEC 8859-7:希腊语</li>
<li>ISO/IEC 8859-8:希伯来语</li>
<li>ISO/IEC 8859-9:土耳其语</li>
<li>ISO/IEC 8859-10:北日耳曼语</li>
<li>ISO/IEC 8859-11:泰语</li>
<li>ISO/IEC 8859-13:波罗的语族</li>
<li>ISO/IEC
8859-14: 凯尔特语族</li>
<li>ISO/IEC 8859-15:西欧语言,收录芬兰语字母和大写法语重音字母,以及欧元(€)符号</li>
<li>ISO/IEC 8859-16 :东南欧语言,主要供罗马尼亚语使用,并加入欧元(€)符号</li>
</ul>


<p>其中ISO/IEC 8859-1至ISO/IEC
8859-4四个项目早在1982年就已经编写出来,只不过是由ANSI与ECMA合作完成,并于1985年正式公布,ISO/IEC小组成立后,
这一成果被其收录,并改名为ISO/IEC 8859 前四个项目。 大家其实发现以上15个字符集中并没有代号为&#8221;ISO/IEC 8859
-12&#8221;的字符集,据说-12号本来是预留给印度天城体梵文的,但后来却搁置了(阿三有了自己的编码－ISCII)。由于英语没有任何重音字母,
故可使用以上十五个字符集中的任何一个来表示。</p>

<h1>ISO/IEC 10646 / UCS</h1>

<p>1993年,ISO/IEC 10646标准第一次发表,ISO/IEC 10646是ISO 646的扩展,定义了1个31位的字符集。ISO
10646标准中定义的字符集为UCS,<font color="#bd260d">UCS是Universal Character
Set的缩写,中文译作通用字符集。</font></p>

<p>版本:</p>

<ul>
<li>ISO/IEC 10646-1:第一次发表于1993年,现在的公开版本是2000年发表的ISO/IEC 10646-1:2000。</li>
<li>ISO/IEC 10646-2:在2001年发表。</li>
</ul>


<p>包含字符:</p>

<p>最初的ISO 10646-1:1993的编码标准,即Unicode
1.1,收录中国大陆、台湾、日本及韩国通用字符集的汉字共计20,902个,当然每个版本的Unicode标准的字符集所包含的字符数不尽相同,
UCS包含了已知语言的所有字符,除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语,还包括中文、日文、韩文这样的方块文字,
此外还包括了大量的图形、印刷、数学、科学符号。
UCS给每个字符分配一个唯一的代码,并且赋予了一个正式的名字,通常在表示一个Unicode值的十六进制数的前面加上&#8221;U+&ldquo;,例如&#8221;U+0041&rdquo;
代表字符&#8221;A&#8221;。</p>

<p>编码方案:</p>

<p>UCS仅仅是一个超大的字符集,关于UCS制定的编码方案有两种:UCS-2和UCS-4,<font color="#bd260d">Unicode默认以UCS-2编码。</font>
顾名思义,UCS-2就是用两个字节编码,UCS-4就是用4个字节(实际上只用了31位,最高位必须为0)编码。那么UCS-
2其实可以容纳的字符数为65536(2的16次方),而UCS-4可以容纳的字符数为2147483648(2的31次方)。其实对于UCS-
2已经是完全够用了,基本可以包含世界所有国家的常用文字,如果需要考虑一些偏僻字,那么UCS-4则绝对可以满足了,
21亿个字符哪怕是整个宇宙也够用了吧！</p>

<h1>UTF-8</h1>

<p>Unicode 诞生,随之而来的计算机网络也发展了起来,Unicode
如何在网络上传输也是一个必须考虑的问题,于是在1992年,面向网络传输的UTF标准出现了。 UTF是Unicode Transformation
Format的缩写,中文译作Unicode转换格式。其实我们从现在可以把Unicode看作是一个标准或组织,而UCS就是一个字符集,
那么UCS在网络中的传输标准就是UTF了。
前面提到了UCS的编码实现方式为UCS-2和UCS-4,即要么是每个字符为2个字节,要么是4个字节。
如果一个仅包含基本7位ASCII字符的Unicode文件,每个字符都使用2字节的原Unicode编码传输,其第一字节的8位始终为0,
这就造成了比较大的浪费。但是,聪明的人们发明了UTF-8,UTF-8采用可变字节编码,这样可以大大节省带宽,并增加网络传输效率。</p>

<p>UTF-8使用1~4个字节表示一个符号,根据不同的符号而变化字节长度。UTF-8的编码规则很简单,只有二条:</p>

<p>1）对于单字节的符号,字节的第一位设为0,后面7位为这个符号的unicode码。因此对于英语字母,UTF-8编码和ASCII码是相同的。 2.
对于n字节的符号(n>1),第一个字节的前n位都设为1,第n+1位设为0,后面字节的前两位一律设为10。剩下的没有提及的二进制位,
全部为这个符号的unicode码。</p>

<p>下表总结了编码规则,字母x表示可用编码的位。</p>

<pre><code>Unicode符号范围 | UTF-8编码方式 (十六进制) | (二进制)
--------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx
10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001
0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</code></pre>

<p>跟据上表,解读UTF-8编码非常简单。如果一个字节的第一位是0,则这个字节单独就是一个字符；如果第一位是1,则连续有多少个1,
就表示当前字符占用多少个字节。</p>

<p>下面,还是以汉字&#8221;严&#8221;为例,演示如何实现UTF-8编码。</p>

<p>已知&#8221;严&#8221;的unicode是4E25(100111000100101),根据上表,可以发现4E25处在第三行的范围内(0000
0800-0000 FFFF),因此&#8221;严&#8221;的UTF-8编码需要三个字节,即格式是&#8221;1110xxxx 10xxxxxx
10xxxxxx&#8221;。然后,从&#8221;严&#8221;的最后一个二进制位开始,依次从后向前填入格式中的x,多出的位补0。这样就得到了,&ldquo;严&#8221;的UTF-8编码是&rdquo;
11100100 10111000 10100101&#8221;,转换成十六进制就是E4B8A5。</p>

<p>其他:</p>

<ul>
<li>128个ASCII字符只需一个字节编码(Unicode范围由U+0000至U+007F) &ndash; 拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母需要二个字节编码(Unicode范围由U+0080至U+07FF)</li>
<li><font color="#bd260d"><strong>大部分国家的常用字(包括中文)使用三个字节编码</strong></font></li>
<li>其他极少使用的生僻字符使用四字节编码</li>
</ul>


<h1>GB13000</h1>

<p>前面提到了Unicode的迅速发展,至1993年时,包含CJK的Unicode
1.1已经发布了,天朝的ZF也意识到了需要一个更大的字符集来走向世界,于是在同一年,中国大陆制定了几乎等同于Unicode1.1的GB13000
.1-93国家编码标准(简称GB13000)。是的,你没听错,中华人民共和国信息产业部把Unicode里的所有东东拿过来,
然后自己重新修订发布了下,改为了国家标准GB13000。此标准等同于 ISO/IEC 10646.1:1993和Unicode 1.1。</p>

<h1>GBK</h1>

<p>1995年,在GB13000诞生后不久,中国教育科研网(NCFC)与美国NCFnet直接联网,这一天是中国被国际承认为开始有网际网路的时间。
此后网络正式开始在中国大陆接通,个人计算机开始在中国流行,虽然当时只是高富帅才消费得起的产品。中国是一个十几亿人口的大国,
微软意识到了中国是一个巨大的市场,当时的微软也将自己的操作系统市场布局进中国,进入中国随之而来要解决的就是系统的编码兼容问题。
之前的国家编码标准GB
2312,基本满足了汉字的计算机处理需要,它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但对于人名、古汉语等方面出现的罕用字和繁体字,
GB 2312不能处理,因此微软利用了GB2312中未使用的编码空间,收录了GB13000中的所有字符制定了汉字内码扩展规范GBK(K为汉语拼音
Kuo
Zhan中&#8221;扩&#8221;字的首字母)。所以这一关系其实是大陆把Unicode1.1借鉴过来改名为了GB13000,
而微软则利用GB2312中未使用的编码空间收录GB13000制定了GBK。所以GBK是向下完全兼容GB2312的。</p>

<p>包含字符:<br> 共收录21886个字符, 其中汉字21003个, 字符883个</p>

<p>编码方式:<br> GBK只不过是把GB2312中未使用的空间,编码了其他字符,所以GBK同样是用两个字节为每个字符进行编码</p>

<h1>GB18030</h1>

<p>微软到了99年前后,说GBK已经落伍了,现在流行UTF-8标准,准备全盘转换成UTF-8,但中国ZF不是吃素的,
编写并强制推出了GB18030标准。GB18030的诞生还有一个原因是GBK只包含了大部分的汉字和繁体字等,我们的少数民族兄弟根本木有考虑！
中国有56个民族,其中有12个民族有自己的文字,那怎么办呢？在2000年,电子工业标准化研究所起草了GB18030标准,项目代号&#8221;GB
18030-2000&#8221;,全称《信息技术-信息交换用汉字编码字符集-基本集的扩充》。此标准推出后,
在中国大陆之后的所售产品必须强制支持GB18030标准,不然不得卖！</p>

<p>版本:</p>

<ul>
<li>GB 18030-2000</li>
<li>GB 18030-2005</li>
</ul>


<p>包含字符:</p>

<p>GB18030收录了GBK中的所有字符,并将Unicode中其他中文字符(少数民族文字、偏僻字)也一并收录进来重新编码。其中GB
18030-2000共收录27533个汉字,而GB 18030-2005共包含70244个汉字。</p>

<p>编码方式:</p>

<p>采用多字节编码,每个字符由1或2或4个字节进行编码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread]]></title>
    <link href="http://sbxfc.github.io/blog/2015/07/14/pthread/"/>
    <updated>2015-07-14T10:28:45+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/07/14/pthread</id>
    <content type="html"><![CDATA[<h1>POSIX线程</h1>

<p>pthread即POSIX thread,是POSIX标准的线程API。(POSIX是包括Unix、Linux、OS系统等绝大多数操作系统支持的API标准。)</p>

<p>使用pthread创建一个线程非常简单,调用pthread_create函数,传入pthread_t类型的线程ID指针和回调的函数指针。</p>

<pre><code>pthread_create(&amp;tid,NULL,func,NULL);
</code></pre>

<p>线程终止:</p>

<ul>
<li><p>线程函数返回(return)时线程终止。</p></li>
<li><p>被同一进程的另外线程cancel掉。</p></li>
<li><p>调用pthread_exit函数退出线程。</p></li>
</ul>


<p><a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B">查看POSIX线程支持的操作系统</a></p>

<!-- more -->


<h1>互斥锁</h1>

<p>线程之间可以共享内存空间,这意味着不同线程可以读取内存中的同一个变量。但是不同线程在同一时间修改一个内存对象会造成一些不可预知的结果。</p>

<p>为了避免意外发生,我们需要用到pthread里一个非常重要的数据结构 —— 互斥对象(mutex)。互斥对象在使用时结合互斥锁 pthread_mutex_lock() 和 pthread_mutex_unlock()使用。</p>

<p>它的工作是这样的:线程B锁定了一个互斥对象(mutex),如果线程A也试图锁定该互斥对象时,线程A就进入睡眠状态。一旦线程B释放了互斥对象（通过 pthread_mutex_unlock(),线程A 就能够锁定这个互斥对象（换句话说，线程A就将从 pthread_mutex_lock() 函数调用中返回,同时互斥对象被重新锁定）。同样地,当线程A正锁定互斥对象时,如果线程C试图锁定互斥对象的话,线程C也将临时进入睡眠状态。</p>

<pre><code>pthread_mutex_lock(&amp;mymutex);

 //在这里进行多线程环境下的数据修改工作,
 //因为mymutex被锁定,凡是此时试图锁定mymutex的线程都会进入睡眠,
 //直到函数unlock执行之后才被重新唤醒。

pthread_mutex_unlock(&amp;mymutex);
</code></pre>

<p>对已锁定的互斥对象上调用 pthread_mutex_lock() 的所有线程都将进入睡眠状态,这些睡眠的线程将“排队”访问这个互斥对象。</p>

<p>1）互斥对象使用时需要初始化:</p>

<p>静态初始化:</p>

<pre><code>pthread_mutex_t myLock = PTHREAD_MUTEX_INITIALIZER;
</code></pre>

<p>动态初始化:</p>

<pre><code>pthread_mutex_t myLock;
pthread_mutex_init(&amp;myLock,NULL);
</code></pre>

<p>2）销毁互斥对象</p>

<p>一旦初始化完之后,我们就可以根据实际情况对对象实施加锁和解锁,但需要注意的是如果是动态初始化(使用pthread_mutex_init()初始化)的互斥对象,在释放或废弃条件变量之前,需要清理它:</p>

<pre><code>/*
 * 使用pthread_mutex_init()初始的互斥对象,
 * 应使用 pthread_mutex_destroy() 清理它。
 * pthread_mutex_destroy() 接受一个指向 pthread_mutext_t 的指针作为参数
 * 并释放创建互斥对象时分配给它的任何资源。
 */
pthread_mutex_destroy(myLock);   
</code></pre>

<p>3）尝试锁定</p>

<p>使用 pthread_mutex_trylock() 可以尝试锁定互斥对象。如果互斥对象当前处于解锁状态，那么您将获得该锁并且函数将返回零。然而,如果互斥对象已锁定,这个调用也不会阻塞。</p>

<h1>条件变量</h1>

<p>如果线程在等待某个特定条件发生,按照上面的方式,就需要对数据结构不停地加锁、解锁进行检测,这样不但浪费时间和资源，而且繁忙查询的效率也非常低。这时,我们可以用pthread_cond_wait()方法。</p>

<p>以查询特殊条件为例:<br>
首先,线程A执行对数据的检测并没有找到满足条件的数据。此时,通过pthread_cond_wait()函数将线程A设置为等待休眠状态:</p>

<pre><code> /*
 * 线程A操作
 */
pthread_mutex_lock(&amp;mymutex);
//检测数据条件 
pthread_cond_wait(&amp;mycond, &amp;mymutex);
</code></pre>

<p>调用pthread_cond_wait()所做的第一件事就是对互斥对象进行解锁（其他线程可以修改数据条件）,并等待条件mycond发生。</p>

<p>此时,pthread_cond_wait() 调用还未返回,对互斥对象的解锁会立即发生。等待条件mycond通常是一个阻塞操作。这意味着线程将睡眠,在它苏醒之前不会消耗 CPU 周期。这正是我们期待发生的情况。线程将一直睡眠，直到特定条件发生,在这期间不会发生任何浪费 CPU 时间的繁忙查询。从线程的角度来看,它只是在等待 pthread_cond_wait() 调用返回。</p>

<p>假如另一个线程B锁定了mymutex并对数据条件做了修改。在对互斥对象解锁之后,线程B会立即调用函数 pthread_cond_broadcast(&amp;mycond)。此操作之后，线程B将使所有等待 mycond 条件变量的线程立即苏醒。这意味着第一个线程（仍处于 pthread_cond_wait() 调用中）现在将苏醒。</p>

<pre><code> /*
 * 线程B操作
 */
pthread_mutex_lock(&amp;mymutex);

//修改数据条件操作 

pthread_mutex_unlock(&amp;mymutex);
pthread_cond_broadcast(&amp;mycond);
</code></pre>

<p>您可能会认为在线程B调用 pthread_cond_broadcast(&amp;mymutex) 之后，线程A的 pthread_cond_wait() 会立即返回。不是那样!实际上，pthread_cond_wait() 将执行最后一个操作:重新锁定 mymutex。一旦 pthread_cond_wait() 锁定了互斥对象,那么它将返回并允许线程A继续执行。</p>

<p>1）初始化和清除</p>

<p>和互斥对象一样,条件变量在使用时也需要初始化:</p>

<pre><code>pthread_cond_t mycond;
pthread_cond_init(&amp;mycond,NULL);
</code></pre>

<p>在释放或废弃条件变量之前，需要毁坏它,如下所示:</p>

<pre><code>pthread_cond_destroy(&amp;mycond);
</code></pre>

<p>2）等待</p>

<p>一旦初始化了互斥对象和条件变量，就可以等待某个条件，如下所示:</p>

<pre><code>pthread_cond_wait(&amp;mycond, &amp;mymutex);
</code></pre>

<p>请注意，代码在逻辑上应该包含 mycond 和 mymutex。一个特定条件只能有一个互斥对象,而且条件变量应该表示互斥数据“内部”的一种特殊的条件更改。一个互斥对象可以用许多条件变量（例如，cond_empty、cond_full、cond_cleanup），但每个条件变量只能有一个互斥对象。</p>

<p>3）发送信号和广播</p>

<p>对于发送信号和广播，需要注意一点。如果线程更改某些共享数据，而且它想要唤醒所有正在等待的线程，则应使用 pthread_cond_broadcast 调用，如下所示：</p>

<pre><code>pthread_cond_broadcast(&amp;mycond);
</code></pre>

<p>在某些情况下，活动线程只需要唤醒第一个正在睡眠的线程。假设您只对队列添加了一个工作作业。那么只需要唤醒一个工作程序线程（再唤醒其它线程是不礼貌的！）:</p>

<pre><code>pthread_cond_signal(&amp;mycond);
</code></pre>

<p>此函数只唤醒一个线程。</p>

<h1>参见</h1>

<p>POSIX 线程(WIKI):<a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B">https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B</a></p>

<p>POSIX 线程详解:<a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/#icomments">http://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/#icomments</a></p>

<p>POSIX 线程详解，第 2部分:<a href="https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/</a></p>

<h1>完整代码</h1>

<p><a href="https://github.com/sbxfc/PThreads">https://github.com/sbxfc/PThreads</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS - 帧时长可控的逐帧动画]]></title>
    <link href="http://sbxfc.github.io/blog/2015/06/03/ios-frame-by-frame-animation/"/>
    <updated>2015-06-03T10:12:57+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/06/03/ios-frame-by-frame-animation</id>
    <content type="html"><![CDATA[<p>UIImageView组件可以通过设置 animationImages、anmiamtionDurations 等参数来实现逐帧动画。 但是,如果我们想单独改变某一帧的播放时间,通过UIImageView现有的API却不能实现。那么,我们就会考虑自己定义一个这样的逐帧动画。</p>

<p>当你选择诸如 <font color="#bd260d"><strong>CADisplayLink</strong></font> 、 <font color="#bd260d"><strong>NSTimer</strong></font>等时间驱动来绘制这样的的动画时,很可能会遇到一个问题。当这样的动画在同一个界面被大量使用时,会带来不小的CPU消耗、甚至是帧阻塞问题。通常情况下 UIView动画 或者 CAAnimation 驱动的动画任务几乎不受系统影响。所以,我们可以选择用 UIView 或 CAAnimation 等来封装我们的自定义动画。</p>

<p>实际上,UIImageView动画本身就是一个封装了传统动画API的image view。其实现方式是通过修改image view在layer上的contents属性来完成动画播放的:</p>

<!-- more -->


<pre><code>&lt;CAKeyframeAnimation:0x8e5b020; 
    removedOnCompletion = 0; 
    delegate = &lt;_UIImageViewExtendedStorage: 0x8e49230&gt;; 
    duration = 2.5; 
    repeatCount = 2.14748e+09; 
    calculationMode = discrete; 
    values = (
        "&lt;CGImage 0x8d6ce80&gt;",
        "&lt;CGImage 0x8d6d2d0&gt;",
        "&lt;CGImage 0x8d5cd30&gt;"
    ); 
    keyPath = contents
&gt;
</code></pre>

<p>所以,我们可以通过修改contents来实现自定义动画。创建一个CAKeyframeAnimation动画,设置 keyTimes 来控制每帧时长。keyTimes里的元素表示每帧图片出现在动画总时长duration里的相对位置,其取值为区间[0,1]上的比例值。且 keyTimes 里元素个数要比values值多1个,使循环播放时首尾帧动画可以衔接起来。</p>

<pre><code>CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"contents"];
animation.calculationMode = kCAAnimationDiscrete;
animation.keyTimes = keyTimes;
animation.values = images;
animation.duration = 7.0f;
animation.repeatCount = HUGE_VAL;
[imageView.layer addAnimation:animation forKey:nil];   
</code></pre>

<h1>代码</h1>

<p><a href="https://github.com/sbxfc/FrameByFrameAnimation">https://github.com/sbxfc/FrameByFrameAnimation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS - 操作队列]]></title>
    <link href="http://sbxfc.github.io/blog/2015/06/02/ios-nsoperation/"/>
    <updated>2015-06-02T11:27:11+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/06/02/ios-nsoperation</id>
    <content type="html"><![CDATA[<p>操作队列(NSOperationQueue)是一个可以方便实现后台操作的工作队列,它是在GCD的基础上使用Cocoa抽象出来的一个队列模型。操作队列和GCD一样既可以在主线程运行,做一些UI刷新操作,也可以在子线程运行。</p>

<p>操作队列里的工作被封装在一个NSOperation对象里,NSOperation本身是抽象对象不能直接使用,需要创建它的子类或者使用系统提供的两个子类 NSBlockOperation 或 NSInvocationOperation。</p>

<h1>NSOperation</h1>

<p>NSOperation 将工作单独封装成一个单元,并提供了一些线程安全的特性,比如状态(state),优先级(priority),依赖(dependencies)以及取消(cancellation)等。</p>

<p>1,状态(state):</p>

<p>状态(state)描述了一个 operation 的执行过程:</p>

<pre><code>isReady -&gt; isExecuting -&gt; isFinished
</code></pre>

<p>1）isReady：isReady属性与dependencies有关,当operation依赖的工作完成时,会获得一个isReady键值的KVO通知,然后isReady属性修改为YES,标识该工作已经准备好。</p>

<p>2）isExecuting：如果操作队列正在执行该operation,operation的isExecuting返回YES。</p>

<p>3）isFinished: 任务成功的完成了或者中途被Cancel掉,该值返回YES。NSOperationQueue只会把isFinished为YES的operation踢出队列,isFinished为NO的永远不会被移除,所以实现时一定要保证其正确性,避免死锁的情况发生。</p>

<p>2,取消(cancellation):</p>

<p>NSOperation里的工作是可以取消的,取消一个operation可以是显式的调用cancel方法,也可以是operation依赖的其他operation执行失败。</p>

<p>和state类似,当NSOperation被取消,是通过isCancelled键值的KVO来获得。当NSOperation的子类覆写cancel方法时,注意清理掉内部分配的资源。特别注意的是,这时isCancelled和isFinished的值都变为了YES,isExecuting为值变为NO</p>

<p>3，优先级(priority):</p>

<p>所有的operation在NSOperationQueue中未必都是一样的重要,设置queuePriority属性就可以提升和降低operation的优先级，queuePriority属性可选的值如下:</p>

<ul>
<li>NSOperationQueuePriorityVeryHigh</li>
<li>NSOperationQueuePriorityHigh</li>
<li>NSOperationQueuePriorityNormal</li>
<li>NSOperationQueuePriorityLow</li>
<li>NSOperationQueuePriorityVeryLow</li>
</ul>


<p>4,依赖(Dependencies):</p>

<p>如果你从服务器上下载一张图片完成后进行压缩,你可能会想把下载图片作为一个operation,压缩作为另外一个。一个图片在从服务器上下载下来之前是没有办法压缩的,于是我们说压缩图片的operation依赖从服务器上下载图片的operation,后者必须先完成,前者才能开始执行。通过代码来说就是:</p>

<pre><code>[resizingOperation addDependency:networkingOperation];
[operationQueue addOperation:networkingOperation];
[operationQueue addOperation:resizingOperation];
</code></pre>

<p>除非一个操作的依赖的isFinished返回YES，不然这个操作不会开始。要记住添加到队列里的所有的operation的依赖关系,并避免循环依赖,比如A依赖B,B依赖A,这样会产生死锁。</p>

<h1>自定义NSOperation子类</h1>

<p>对于非并发的工作,你只需要实现NSOperation子类里的main方法:</p>

<pre><code>@implementation YourOperation

-(void)main
{
    if(self.isCancelled == NO)
    {
        //执行相应的操作
    }
}

@end
</code></pre>

<p>如果要支持并发工作，那么NSOperation子类需要至少重写这四个方法:</p>

<ul>
<li>start</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
</ul>


<p>start方法是工作的入口，通常是你用来设置线程或者其他执行工作任务需要的运行环境的，注意不要调用[super start]；isConcurrent是标识这个Operation是否是并发执行的，这里曾经是个坑，如果你没有实现isConcurrent，默认是返回NO，那么你的NSOperation就不是并发执行而是串行执行的，不过在iOS5.0和OS X10.6之后，已经会默认忽略这个返回值，最终和Queue的maxConcurrentOperationCount最大并发操作值相关；isExecuting和isFinished是用来报告当前的工作执行状态情况的，注意必须是线程访问安全的。</p>

<p>注意你的实现要发出合适的KVO通知，因为如果你的NSOperation实现需要用到工作依赖从属特性，而你的实现里没有发出合适的“isFinished”KVO通知，依赖你的NSOperation就无法正常执行。NSOperation支持KVO的属性有：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>当然也不是说所有的KVO通知都需要自己去实现，例如通常你用不到addObserver到你工作的“isCancelled”属性，你只需要直接调用cancel方法就可以取消这个工作任务。</p>

<h1>NSInvocationOperation &amp; NSBlockOperation</h1>

<p>除此之外,对于一些不复杂的工作,可以由官方提供的NSOperation两个子类 NSInvocationOperation 和 NSBlockOperation 来实现。</p>

<p>NSInvocationOperation:</p>

<pre><code>NSInvocationOperation* operation = [[NSInvocationOperation alloc]
                                        initWithTarget:self
                                        selector:@selector(doSomeWork:)
                                        object:nil];
</code></pre>

<p>NSBlockOperation:</p>

<pre><code>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
        // Do some work.
    }];
</code></pre>

<h1>NSOperationQueue</h1>

<p>创建一个子线程队列,并将operation添加至队列里:</p>

<pre><code>NSOperationQueue* operationQueue = [[NSOperationQueue alloc] init];
[operationQueue addOperation:operation];
</code></pre>

<p>或者,直接使用主线程队列:</p>

<pre><code>NSOperationQueue* operationQueue = [NSOperationQueue mainQueue];
</code></pre>

<p>设置并发工作的数量:</p>

<pre><code>operationQueue.maxConcurrentOperationCount = 1;
</code></pre>

<p>取消所有队列工作:</p>

<pre><code>[operationQueue cancelAllOperations];
</code></pre>

<h1>参见</h1>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html">https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html</a></li>
</ul>


<!--对于非并发操作,你可以通过重写 main 方法来定义自己的operation。使用main方法非常简单,你不需要管理一些状态属性（例如 isExecuting 和 isFinished）,当 main 方法返回的时候,这个 operation 就结束了。

    @implementation YourOperation
        - (void)main
        {
            // 进行处理 ...
        }
    @end

如果要支持并发工作,那么NSOperation子类需要至少重写这四个方法:

- start
- isConcurrent
- isExecuting
- isFinished

..

    @implementation YourOperation
        - (void)start
        {
            self.isExecuting = YES;
            self.isFinished = NO;
            // 开始处理,在结束时应该调用 finished ...
        }
        
        - (BOOL)isConcurrent {
            return YES;
        }
        
        - (BOOL)isExecuting {
            return self.executing;
        }

        - (void)finished
        {
            self.isExecuting = NO;
            self.isFinished = YES;
        }
    @end-->




<!--操作队列(Operation Queue)是基于GCD实现的用于异步操作任务的队列模型。GCD本身是通过C语言实现的,而Operation Queue在GCD基础上实现了一些方便的功能,并且通过Cocoa进行抽象封装。

通常来说Operation Queue是开发者最安全的选择。

#NSOperation

Operation Queue队列处理的任务是通过NSOperation子类来封装的。你可以自己来写子类实现,也可以使用Foundation框架里提供的两个子类:<font color="#bd260d">**NSInvocationOperation**</font> 或 <font color="#bd260d">**NSBlockOperation**</font>

一,NSInvocationOperation

    NSInvocationOperation* operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(runTask:) object:nil];
    [operation start];

二,NSBlockOperation
    
    NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
        [self runTask:@&#8221;task1&#8221;];
    }];
    [operation addExecutionBlock:^{
        [self runTask:@&#8221;task2&#8221;];
    }];
    [operation addExecutionBlock:^{
        [self runTask:@&#8221;task3&#8221;];
    }];
    [operation start];
    
[NSBlockOperation](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSBlockOperation_class/index.html) 可以并行执行多个 NSOperation ,但只有当所有 block 都执行完成之后,NSBlockOperation的 <font color="#bd260d">**isFinished**</font> 属性才会被标记为已完成。 

三,自定义NSOperation子类
    
第一种方式是简单地重写main函数来操作operations,当 main 方法返回的时候,这个 operation 就结束了。



    -(void)main
    {
        NSLog(@&#8221;Do SomeThing&#8221;);
    }
    


另一种方式是重写start方法。在这种情况下,你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变,需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话,你就需要在合适的时候发送合适的 KVO 消息。


    @implementation MyOperation
        - (void)start
        {
            [self willChangeValueForKey:@&#8221;isExecuting&#8221;];
            _isExecuting = YES;
            [self didChangeValueForKey:@&#8221;isExecuting&#8221;];
            
            // 开始处理,在结束时调用 finished &#8230;
            [self runTask];         
        }
        
    
        - (void)finish
        {
            [self willChangeValueForKey:@&#8221;isExecuting&#8221;];
            [self willChangeValueForKey:@&#8221;isFinished&#8221;];
            
            _isExecuting = NO;
            _isFinished = YES;
            
            [self didChangeValueForKey:@&#8221;isFinished&#8221;];
            [self didChangeValueForKey:@&#8221;isExecuting&#8221;];
        }
    @end


参见:[MyOperation类](https://github.com/sbxIOS/OperationQueuesExample)

#Operation Queue

operation创建好以后很容易加入operation queue中

    queue = [[NSOperationQueue alloc] init];
    NSInvocationOperation* operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(runTask:) object:nil];
    [queue  addOperation:operation];
    
或者直接使用Block添加:
    
    //想queue队列添加任务
    [queue addOperationWithBlock:^{
        //向主队列添加任务 
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                
        }];
    }];
    
#参考

使用Operation Queue实现批量下载:<br>
<https://github.com/sbxIOS/asyncDownloadQueque>

使用Operation Queue对ScrollView里的项进行异步绘制:<br>
<https://github.com/sbxIOS/lazyViewExample>&#8211;>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跨平台的TCP通信客户端]]></title>
    <link href="http://sbxfc.github.io/blog/2015/05/12/cross-platform-tcpip-socket/"/>
    <updated>2015-05-12T14:05:45+08:00</updated>
    <id>http://sbxfc.github.io/blog/2015/05/12/cross-platform-tcpip-socket</id>
    <content type="html"><![CDATA[<p>TCP/IP 是 TCP/IP协议族的简称,是互联网的基础通讯架构,事实上也是计算机网络通信的国际标准。TCP/IP的前身是NCP(网络控制协议),是S.克罗克及其小组在加州大学制定的最初的主机间通信协议。NCP协议的缺点是,它没有为每台电脑设置一个唯一地址,导致在越来越庞大的网络中难以准确定位。另一方面,NCP缺乏纠错功能,导致数据传输不稳定。</p>

<p>TCP/IP将网络通信的可靠性改为由主机保证而不是像NCP那样由网络保证。TCP/IP使用一个成为网关（后来改为路由器以免与网关混淆）的计算机为每个网络提供一个接口并且在它们之间来回传输数据包。</p>

<p>在1985年时,因特网架构理事会举行一个三天有250家厂商代表参加的关于计算产业使用TCP/IP的工作会议，帮助推广并且引领它日渐增长的商业应用。</p>

<p>如今,绝大多数商业操作系统都实现了TCP/IP协议,这其中包括所有的商业Unix、Linux发布包，以及Mac OS X和微软的Windows操作系统。</p>

<h1>TCP/IP模型</h1>

<p>两个因特网主机(Host)通过两个路由器（Router）和对象的层连接。</p>

<p><img src="http://sbxfc.github.io/images/2015/5/tcp_ip_stack_connections.png" alt="" /></p>

<!-- more -->


<p>在TCP/IP模型是一个抽象的分层模型，这个模型中,所有的TCP/IP系列网络协议都被归类为4个抽象层,应用层、运输层、网络层、链路层。每一层建立在低一层的服务上,并为高一层提供服务。</p>

<ul>
<li><p>数据链路层:在TCP/IP协议族中,链路层又称为网络接口层。通常包括操作系统中的设备驱动和计算机中的对应网络接口卡。它们一起处理与电缆的物理接口细节。</p></li>
<li><p><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>:网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。</p></li>
<li><p>运输层:运输层主要为两台计算机上的应用程序提供端到端的通信。在TCP/IP协议族中,有两个不相同的传输协议:TCP和UDP。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层,确认接收到的分组,设置发送最后确认分组的超时时钟 等。由于运输层提供了高可靠性的端到端的通信,因此应用层可以忽略所有这些细节。而另一方面,UDP则为应用层提供一种非常简单的服务。它只是把称做数据报的分组从一台主机发送到另一台主机,但并不保证该数据报能到达另一端。任何必须的可靠性由应用层来提供。</p></li>
<li><p>应用层:应用层是指我们的应用程序。</p></li>
</ul>


<p><img src="http://sbxfc.github.io/images/2015/5/ip_stack_connections.png" alt="" /></p>

<h1>POSIX</h1>

<p>可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称。</p>

<p>在OS和Linux在内的所有Unix系统里,我们都可以使用Posix接口来创建socket。在Windows系统里,我们可以使用WinSock来操作socket,WinSock实际上是对POSIX socket的一个封装。</p>

<h1>WinSock和POSIX socket接口的异同</h1>

<p>一,头文件</p>

<p>在windows中需要引入头文件</p>

<pre><code>#include &lt;winsock.h&gt;
</code></pre>

<p>在其他遵从POSIX规则的系统里需要引入</p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
</code></pre>

<p>二,链接库</p>

<p>在windows下面需要主动连接ws2_32.lib库</p>

<pre><code>#ifdef WIN32
#include "StdAfx.h"
#pragma comment(lib, "wsock32")
#endif
</code></pre>

<p>三,初始化</p>

<p>在windows下面需要初始化,windows下面是通过动态链接的方式调用socket的,所以需要你告诉调用的链接库的版本,操作系统会帮你加载并初始化dll。</p>

<pre><code>WORD wVersionRequested;
WSADATA wsaData;
int err;
wVersionRequested = MAKEWORD(2, 0);
err = WSAStartup(wVersionRequested, &amp;wsaData);
if(0 != err) //检查Socket初始化是否成功
{
    cout&lt;&lt;"Socket2.0初始化失败，Exit!";
    return -1;
}
</code></pre>

<p>四,函数</p>

<p>在Windows和POSIX里,socket的函数是一致的。只是windows里面宏定义了一个socket描述符。</p>

<h1>创建TCP套接字</h1>

<p>一,创建一个TCP套接字</p>

<p>该函数返回一个整数描述符,以后所有socket调用(如随后的connect和write)就用该描述符来标识这个套接字</p>

<pre><code>int sockfd = socket(AF_INET,     //internetwork: UDP, TCP, etc
                    SOCK_STREAM, //SOCK_STREAM说明是TCP类型
                    0);          //protocol
</code></pre>

<p>二,与TCP服务器建立连接</p>

<pre><code>    /**
     * 设置发往的地址
     */
    struct sockaddr_in addrto;
    addrto.sin_family = AF_INET;//地址类型为internetwork
    addrto.sin_addr.s_addr = inet_addr(ip);
    addrto.sin_port = htons(port);

    int connect(int sockfd,          //sockfd是由socket函数返回的套接字描述符
    const struct sockaddr* servaddr,//套接字地址
    socklen_t addrlen);              //套接字地址结构大小
</code></pre>

<p>三,发送信息:</p>

<p>使用<font color="#bd260d"><strong>send</strong></font>函数向TCP连接的另一端(服务器端)发送数据:</p>

<pre><code>int send(SOCKET s,     //指定接收端的套接字描述符
          char *buf,   //指定一个存放应用程序要发送数据的缓冲区            int len,     //指明buf的长度
          int flags);  //这个参数一般置为0
</code></pre>

<p>四,数据接收</p>

<p>使用<font color="#bd260d"><strong>recv</strong></font>函数从TCP连接的另一端接收数据:</p>

<pre><code>int recv(SOCKET s,  //指定接收端的套接字描述符
         char *buf, //指明一个缓冲区,该缓冲区用来存放recv接收到的数据
         int len,    //指明buf的长度
         int flags); //这个参数一般设置为0
</code></pre>

<h1>完整代码</h1>

<p><a href="https://github.com/sbxfc/CrossPlatformSocket">https://github.com/sbxfc/CrossPlatformSocket</a></p>

<h1>参考</h1>

<p>网络传输协议(Wiki):<br><a href="http://zh.wikipedia.org/zh-cn/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">http://zh.wikipedia.org/zh-cn/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE</a></p>

<p>TCP/IP协议族(Wiki):<br><a href="http://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">http://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F</a></p>

<p>TCP/IP 详解</p>

<p>Unix 网络编程</p>

<p>sockimp.pdf:<br><a href="http://www.openss7.org/papers/strsock/sockimp.pdf">http://www.openss7.org/papers/strsock/sockimp.pdf</a></p>

<p>windows/linux socket接口的异同:<br><a href="http://blog.chinaunix.net/uid-28323465-id-3876368.html">http://blog.chinaunix.net/uid-28323465-id-3876368.html</a></p>
]]></content>
  </entry>
  
</feed>
