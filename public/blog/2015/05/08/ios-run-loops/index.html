
<!DOCTYPE html>
<html lang="ja">
  <head>
    <!-- include head -->
    

<meta charset="utf-8">
<title>iOS - Run Loop - sbxfc</title>
<meta name="author" content="sbxfc">
<meta name="description"
      content="iOS - Run Loop 什么是RunLoop RunLoop是iOS里线程的一部分,任何线程,包括主线程都包含了一个Run Loop对象。RunLoop的作用相当于在线程上维持一个类似while的死循环,使线程在任何时刻都处于待命状态,并且在不执行任务时 RunLoop &hellip;">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!---->
<script src="//ajax.useso.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<link href='http://fonts.useso.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/monokai_sublime.min.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!---->

<link rel="canonical" href="http://sbxfc.github.io/blog/2015/05/08/ios-run-loops">
<link href="/favicon.png" rel="icon">
<link href="/stylesheets/screen.css"
      media="screen, projection"
      rel="stylesheet"
      type="text/css">
<link href="/atom.xml"
      rel="alternate"
      title="sbxfc"
      type="application/atom+xml">


<script src="/javascripts/modernizr-2.0.js" type="text/javascript"></script>
<script src="/javascripts/ender.js" type="text/javascript"></script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>



    <!-- /include -->
  </head>
  <body>
    <div id="wrapper">

      <header role="banner" class="site_metas">
	<!-- include header -->
	
<hgroup>
  <h1><a href="/">sbxfc</a></h1>
  
  <h2>IF YOU LOVE SOMETHING,SET IT FREE</h2>
  
</hgroup>

	<!-- /include -->
        <!-- include social_service_links -->
	

        <!-- /include -->
      </header>

      <div id="content">
	<!-- content -->
	

  


<article class="entry" role="article">

  <header>
    <h2 class="entry_title">iOS - Run Loop</h2>
    
  </header>

  <div class="entry_content"><h1>什么是RunLoop</h1>

<p>RunLoop是iOS里线程的一部分,任何线程,包括主线程都包含了一个Run Loop对象。RunLoop的作用相当于在线程上维持一个类似while的死循环,使线程在任何时刻都处于待命状态,并且在不执行任务时 RunLoop 会让线程进入睡眠状态(不占用CPU资源)。</p>

<p>主线程上的RunLoop在App运行时由系统自动启动,子线程里的RunLoop需要手动运行。运行时,RunLoop在需要监听Time Source或者Input Source类型的至少一种事件源,如果RunLoop没有绑定事件源,在运行后会立即退出。当事件源没有触发时,RunLoop会让线程进入睡眠状态,当事件源发生时RunLoop会唤醒线程来处理事件。</p>

<h1>运行RunLoop</h1>

<p>1）RunLoop 在 Foundation 层和 Core Foundation 层都有对应的接口。</p>

<p>Foundation层:</p>

<pre><code>//运行 RunLoop 在NSDefaultRunLoopMode模式下
- (void)run;
//运行 RunLoop 在指定模式下,直到指定的时间结束
- runMode:beforeDate:
//运行 RunLoop 在NSDefaultRunLoopMode模式下,直到指定的时间结束
- runUntilDate:
- acceptInputForMode:beforeDate:
</code></pre>

<p>Core Foundation层:</p>

<pre><code>//运行 CFRunLoopRef
void CFRunLoopRun();
//运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因
SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);
//停止运行 CFRunLoopRef
void CFRunLoopStop( CFRunLoopRef rl );
//唤醒 CFRunLoopRef
void CFRunLoopWakeUp ( CFRunLoopRef rl );
</code></pre>

<p>2）RunLoop的退出方式:</p>

<ul>
<li><p>以超时配置RunLoop启动,RunLoop会在指定的时间自动退出。</p></li>
<li><p>显式的停止RunLoop（调用CFRunLoopStop函数）</p></li>
<li><p><a href="https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/">https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/</a></p></li>
<li><a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFRunLoopRef/">https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFRunLoopRef/</a></li>
</ul>


<h1>运行模式</h1>

<p>RunLoop运行时只能以一种固定的模式运行,只会监控这个Mode下添加的Time Source和Input Source。如果这个模式下没有添加事件源,RunLoop会立刻退出。大多数时候，Run Loop都是运行在系统定义的默认模式上。</p>

<p>1）NSDefaultRunLoopMode : 大多数工作默认的运行模式</p>

<p>2) UITrackingRunLoopMode : 用于跟踪触摸事件触发的模式（比如UITableView上下滑动）, 主线程中当触摸事件发生时会设置为这个模式。</p>

<p>3) GSEventReceiveRunLoopMode : 用来接受系统事件,内部的Run Loop模式。</p>

<p>4）NSConnectionReplyMode : 使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个Mode。</p>

<p>5）NSModalPanelRunLoopMode : 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。</p>

<p>6) NSRunLoopCommonModes : 是一组常用的模式集合，将一个input source关联到这个模式集合上，等于将input source关联到这个模式集合中的所有模式上。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode，我有个timer要关联到这些模式上，一个个注册很麻烦，我可以用</p>

<pre><code>CFRunLoopAddCommonMode([[NSRunLoop currentRunLoop] getCFRunLoop],(__bridge CFStringRef) NSEventTrackingRunLoopMode)
</code></pre>

<p>将NSEventTrackingRunLoopMode或者其他模式添加到这个NSRunLoopCommonModes模式中，然后只需要将Timer关联到NSRunLoopCommonModes，即可以实现Run Loop运行在这个模式集合中任何一个模式时，这个Timer都可以被触发。默认情况下NSRunLoopCommonModes包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。注意：让Run Loop运行在NSRunLoopCommonModes下是没有意义的，因为一个时刻Run Loop只能运行在一个特定模式下，而不可能是个模式集合。</p>

<h1>事件源</h1>

<p>归根结底，Run Loop就是个处理事件的Loop，可以添加Timer和其他Input Source等各种事件源，如果事件源没有发生时，Run Loop就可能让线程进入asleep状态，而事件源发生时就会唤醒休眠的(asleep)的子线程来处理事件。Run Loop的事件源事件源分两类：Timer Source和Input Source(包括-performSelector:*API调用簇，Port Input Source、自定义Input Source)。</p>

<p>1）Timer Source类型的事件源,就是创建Timer添加到RunLoop中。在Cocoa里,使用NSTimer创建定时器加入Run Loop,在Core Foundation里使用CFRunLoopTimerRef类型,本质上NSTimer是CFRunLoopTimerRef的简单扩展。需要注意的是,使用scheduledTimerWithTimeInterval 创建的定时器会默认以NSDefaultRunLoopMode模式添加到Run Loop里。而使用timerWithTimeInterval或其他接口创建的Timer需要手动使用 -addTimer:forMode 添加到RunLoop中。如果事件源没有被添加到RunLoop中,则NSTimer不会监听到相应的事件。</p>

<pre><code>NSTimer* timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
[runLoop addTimer:timer forMode:NSDefaultRunLoopMode];
</code></pre>

<p>2) Input Source中的-performSelector:*API调用簇方法，有以下这些接口：</p>

<pre><code>performSelectorOnMainThread:withObject:waitUntilDone:  
performSelectorOnMainThread:withObject:waitUntilDone:modes:

performSelector:onThread:withObject:waitUntilDone:  
performSelector:onThread:withObject:waitUntilDone:modes:

performSelector:withObject:afterDelay:  
performSelector:withObject:afterDelay:inModes:

cancelPreviousPerformRequestsWithTarget:  
cancelPreviousPerformRequestsWithTarget:selector:object:
</code></pre>

<p>这些API最后两个是取消当前线程中调用，其他API是在主线程或者当前线程下的Run Loop中执行指定的@selector。</p>

<p>3）Port Input Source</p>

<p>Cocoa和Core Foundation提供了基于端口的对象用于线程或进程间的通信。</p>

<p>如果要建立和<font color="#bd260d"><strong>NSMachPort</strong></font>对象的本地连接,你需要创建端口对象并加入主线程的Run Loop里。当运行次线程的时候,你传递端口对象到次线程的入口点。次线程通过端口对象将消息传入主线程。</p>

<p>首先在主线程建立端口对象,并在次线程的启动时将端口对象传入:</p>

<pre><code>//设置主线程port，子线程通过此端口发送消息给主线程
NSPort *myPort = [NSMachPort port];
if (myPort) {
    myPort.delegate = self;
    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];

    //启动次线程,并传入端口信息
    [NSThread detachNewThreadSelector:@selector(launchThreadWithPort:) toTarget:[MyWorkerClass class] withObject:myPort];
}
</code></pre>

<p>PS:<font color="#bd260d"><strong>NSPortMessage</strong></font>
是私有 API,官网示例中的线程通实例,客户端实现会有问题。线程间通信完全可以用<font color="#bd260d"><strong>GCD</strong></font>
或<font color="#bd260d"><strong>performSelector</strong></font>函数等更简便的方式去实现:</p>

<p><a href="http://stackoverflow.com/questions/12384210/is-nsportmessage-in-the-ios-api">http://stackoverflow.com/questions/12384210/is-nsportmessage-in-the-ios-api</a></p>

<h1>观察者</h1>

<p>为了方便理解,贴一下代码:</p>

<ul>
<li><a href="https://github.com/sbxfc/RunLoops/">https://github.com/sbxfc/RunLoops/</a></li>
</ul>


<p>Run Loop里有一组用于监听事件源的Observers,observers可以通过Core Foundation层的接口定义,并监听指定模式下的事件源触发。</p>

<pre><code>CFRunLoopAddObserver(cfRunLoop, observer, kCFRunLoopDefaultMode);
</code></pre>

<p>程序里,大多数情况都是运行在 kCFRunLoopDefaultMode 模式下的,假如我们此时拖动示例中的TableView发现NSTimer事件源不再触发,并且收到RunLoop推出信号。因为此时,RunLoop</p>

<p>加入我们监听主线程运行的RunLoop UITrackingRunLoopMode 模式下,而NSTimer默认是运行在 kCFRunLoopDefaultMode 模式下的。有一种解决方式是将Timer添加到forMode:NSRunLoopCommonModes模式下,这也就意味着timer要跟触摸事件同时分享主线程,为了使程序拖动时流畅,在一些很繁重的计算情况下不建议这样去做,因为这样在一定程序上妨碍了流畅度。</p>

<pre><code>    [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>
</div>

  <footer>
    <p class="meta">

      

      
      <time datetime="2015-05-08 14:14:25 +0800" pubdate>May 8<span>th</span>, 2015</time>
      

      
      <span class="categories">
	
      </span>
      

    </p>

    

    
    <section>
      <h3 id="comments">Comments</h3>
      <div id="disqus_thread" aria-live="polite">
	<noscript>
	  Javascript 未启用。
	  (<a href="http://disqus.com/?ref_noscript">Disqus</a>)
	</noscript>
      </div>
    </section>
    

  </footer>
  
</div>

	<!-- /content -->
      </div>

      <footer role="contentinfo">
	<!-- include footer -->
	<p>
  Copyright &copy; 2015 - sbxfc -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

	<!-- /include -->
      </footer>
      
      <!-- include after_footer -->
      

<script type="text/javascript">
      var disqus_shortname = 'sbxfc17';
      
	
	// var disqus_developer = 1;
	var disqus_identifier = 'http://sbxfc.github.io/blog/2015/05/08/ios-run-loops';
	var disqus_url = 'http://sbxfc.github.io/blog/2015/05/08/ios-run-loops';
	var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










      <!-- /include -->

    </div>
  </body>
</html>
