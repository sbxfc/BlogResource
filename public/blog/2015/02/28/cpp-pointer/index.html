
<!DOCTYPE html>
<html lang="ja">
  <head>
    <!-- include head -->
    

<meta charset="utf-8">
<title>C/C++ 认识指针 - sbxfc</title>
<meta name="author" content="sbxfc">
<meta name="description"
      content="C/C++ 认识指针 管理内存 C/C++语言和其他语言相比最大的区别是需要自己管理内存,但也不是所有内存都需要开发者自己手动去管理。应当了解一下C/C++程序编译后的内存。 编译后的程序内存主要分为几部分: 1）栈区(stack) : 用于存放函数的参数和局部变量的值等。这一部分内存, &hellip;">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!---->
<script src="//ajax.useso.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<link href='http://fonts.useso.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/monokai_sublime.min.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!---->

<link rel="canonical" href="http://sbxfc.github.io/blog/2015/02/28/cpp-pointer">
<link href="/favicon.png" rel="icon">
<link href="/stylesheets/screen.css"
      media="screen, projection"
      rel="stylesheet"
      type="text/css">
<link href="/atom.xml"
      rel="alternate"
      title="sbxfc"
      type="application/atom+xml">


<script src="/javascripts/modernizr-2.0.js" type="text/javascript"></script>
<script src="/javascripts/ender.js" type="text/javascript"></script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>



    <!-- /include -->
  </head>
  <body>
    <div id="wrapper">

      <header role="banner" class="site_metas">
	<!-- include header -->
	
<hgroup>
  <h1><a href="/">sbxfc</a></h1>
  
  <h2>IF YOU LOVE SOMETHING,SET IT FREE</h2>
  
</hgroup>

	<!-- /include -->
        <!-- include social_service_links -->
	

        <!-- /include -->
      </header>

      <div id="content">
	<!-- content -->
	

  


<article class="entry" role="article">

  <header>
    <h2 class="entry_title">C/C++ 认识指针</h2>
    
  </header>

  <div class="entry_content"><h1>管理内存</h1>

<p>C/C++语言和其他语言相比最大的区别是需要自己管理内存,但也不是所有内存都需要开发者自己手动去管理。应当了解一下C/C++程序编译后的内存。</p>

<p>编译后的程序内存主要分为几部分:</p>

<p>1）栈区(stack) : 用于存放函数的参数和局部变量的值等。这一部分内存,在程序运行中由编译器自动分配,并且当程序结束时由编译器自动释放,不需要开发者参与管理。例如,在下面的代码中,val值是函数func里的一个局部变量,在函数结束后val自动释放:</p>

<pre><code>void func(){
    int val;
}
</code></pre>

<p>2）堆区(heap) :这一部分内存开发者自己主动分配的,需要开发者手动去释放。在C/C++程序中,我们主要用到两种主动申请内存的函数 <font color="#bd260d"><strong>malloc</strong></font>和<font color="#bd260d"><strong>new</strong></font>,前者来源于C,后者是C++特有的。</p>

<p>在myMallow函数里,指针pVal主动创建了一块int类型大小的内存,因为该内存创建于堆区,编译器不会帮我们释放掉,需要我们自己手动释放。</p>

<pre><code>void myMallow(){
    int* pVal = (int*)malloc(sizeof(int));
    free(pVal);//释放内存
}
</code></pre>

<p>3）全局区(静态区)(static),全局变量和静态变量存储于此,编译器在编译时就为这些变量分配内存。</p>

<pre><code>void foo(){
    static int val;//(val == 0),静态变量有默认值,动态变量没有,值是随机的。
}
</code></pre>

<p>4）其他区 : 剩下的部分是文字常量区和程序代码区,前者存放常量字符串后者用于储存函数体的二进制代码。</p>

<h1>指针的使用</h1>

<p>指针是C/C++里进行内存管理的途径。在C/C++里,所有变量、函数等,本质上是一个存在于内存区上的一块内存,并且每个内存都有一个地址。</p>

<p>对于一个int类型的变量val来说,其存在形式是一个大小为4个字节并且连续的内存。首字节的内存地址，即是该变量的内存地址。</p>

<pre><code>//指针pval的内存地址,并且记录下val类型
int val = 17;
int* p = &amp;val;//&amp;是取地址运算符
</code></pre>

<p>我们使用取地址运算符(&amp;)来获取变量val的内存地址,对于指针变量p,如果我们想获取其指向的目标对象,我们可以用解引用运算符(*p)来得到它:</p>

<pre><code>int reVal = *p;  //使用*解引用,获取目标对象。
</code></pre>

<p>在程序中,如果指针暂时没有一个需要指向的目标对象,我们可以声明一个空指针:</p>

<pre><code>int* p;
</code></pre>

<p>但是这样声明是不安全的,最好为其初始化。未初始化的指针,可能包含一个垃圾值,其可能覆盖内存上的某个随机内存区域。可以用等于0来初始化指针,这个声明确保这个指针不指向任何实体。<font color='#bd260d'><strong>虽然符号NULL在标准库中也定义为0，它常常用于初始化空指针。但是，NULL仅同C兼容,在C++中最好使用0。</strong></font></p>

<pre><code>int* p = 0;
</code></pre>

<h1>函数参数</h1>

<p>在函数调用时,参数是按值传递的,即传入的参数只是这个参数值的副本。我们在函数体内,修改这个参数并不会对原参数对象造成影响。有时候,我们需要去修改原参数本身,这时候我们可以传入原参数的地址。</p>

<pre><code>void inc(int *p){
    (*p)++;
}

int main()
{
    int a=3;
    inc(&amp;a);
}
</code></pre>

<p>在main函数里,我们将变量a的地址传入inc函数时,在函数调用的一刹那发生了一次赋值操作。这时新建的指针p(形参)指向变量a</p>

<pre><code>int* p = &amp;a;
</code></pre>

<h1>二级指针</h1>

<p>在使用变量地址作为参数传入时,通过解引用可以获取原变量,并修改原变量的值。但是如果我们要修改引用变量的指针,用传入原变量地址的方式就不行了。</p>

<p>这时我们可以传入指针的地址,<font color='#bd260d'><strong>指针作为一个对象也是有地址的。</strong></font>
对一个普通变量,通过取地址运算符(&amp;)获取该变量的地址。同样地,对一个指针使用取地址运算符(&amp;)获取指针的地址。</p>

<pre><code>void myMalloc(int** p){
    //申请一块内存,并赋值给指针对象*p
    *p = malloc(sizeof(int));
}

int main()
{
    int *p = 0;
    myMalloc(&amp;p);
    return 0;
}
</code></pre>

<h1>指针常量</h1>

<p>用const修饰的变量为常量,常量的值不能被修改。当const符号修饰指针时,分为两种情况。</p>

<p>第一,当const修饰符在*左侧时,表示*p部分为常量不能被修改:</p>

<pre><code>const int* pVal = &amp;val;
</code></pre>

<p>第二,当const修饰符在*右侧时,pVal部分为常量不能被修改:</p>

<pre><code>int* const pVal = &amp;val;
</code></pre>

<p>当*pVal作为常量部分时:</p>

<pre><code>int val = 17;
const int* pVal = &amp;val;

/**
* val不受影响
* 但常量*pVal不能被重新赋值
*/
val++;        
//*pVal = 18;

/**
* 可以修改指针引用的对象
*/
int num = 999;
pVal = &amp;num;
</code></pre>

<p>当pVal作为常量部分时:</p>

<pre><code>int val = 17;
const int* pVal = &amp;val;

//val值不受影响
val++;

/**
* 不可以修改指针引用的对象
*/
int num = 999;
//pVal = &amp;num;
</code></pre>

<p>当指针指向常量时,因为引用对象为常量，所以这个对象值不能被改变:</p>

<pre><code>const int val = 17;
const int* pval = &amp;val;

const char* pStr = "sbxfc";
</code></pre>

<h1>引用</h1>

<p>引用实际上是一个常量指针。表达式 <font color='#bd260d'><strong>int &amp;i = j;</strong></font>在编译时会被 <font color='#bd260d'><strong>int *const i = &j;</strong></font> 替换掉。所以,引用在初始化时必须为其赋值。</p>

<pre><code>int&amp; ref = val;
</code></pre>

<h1>字符串数组</h1>

<p>在C语言中,可以将字符串常量当做字符数组来使用。因为C语言中,系统会对字符串常量后面加一个&#8217;\0&#8217;来作为结束符。有了结束标志&#8217;\0&#8217;后，字符数组的长度就显得不那么重要了，在程序中往往依靠检测&#8217;\0&#8217;的位置来判定字符串是否结束，而不是根据数组的长度来决定字符串长度。当然，在定义字符数组时应估计实际字符串长度，保证数组长度始终大于字符串实际长度。（在实际字符串定义中，常常并不指定数组长度，如char str[]）</p>

<pre><code>char str[] = "Hello Sbxfc";
printf("%zu \n",sizeof(str));//12字节
</code></pre>

<h1>参考:</h1>

<p>More Effective C++</p>

<p><a href="http://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">维基百科-指针</a></p>

<p><a href="http://en.wikipedia.org/wiki/Reference_%28computer_science%29">维基百科-Reference</a></p>

<p><a href="http://en.wikipedia.org/wiki/Dereference_operator">维基百科-Dereference operator</a></p>

<p><a href="http://wenku.baidu.com/link?url=aw5yRsRMPGXrTDsBoP4MNSi7iTZ94ogX-b0GSaOYvFx7XyWC7071EOg_ehZrw4LuqBvfhml5wfUy-TUCBm5QZXksYcMSrK30FsDpSarMUcO">指针和引用的区别</a></p>

<p><a href="http://blog.csdn.net/fjb2080/article/details/5623427">c++之指针作为函数参数传递的问题</a></p>

<p><a href="http://www.fenesky.com/blog/2014/07/03/pointers-to-pointers.html">重新认识二级指针</a></p>

<p><a href="http://blog.csdn.net/webscaler/article/details/6577429">深入分析C++引用</a></p>
</div>

  <footer>
    <p class="meta">

      

      
      <time datetime="2015-02-28 13:47:25 +0800" pubdate>Feb 28<span>th</span>, 2015</time>
      

      
      <span class="categories">
	
      </span>
      

    </p>

    

    
    <section>
      <h3 id="comments">Comments</h3>
      <div id="disqus_thread" aria-live="polite">
	<noscript>
	  Javascript 未启用。
	  (<a href="http://disqus.com/?ref_noscript">Disqus</a>)
	</noscript>
      </div>
    </section>
    

  </footer>
  
</div>

	<!-- /content -->
      </div>

      <footer role="contentinfo">
	<!-- include footer -->
	<p>
  Copyright &copy; 2015 - sbxfc -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

	<!-- /include -->
      </footer>
      
      <!-- include after_footer -->
      

<script type="text/javascript">
      var disqus_shortname = 'sbxfc17';
      
	
	// var disqus_developer = 1;
	var disqus_identifier = 'http://sbxfc.github.io/blog/2015/02/28/cpp-pointer';
	var disqus_url = 'http://sbxfc.github.io/blog/2015/02/28/cpp-pointer';
	var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










      <!-- /include -->

    </div>
  </body>
</html>
