---
layout: post
title: "插入排序"
date: 2014-12-03 09:39:12 +0800
comments: true
categories: 
---

运行时间
---
---

1，若排序集合正好是顺序的,插入排序的工作量近似为0。如果是逆序的，工作量最大。<br>
2，若排序集合长度为n,集合里元素是顺序的，使用插入排序进行(n-1)次操作即可。若集合里元素是逆序的,那么此时需要进行的比较有n(n-1)/2次:

	1+2+3+4+...+(n-1) = n*(n-1)/2

插入排序的赋值操作是比较操作的次数加上 (n-1）次,即:

	T0 =  n*(n-1)/2 + (n-1);

平均来说插入排序算法的时间复杂度为Θ(n^2）:

	T = n*(n-1)/2 + T0 
	T = n*(n-1)/2 + n*(n-1)/2 + (n-1) 
	T = (n+1)*(n-1)
	T = Θ(n^2)
	
如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。
<!--more-->
实例
---
---
对集合{4,2,1,5,9}进行插入排序。<br>

1. 首先将集合的第一个元素4，作为已排序集合的第一个值{4}
2. 用第二个元素2，与已排序的集合{4}进行比较，若2<4,交换位置，得到集合 {2、4}。
3. 取集合第三个元素1与已排序集合{2、4}进行比较。<br>元素1首先与已排序集合的最后一个元素4比较,若1<4，将元素1、4交换位置,然后再与元素2进行比较，如元素1<2，将元素1、2的位置交换，最后得到排序集合{1,2,4}。
4. 以此类推。

代码实现
---
---

	#define LEN 5
	int a[LEN] = {4,2,1,5,9};
	
	void insert()
	{
	    int i, j, key;
	    for (j = 1; j < LEN; j++)
	    {
	        key = a[j];
	        i = j - 1;
	        while (i >= 0 && a[i] > key)
	        {
	            a[i+1] = a[i];
	            i--;
	        }
	        a[i+1] = key;
	    }
	    printf("%d, %d, %d, %d, %d \n",a[0], a[1], a[2], a[3], a[4]);
	}