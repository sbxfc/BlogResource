---
layout: post
title: "网络字节序(二)*"
date: 2015-01-29 11:57:27 +0800
comments: true
categories: 
---

BSD Socket API提供了16和32bit整数转化字节序的方法。但是,包括string 、double、float、long 在内的格式都是常用于网络通信的数据格式。

这时,我们需要自己去将这些数据转化为网络字节流。实现字节流转化的思路有两种:

#第一种方式是使用反转函数修改字节顺序

首先,判断当前设备是大端序还是小端序。如果是大端序,我们可将字节流直接放进字节数组里用于传输。如果是小端序,因为大端和小端的字节排列顺序正好相反。所以，我们可以通过一个反转函数将数据里的字节进行反转,最终得到我们需要的字节流。

这种方式的核心是一个反转函数:

	 /**
	 * 将字节源 bytes 里的字节顺序反转
	 * @param bytes 源字节
	 * @param size 字节长度
	 */
	void SFByteArray::reversalArray(char *bytes, size_t size)
	{
	    for(size_t i = 0; i < size / 2; i++)
	    {
	        char tb;
	        tb = *(bytes + i);
	        *(bytes + i) = *(bytes + size - i - 1);
	        *(bytes + size - i - 1) = tb;
	    }
	}
 
#另一种方式是使用移位运算符

除了使用逆转函数以外,还可以通过位移运算符来实现网络字节流的读写。使用移位运算符,直接读取高位或地位字节,无需进行大小端转换。（我们对一个数值进行移位运算的时候，不需要去考虑内存的排列顺序,移位运算符是在寄存器中进行的运算。永远左侧是高位，右侧是地位。)
	
	bytesBuf[writePos++] = (value >> 8) & 0xff;
	bytesBuf[writePos++] = value & 0xff;
	    
如果我们想获取一个高位字节，我们只需要右移相应的字节,移除低位即可。为了确保移位之后的数值是8位字节,我们使用了按位“与”运算。
	
	short value = 0;
    value  = (bytes[0] & 0xff) << 8;
    value |= (bytes[1] & 0xff);
    
从网络字节流里去读数值,首先把高位字节左移,获取高位对应的数值。然后与低位数值进行按位“或”运算,将低位和高位拼接在一起。
    
# 按位“与” &

参加按位“与”运算的两个数据,按照二进制进行“与”运算。

运算规则：<br>0&0=0;<br>0&1=0;<br>1&0=0;<br>1&1=1;

即：两位同时为“1”，结果才为“1”，否则为0 <br>

例如：3&5  即 0000 0011 & 0000 0101 = 0000 0001   因此，3&5的值得1。在大小端转化时,进行按位与运算,相当于对数值进行byte类型强转。

# 按位“或” | 

按位“或”的运算规则和按位“与”相反

1|1=1<br>1|0=1<br>0|1=1<br>0|0=0

#完整代码

完整代码:<https://github.com/CPPSF/ByteArrayDemo>
