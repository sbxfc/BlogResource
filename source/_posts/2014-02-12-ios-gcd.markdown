---
layout: post
title: "使用GCD的任务队列*"
date: 2014-02-12 18:31:58 +0800
comments: true
categories: 
---

GCD任务队列将多线程操作抽象成任务的形式,并通过队列的方式对任务进行组织和管理。开发者无需去关心底层如何实现多线程,只需要专注于任务操作。

#主线程队列

由于主线程负责程序的生命周期和UI绘制,所以尽量使用异步方式(dispatch_async)添加线程操作:
	
	dispatch_async(dispatch_get_main_queue(), ^{
		NSLog(@"执行主线程上的异步操作!");
	});

#串行队列

对于串行队列来说,在同一时间只有一个block在运行。

GCD的串行队列通过dispatch_queue_create来创建,该函数每次都会返回一个不同的任务队列,这一点需要留意。如果多个操作任务执行串行操作,要确保它们被添加到同一个串行队列上。

该函数第一个参数可选并且可以为NULL。

    dispatch_queue_t serialQueue = dispatch_queue_create(NULL,NULL);
    dispatch_async(serialQueue, ^{
        NSLog(@"执行串行任务1!");
    });
    dispatch_async(serialQueue, ^{
        NSLog(@"执行串行任务2!");
    });

#并行队列

串行队列也就是说可以并行执行多个任务block的队列,每个队列的完成顺序与其block里的时间复杂度有关。

需要注意的是,每个并行队列是与该队列的优先级密切相关。相同的优先级对应相同的全局并行队列。

	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
		NSLog(@"并行操作!");
    });

#监听全部队列任务完成


	dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_async(group,globalQueue, ^{
        [NSThread sleepForTimeInterval:3];
        NSLog(@"我是任务1");
    });
    
    dispatch_group_async(group,globalQueue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"我是任务2");
    });
    
    dispatch_group_async(group,globalQueue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"我是任务3");
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"任务全部完成!");
    });

#dispatch_barrier_async

通过 dispatch_barrier_async 可以设置前面的执行完,后一个才执行，而且它后面的任务要等它执行完成之后才会开始

	dispatch_queue_t queue = dispatch_queue_create(NULL,NULL);
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:3];// 耗时的操作
        NSLog(@"task1");
    });
    
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"task2");
    });
    
    dispatch_barrier_async(queue, ^{
        [NSThread sleepForTimeInterval:4];
        NSLog(@"dispatch_barrier_async");
    });
    
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"task3");
    });

#小结

由于GCD里的任务队列在使用时是不可取消的,所以尽量不要使用GCD而是选择在其基础上封装的NSOperationQueue。

